<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="mpark/wg21" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2022-01-15" />
  <title>Relaxing some constexpr restrictions</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
      div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
      ul.task-list{list-style: none;}
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode
        {  background-color: #f6f8fa; }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span. { } /* Normal */
      code span.al { color: #ff0000; } /* Alert */
      code span.an { } /* Annotation */
      code span.at { } /* Attribute */
      code span.bn { color: #9f6807; } /* BaseN */
      code span.bu { color: #9f6807; } /* BuiltIn */
      code span.cf { color: #00607c; } /* ControlFlow */
      code span.ch { color: #9f6807; } /* Char */
      code span.cn { } /* Constant */
      code span.co { color: #008000; font-style: italic; } /* Comment */
      code span.cv { color: #008000; font-style: italic; } /* CommentVar */
      code span.do { color: #008000; } /* Documentation */
      code span.dt { color: #00607c; } /* DataType */
      code span.dv { color: #9f6807; } /* DecVal */
      code span.er { color: #ff0000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #9f6807; } /* Float */
      code span.fu { } /* Function */
      code span.im { } /* Import */
      code span.in { color: #008000; } /* Information */
      code span.kw { color: #00607c; } /* Keyword */
      code span.op { color: #af1915; } /* Operator */
      code span.ot { } /* Other */
      code span.pp { color: #6f4e37; } /* Preprocessor */
      code span.re { } /* RegionMarker */
      code span.sc { color: #9f6807; } /* SpecialChar */
      code span.ss { color: #9f6807; } /* SpecialString */
      code span.st { color: #9f6807; } /* String */
      code span.va { } /* Variable */
      code span.vs { color: #9f6807; } /* VerbatimString */
      code span.wa { color: #008000; font-weight: bold; } /* Warning */
      code.diff {color: #898887}
      code.diff span.va {color: #006e28}
      code.diff span.st {color: #bf0303}
  </style>
  <style type="text/css">
body {
margin: 5em;
font-family: serif;

hyphens: auto;
line-height: 1.35;
}
div.wrapper {
max-width: 60em;
margin: auto;
}
ul {
list-style-type: none;
padding-left: 2em;
margin-top: -0.2em;
margin-bottom: -0.2em;
}
a {
text-decoration: none;
color: #4183C4;
}
a.hidden_link {
text-decoration: none;
color: inherit;
}
li {
margin-top: 0.6em;
margin-bottom: 0.6em;
}
h1, h2, h3, h4 {
position: relative;
line-height: 1;
}
a.self-link {
position: absolute;
top: 0;
left: calc(-1 * (3.5rem - 26px));
width: calc(3.5rem - 26px);
height: 2em;
text-align: center;
border: none;
transition: opacity .2s;
opacity: .5;
font-family: sans-serif;
font-weight: normal;
font-size: 83%;
}
a.self-link:hover { opacity: 1; }
a.self-link::before { content: "ยง"; }
ul > li:before {
content: "\2014";
position: absolute;
margin-left: -1.5em;
}
:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }
.abbr_ref { float: right; }
.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }
:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }
.secnum { display: inline-block; min-width: 35pt; }
.header-section-number { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }
div.sourceLinkParent {
float: right;
}
a.sourceLink {
position: absolute;
opacity: 0;
margin-left: 10pt;
}
a.sourceLink:hover {
opacity: 1;
}
a.itemDeclLink {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
opacity: 0;
}
a.itemDeclLink:hover { opacity: 1; }
span.marginalizedparent {
position: relative;
left: -5em;
}
li span.marginalizedparent { left: -7em; }
li ul > li span.marginalizedparent { left: -9em; }
li ul > li ul > li span.marginalizedparent { left: -11em; }
li ul > li ul > li ul > li span.marginalizedparent { left: -13em; }
div.footnoteNumberParent {
position: relative;
left: -4.7em;
}
a.marginalized {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
}
a.enumerated_item_num {
position: relative;
left: -3.5em;
display: inline-block;
margin-right: -3em;
text-align: right;
width: 3em;
}
div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }
span.indexparent {
display: inline;
position: relative;
float: right;
right: -1em;
}
a.index {
position: absolute;
display: none;
}
a.index:before { content: "โต"; }

a.index:target {
display: inline;
}
.indexitems {
margin-left: 2em;
text-indent: -2em;
}
div.itemdescr {
margin-left: 3em;
}
.bnf {
font-family: serif;
margin-left: 40pt;
margin-top: 0.5em;
margin-bottom: 0.5em;
}
.ncbnf {
font-family: serif;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
}
.ncsimplebnf {
font-family: serif;
font-style: italic;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
background: inherit; 
}
span.textnormal {
font-style: normal;
font-family: serif;
white-space: normal;
display: inline-block;
}
span.rlap {
display: inline-block;
width: 0px;
}
span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }
span.phantom { color: white; }

span.math { font-style: normal; }
span.mathblock {
display: block;
margin-left: auto;
margin-right: auto;
margin-top: 1.2em;
margin-bottom: 1.2em;
text-align: center;
}
span.mathalpha {
font-style: italic;
}
span.synopsis {
font-weight: bold;
margin-top: 0.5em;
display: block;
}
span.definition {
font-weight: bold;
display: block;
}
.codeblock {
margin-left: 1.2em;
line-height: 127%;
}
.outputblock {
margin-left: 1.2em;
line-height: 127%;
}
div.itemdecl {
margin-top: 2ex;
}
code.itemdeclcode {
white-space: pre;
display: block;
}
span.textsuperscript {
vertical-align: super;
font-size: smaller;
line-height: 0;
}
.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }
.footnote {
font-size: small;
margin-left: 2em;
margin-right: 2em;
margin-top: 0.6em;
margin-bottom: 0.6em;
}
div.minipage {
display: inline-block;
margin-right: 3em;
}
div.numberedTable {
text-align: center;
margin: 2em;
}
div.figure {
text-align: center;
margin: 2em;
}
table {
border: 1px solid black;
border-collapse: collapse;
margin-left: auto;
margin-right: auto;
margin-top: 0.8em;
text-align: left;
hyphens: none; 
}
td, th {
padding-left: 1em;
padding-right: 1em;
vertical-align: top;
}
td.empty {
padding: 0px;
padding-left: 1px;
}
td.left {
text-align: left;
}
td.right {
text-align: right;
}
td.center {
text-align: center;
}
td.justify {
text-align: justify;
}
td.border {
border-left: 1px solid black;
}
tr.rowsep, td.cline {
border-top: 1px solid black;
}
tr.even, tr.odd {
border-bottom: 1px solid black;
}
tr.capsep {
border-top: 3px solid black;
border-top-style: double;
}
tr.header {
border-bottom: 3px solid black;
border-bottom-style: double;
}
th {
border-bottom: 1px solid black;
}
span.centry {
font-weight: bold;
}
div.table {
display: block;
margin-left: auto;
margin-right: auto;
text-align: center;
width: 90%;
}
span.indented {
display: block;
margin-left: 2em;
margin-bottom: 1em;
margin-top: 1em;
}
ol.enumeratea { list-style-type: none; background: inherit; }
ol.enumerate { list-style-type: none; background: inherit; }

code.sourceCode > span { display: inline; }
</style>
  <style type="text/css">a {
color : #4183C4;
text-decoration: underline;
}
a.marginalized {
text-decoration: none;
}
a.self-link {
text-decoration: none;
}
h1#toctitle {
border-bottom: 1px solid #cccccc;
}
#TOC li {
margin-top: 1px;
margin-bottom: 1px;
}
#TOC ul>li:before { display: none; }
h3.subtitle { margin-top: -15px; }
h1:target { background-color: transparent; }
h2:target { background-color: transparent; }
h3:target { background-color: transparent; }
h4:target { background-color: transparent; }
h5:target { background-color: transparent; }
h6:target { background-color: transparent; }
code span.co { font-family: monospace; }
table tr {
background-color: white;
}
table tr:nth-child(2n) {
background-color: #f6f8fa;
}
#title-block-header > table tr:nth-child(2n) {
background-color: white;
}
td > div.sourceCode {
background-color: inherit;
}
table {
border-collapse: collapse;
}
table td, table th {
border: 1px solid #cccccc;
}
table th {
border-bottom: 1px solid black;
text-align: center;
}
table tr:first-child th {
border-top: 0;
}
table tr:last-child td {
border-bottom: 0;
}
table tr td:first-child,
table tr th:first-child {
border-left: 0;
}
table tr td:last-child,
table tr th:last-child {
border-right: 0;
}
table tbody tr:first-child td {
border-top: 1px solid black;
}
#title-block-header td { border: 0; }
@media all {
body {
margin: 2em;
}
}
@media screen and (min-width: 480px) {
body {
margin: 5em;
}
}
#refs code{padding-left: 0px; text-indent: 0px;}
:root {
--diff-ins: #e6ffed;
--diff-strongins: #acf2bd;
--diff-del: #ffdddd;
--diff-strongdel: #ff8888;
}
span.diffins {
background-color: var(--diff-strongins);
}
span.diffdel {
background-color: var(--diff-strongdel);
}
div.rm { text-decoration: line-through; }
div.rm code.sourceCode { text-decoration: line-through; }
div.addu, span.addu {
color: #006e28;
background-color: var(--diff-ins);
}

div.rm pre, div.add pre { background-color: #f6f8fa; }
div.addu pre { background-color: var(--diff-ins); }
div.add, div.add pre { background-color: var(--diff-ins); }
div.addu blockquote {
border-left: 4px solid #00a000;
padding: 0 15px;
color: #006e28;
text-decoration: none;
}
div.addu blockquote code.sourceCode { text-decoration: none; }
div.addu blockquote pre { text-decoration: none; }
div.addu blockquote pre code { text-decoration: none; }
div.quote {
border-left: 7px solid #ccc;
background: #f9f9f9;
margin: 1.5em 10px;
padding-left: 20px;
}
code.diff span.va { color: #000000; background-color: var(--diff-ins); }
code.diff span.st { color: #000000; background-color: var(--diff-del); }
</style>
  <link href="data:image/x-icon;base64,AAABAAIAEBAAAAEAIABoBAAAJgAAACAgAAABACAAqBAAAI4EAAAoAAAAEAAAACAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAVoJEAN6CRADegkQAWIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wCCRAAAgkQAAIJEAACCRAAsgkQAvoJEAP+CRAD/gkQA/4JEAP+CRADAgkQALoJEAACCRAAAgkQAAP///wD///8AgkQAAIJEABSCRACSgkQA/IJEAP99PQD/dzMA/3czAP99PQD/gkQA/4JEAPyCRACUgkQAFIJEAAD///8A////AHw+AFiBQwDqgkQA/4BBAP9/PxP/uZd6/9rJtf/bybX/upd7/39AFP+AQQD/gkQA/4FDAOqAQgBc////AP///wDKklv4jlEa/3o7AP+PWC//8+3o///////////////////////z7un/kFox/35AAP+GRwD/mVYA+v///wD///8A0Zpk+NmibP+0d0T/8evj///////+/fv/1sKz/9bCs//9/fr//////+/m2/+NRwL/nloA/5xYAPj///8A////ANKaZPjRmGH/5cKh////////////k149/3UwAP91MQD/lmQ//86rhv+USg3/m1YA/5hSAP+bVgD4////AP///wDSmmT4zpJY/+/bx///////8+TV/8mLT/+TVx//gkIA/5lVAP+VTAD/x6B//7aEVv/JpH7/s39J+P///wD///8A0ppk+M6SWP/u2sf///////Pj1f/Nj1T/2KFs/8mOUv+eWhD/lEsA/8aee/+0glT/x6F7/7J8Rvj///8A////ANKaZPjRmGH/48Cf///////+/v7/2qt//82PVP/OkFX/37KJ/86siv+USg7/mVQA/5hRAP+bVgD4////AP///wDSmmT40ppk/9CVXP/69O////////7+/v/x4M//8d/P//7+/f//////9u7n/6tnJf+XUgD/nFgA+P///wD///8A0ppk+NKaZP/RmWL/1qNy//r07///////////////////////+vXw/9akdP/Wnmn/y5FY/6JfFvj///8A////ANKaZFTSmmTo0ppk/9GYYv/Ql1//5cWm//Hg0P/x4ND/5cWm/9GXYP/RmGH/0ppk/9KaZOjVnmpY////AP///wDSmmQA0ppkEtKaZI7SmmT60ppk/9CWX//OkVb/zpFW/9CWX//SmmT/0ppk/NKaZJDSmmQS0ppkAP///wD///8A0ppkANKaZADSmmQA0ppkKtKaZLrSmmT/0ppk/9KaZP/SmmT/0ppkvNKaZCrSmmQA0ppkANKaZAD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkUtKaZNzSmmTc0ppkVNKaZADSmmQA0ppkANKaZADSmmQA////AP5/AAD4HwAA4AcAAMADAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAMADAADgBwAA+B8AAP5/AAAoAAAAIAAAAEAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAyCRACMgkQA6oJEAOqCRACQgkQAEIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRABigkQA5oJEAP+CRAD/gkQA/4JEAP+CRADqgkQAZoJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAA4gkQAwoJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQAxIJEADyCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAP///wD///8A////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAWgkQAmIJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAJyCRAAYgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAdIJEAPCCRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAPSCRAB4gkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQASoJEANKCRAD/gkQA/4JEAP+CRAD/g0YA/39AAP9zLgD/bSQA/2shAP9rIQD/bSQA/3MuAP9/PwD/g0YA/4JEAP+CRAD/gkQA/4JEAP+CRADUgkQAToJEAACCRAAAgkQAAP///wD///8A////AP///wB+PwAAgkUAIoJEAKiCRAD/gkQA/4JEAP+CRAD/hEcA/4BBAP9sIwD/dTAA/5RfKv+viF7/vp56/76ee/+wiF7/lWAr/3YxAP9sIwD/f0AA/4RHAP+CRAD/gkQA/4JEAP+CRAD/gkQArIJEACaBQwAA////AP///wD///8A////AIBCAEBzNAD6f0EA/4NFAP+CRAD/gkQA/4VIAP92MwD/bSUA/6N1Tv/ezsL/////////////////////////////////38/D/6V3Uv9uJgD/dTEA/4VJAP+CRAD/gkQA/4JEAP+BQwD/fUAA/4FDAEj///8A////AP///wD///8AzJRd5qBlKf91NgD/dDUA/4JEAP+FSQD/cy4A/3YyAP/PuKP//////////////////////////////////////////////////////9K7qP94NQD/ciwA/4VJAP+CRAD/fkEA/35BAP+LSwD/mlYA6v///wD///8A////AP///wDdpnL/4qx3/8KJUv+PUhf/cTMA/3AsAP90LgD/4dK+/////////////////////////////////////////////////////////////////+TYxf91MAD/dTIA/31CAP+GRwD/llQA/6FcAP+gWwD8////AP///wD///8A////ANGZY/LSm2X/4ap3/92mcP+wdT3/byQA/8mwj////////////////////////////////////////////////////////////////////////////+LYxv9zLgP/jUoA/59bAP+hXAD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/RmWL/1p9q/9ubXv/XqXj////////////////////////////7+fD/vZyG/6BxS/+gcUr/vJuE//r37f//////////////////////3MOr/5dQBf+dVQD/nVkA/5xYAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmWP/yohJ//jo2P//////////////////////4NTG/4JDFf9lGAD/bSQA/20kAP9kGAD/fz8S/+Xb0f//////5NG9/6txN/+LOgD/m1QA/51aAP+cWAD/m1cA/5xYAP+cWADy////AP///wD///8A////ANKaZPLSmmT/0ppk/8+TWf/Unmv//v37//////////////////////+TWRr/VwsA/35AAP+ERgD/g0UA/4JGAP9lHgD/kFga/8KXX/+TRwD/jT4A/49CAP+VTQD/n10A/5xYAP+OQQD/lk4A/55cAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/y4tO/92yiP//////////////////////8NnE/8eCQP+rcTT/ez0A/3IyAP98PgD/gEMA/5FSAP+USwD/jj8A/5lUAP+JNwD/yqV2/694Mf+HNQD/jkAA/82rf/+laBj/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/LiUr/4byY///////////////////////gupX/0I5P/+Wuev/Lklz/l1sj/308AP+QSwD/ol0A/59aAP+aVQD/k0oA/8yoh///////+fXv/6pwO//Lp3v///////Pr4f+oay7y////AP///wD///8A////ANKaZPLSmmT/0ppk/8uJSv/hvJj//////////////////////+G7l//Jhkb/0ppk/96nc//fqXX/x4xO/6dkFP+QSQD/llEA/5xXAP+USgD/yaOA///////38uv/qG05/8ijdv//////8efb/6ZpLPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/zIxO/9yxh///////////////////////7dbA/8iEQf/Sm2X/0Zlj/9ScZv/eqHf/2KJv/7yAQf+XTgD/iToA/5lSAP+JNgD/yKFv/611LP+HNQD/jT8A/8qmeP+kZRT/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/Pk1n/1J5q//78+//////////////////+/fv/1aFv/8iEQv/Tm2b/0ppl/9GZY//Wn2z/1pZc/9eldf/Bl2b/kUcA/4w9AP+OQAD/lUwA/59eAP+cWQD/jT8A/5ZOAP+eXADy////AP///wD///8A////ANKaZPLSmmT/0ppk/9KZY//KiEn/8d/P///////////////////////47+f/05tm/8iCP//KiEj/yohJ/8eCP//RmGH//vfy///////n1sP/rXQ7/4k4AP+TTAD/nVoA/5xYAP+cVwD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/0ptl/8uLTf/aq37////////////////////////////+/fz/6c2y/961jv/etY7/6Myx//78+v//////////////////////3MWv/5xXD/+ORAD/mFQA/51ZAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmmT/0ppk/8mFRP/s1b//////////////////////////////////////////////////////////////////////////////+PD/0JFU/7NzMv+WUQD/kUsA/5tXAP+dWQDy////AP///wD///8A////ANKaZP/SmmT/0ppk/9KaZP/Sm2X/z5NZ/8yMT//z5NX/////////////////////////////////////////////////////////////////9Ofa/8yNUP/UmGH/36p5/8yTWv+qaSD/kksA/5ROAPz///8A////AP///wD///8A0ppk5NKaZP/SmmT/0ppk/9KaZP/TnGf/zY9T/82OUv/t1sD//////////////////////////////////////////////////////+7Yw//OkFX/zI5R/9OcZ//SmmP/26V0/9ymdf/BhUf/ol8R6P///wD///8A////AP///wDSmmQ80ppk9tKaZP/SmmT/0ppk/9KaZP/TnGj/zpFW/8qJSv/dson/8uHS//////////////////////////////////Lj0//etIv/y4lL/86QVf/TnGj/0ppk/9KaZP/RmWP/05xn/9ymdfjUnWdC////AP///wD///8A////ANKaZADSmmQc0ppkotKaZP/SmmT/0ppk/9KaZP/Tm2b/0Zli/8qJSf/NjlH/16Z3/+G8mP/myKr/5siq/+G8mP/Xp3f/zY5S/8qISf/RmGH/05tm/9KaZP/SmmT/0ppk/9KaZP/SmmSm0pljINWdaQD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkQtKaZMrSmmT/0ppk/9KaZP/SmmT/0ptl/9GYYf/Nj1P/y4lL/8qISP/KiEj/y4lK/82PU//RmGH/0ptl/9KaZP/SmmT/0ppk/9KaZP/SmmTO0ppkRtKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZGzSmmTu0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmTw0ppkcNKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZBLSmmSQ0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppklNKaZBTSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQy0ppkutKaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppkvtKaZDbSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkXNKaZODSmmT/0ppk/9KaZP/SmmT/0ppk5NKaZGDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkBtKaZIbSmmTo0ppk6tKaZIrSmmQK0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP/8P///+B///+AH//+AAf//AAD//AAAP/AAAA/gAAAHwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA+AAAAfwAAAP/AAAP/8AAP//gAH//+AH///4H////D//" rel="icon" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
</head>
<body>
<div class="wrapper">
<header id="title-block-header">
<h1 class="title" style="text-align:center">Relaxing some <code class="sourceCode cpp"><span class="kw">constexpr</span></code> restrictions</h1>

<table style="border:none;float:right">
  <tr>
    <td>Document #:</td>
    <td>P2448R1</td>
  </tr>
  <tr>
    <td>Date:</td>
    <td>2022-01-15</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Project:</td>
    <td>Programming Language C++</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Audience:</td>
    <td>
      CWG<br>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top">Reply-to:</td>
    <td>
      Barry Revzin<br>&lt;<a href="mailto:barry.revzin@gmail.com" class="email">barry.revzin@gmail.com</a>&gt;<br>
    </td>
  </tr>
</table>

</header>
<div style="clear:both">
<div id="TOC" role="doc-toc">
<h1 id="toctitle">Contents</h1>
<ul>
<li><a href="#abstract"><span class="toc-section-number">1</span> Abstract<span></span></a></li>
<li><a href="#revision-history"><span class="toc-section-number">2</span> Revision History<span></span></a></li>
<li><a href="#maybe-not-now-but-soon"><span class="toc-section-number">3</span> Maybe Not Now, But Soon<span></span></a></li>
<li><a href="#sometimes-maybe-sometimes-always"><span class="toc-section-number">4</span> Sometimes Maybe, Sometimes Always<span></span></a></li>
<li><a href="#onwards-to-constexpr-classes"><span class="toc-section-number">5</span> Onwards to constexpr classes<span></span></a></li>
<li><a href="#getting-rid-of-constexpr-compatible"><span class="toc-section-number">6</span> Getting rid of constexpr-compatible<span></span></a>
<ul>
<li><a href="#going-deeper"><span class="toc-section-number">6.1</span> Going Deeper<span></span></a></li>
<li><a href="#going-deeper-1"><span class="toc-section-number">6.2</span> Going Deeper<span></span></a></li>
</ul></li>
<li><a href="#proposal"><span class="toc-section-number">7</span> Proposal<span></span></a></li>
<li><a href="#bibliography"><span class="toc-section-number">8</span> References<span></span></a></li>
</ul>
</div>
<h1 data-number="1" style="border-bottom:1px solid #cccccc" id="abstract"><span class="header-section-number">1</span> Abstract<a href="#abstract" class="self-link"></a></h1>
<p>There are two rules about <code class="sourceCode cpp"><span class="kw">constexpr</span></code> programming that make code ill-formed or ill-formed (no diagnostic required) when functions or function templates are marked <code class="sourceCode cpp"><span class="kw">constexpr</span></code> that might never evaluate to a constant expression. Butโฆ so what if they donโt? The goal of this paper is to stop diagnosing problems that donโt exist.</p>
<h1 data-number="2" style="border-bottom:1px solid #cccccc" id="revision-history"><span class="header-section-number">2</span> Revision History<a href="#revision-history" class="self-link"></a></h1>
<p>Since <span class="citation" data-cites="P2448R0">[<a href="#ref-P2448R0" role="doc-biblioref">P2448R0</a>]</span>, CWG telecon pointed out that there were several other rules that could be striken in the same theme. Updated wording.</p>
<p>A draft of the first revision of this paper was discussed in an <a href="https://wiki.edg.com/bin/view/Wg21telecons2021/EWG-2021-10-13">EWG telecon</a>, where the following poll was taken:</p>
<blockquote>
<p>send P2448 to electronic polling, targeting CWG for C++23.</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>SF</strong>
</div></th>
<th><div style="text-align:center">
<strong>F</strong>
</div></th>
<th><div style="text-align:center">
<strong>N</strong>
</div></th>
<th><div style="text-align:center">
<strong>A</strong>
</div></th>
<th><div style="text-align:center">
<strong>SA</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>10</td>
<td>8</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
</blockquote>
<p>This first published revision thus targets CWG.</p>
<h1 data-number="3" style="border-bottom:1px solid #cccccc" id="maybe-not-now-but-soon"><span class="header-section-number">3</span> Maybe Not Now, But Soon<a href="#maybe-not-now-but-soon" class="self-link"></a></h1>
<p><code class="sourceCode cpp"><span class="kw">constexpr</span></code> functions and function templates in C++ generally speaking mean <em>maybe</em> <code class="sourceCode cpp"><span class="kw">constexpr</span></code>. Not all instantiations or evaluations must be invocable at compile time, itโs just that there must be at least one set of function arguments in at least one instantiation that works.</p>
<p>And this isnโt just generally speaking, this is enshrined as a rule: <span>9.2.6 <a href="https://wg21.link/dcl.constexpr">[dcl.constexpr]</a></span>/6:</p>
<div class="quote">
<p>For a constexpr function or constexpr constructor that is neither defaulted nor a template, if no argument values exist such that an invocation of the function or constructor could be an evaluated subexpression of a core constant expression, or, for a constructor, an evaluated subexpression of the initialization full-expression of some constant-initialized object ([basic.start.static]), the program is ill-formed, no diagnostic required.</p>
</div>
<p>Here is an example of a program that violates this rule:</p>
<blockquote>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="dt">void</span> f<span class="op">(</span><span class="dt">int</span><span class="op">&amp;</span> i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>    i <span class="op">=</span> <span class="dv">0</span>;</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="op">}</span></span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">constexpr</span> <span class="dt">void</span> g<span class="op">(</span><span class="dt">int</span><span class="op">&amp;</span> i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>    f<span class="op">(</span>i<span class="op">)</span>;</span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p><code class="sourceCode cpp">g</code> unconditionally calls <code class="sourceCode cpp">f</code>, which is not a <code class="sourceCode cpp"><span class="kw">constexpr</span></code> function, so there does not exist any invocation that would be a constant expression. Ill-formed, no diagnostic required. gcc and msvc both diagnose this.</p>
<p>Now, one could argue that this diagnosis is a good thing: that <code class="sourceCode cpp"><span class="kw">constexpr</span></code> annotation on <code class="sourceCode cpp">g</code> makes no sense! It canโt be a constant expression, so having that specifier on the function is misleading. Diagnosing this error helps the programmer realize that they were mistaken and they can take steps to change this. That seems compelling enough.</p>
<p>Consider instead this example:</p>
<blockquote>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="pp">#include </span><span class="im">&lt;optional&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="kw">constexpr</span> <span class="dt">void</span> h<span class="op">(</span>std<span class="op">::</span>optional<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> o<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>    o<span class="op">.</span>reset<span class="op">()</span>;</span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>Here, <code class="sourceCode cpp">h</code> is the exact same kind of function as <code class="sourceCode cpp">g</code>: we have a function unconditionally calling another non-<code class="sourceCode cpp"><span class="kw">constexpr</span></code> function. At least, thatโs true for C++17. Itโs wonโt be true in C++23, and the answer for C++20 depends on how vendors choose to implement <span class="citation" data-cites="P2231R1">[<a href="#ref-P2231R1" role="doc-biblioref">P2231R1</a>]</span>. Here the answer depends: some functions can easily be <code class="sourceCode cpp"><span class="kw">constexpr</span></code> in one standard but not in earlier ones.</p>
<p>Now, the sanctioned way to fix this code is to write:</p>
<blockquote>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="pp">#include </span><span class="im">&lt;optional&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="pp">#if __cpp_lib_optional &gt;= 202106</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="kw">constexpr</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="pp">#endif</span></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="dt">void</span> h<span class="op">(</span>std<span class="op">::</span>optional<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> o<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>    o<span class="op">.</span>reset<span class="op">()</span>;</span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>This way, <code class="sourceCode cpp">h</code> will be <code class="sourceCode cpp"><span class="kw">constexpr</span></code> when the appropriate library changes are made, allowing it to be. Butโฆ is this better?</p>
<p>I would argue itโs not. The language rules for <code class="sourceCode cpp"><span class="kw">constexpr</span></code> have expanded in every language standard since <code class="sourceCode cpp"><span class="kw">constexpr</span></code> was introduced. Standard library support will always lag that. Third-party library support likely even more so. So the answer to the question โare there any arguments for which this function can be a constant expression?โ can easily be No in C++N but Yes in C++N+1, for a wide variety of functions. Does forcing conscientious library authors to take painstaking care in conditionally marking function <code class="sourceCode cpp"><span class="kw">constexpr</span></code> provide value to the ecosystem? Iโm skeptical that it does.</p>
<p>Moreover, while itโs possible to write the above for <code class="sourceCode cpp">std<span class="op">::</span>optional</code>, Iโm not sure that itโs common for other library to provide macros that can be used to mark functions conditionally <code class="sourceCode cpp"><span class="kw">constexpr</span></code> like this. Or, indeed, if there is even another such example. So if Iโm a consumer of a library that might have some functionality <code class="sourceCode cpp"><span class="kw">constexpr</span></code> in one version but more functionality <code class="sourceCode cpp"><span class="kw">constexpr</span></code> in the next, I always have to lag.</p>
<p>Such diagnosis may have made sense in the C++11 days, but now that weโre approaching C++23 where more and more things are <code class="sourceCode cpp"><span class="kw">constexpr</span></code> and more and more libraries will mark more of their functions <code class="sourceCode cpp"><span class="kw">constexpr</span></code> because they can be, it seems strictly better to just reserve diagnosing <code class="sourceCode cpp"><span class="kw">constexpr</span></code> violations to the place where we already have to diagnose them: when you write code that <em>must</em> be evaluated at compile time.</p>
<p>Put differently, the current rule is there must be some tuple (function arguments, template arguments) for which a <code class="sourceCode cpp"><span class="kw">constexpr</span></code> function invocation is a constant expression. But thereโs really another input here: (function arguments, template arguments, version). The version here might be the language version, it might be a bunch of library versions. Ultimately, itโs a question of time. A function may not be <code class="sourceCode cpp"><span class="kw">constexpr</span></code> today, but it may be <code class="sourceCode cpp"><span class="kw">constexpr</span></code> soon. Diagnosing it as not being <code class="sourceCode cpp"><span class="kw">constexpr</span></code> <em>yet</em> seems harmful to the question of evolving code.</p>
<h1 data-number="4" style="border-bottom:1px solid #cccccc" id="sometimes-maybe-sometimes-always"><span class="header-section-number">4</span> Sometimes Maybe, Sometimes Always<a href="#sometimes-maybe-sometimes-always" class="self-link"></a></h1>
<p><code class="sourceCode cpp"><span class="kw">constexpr</span></code> usually means <em>maybe</em> <code class="sourceCode cpp"><span class="kw">constexpr</span></code>. But sometimes it actually means <em>always</em> <code class="sourceCode cpp"><span class="kw">constexpr</span></code>. That case comes up with explicitly defaulted functions. From <span>9.5.2 <a href="https://wg21.link/dcl.fct.def.default">[dcl.fct.def.default]</a></span>/3:</p>
<div class="quote">
<p>An explicitly-defaulted function that is not defined as deleted may be declared <code class="sourceCode cpp"><span class="kw">constexpr</span></code> or <code class="sourceCode cpp"><span class="kw">consteval</span></code> only if it is <code class="sourceCode cpp"><span class="kw">constexpr</span></code>-compatible ([special], [class.compare.default]). A function explicitly defaulted on its first declaration is implicitly inline ([dcl.inline]), and is implicitly constexpr ([dcl.constexpr]) if it is constexpr-compatible.</p>
</div>
<p>Letโs say Iโm writing a wrapper class template that Iโm intending to be usable during compile time:</p>
<blockquote>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="kw">struct</span> Wrapper <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>    <span class="kw">constexpr</span> Wrapper<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb4-4"><a href="#cb4-4"></a>    <span class="kw">constexpr</span> Wrapper<span class="op">(</span>Wrapper <span class="kw">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb4-5"><a href="#cb4-5"></a>    <span class="kw">constexpr</span> Wrapper<span class="op">(</span>T <span class="kw">const</span><span class="op">&amp;</span> t<span class="op">)</span> <span class="op">:</span> t<span class="op">(</span>t<span class="op">)</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb4-6"><a href="#cb4-6"></a></span>
<span id="cb4-7"><a href="#cb4-7"></a>    <span class="kw">constexpr</span> T get<span class="op">()</span> <span class="kw">const</span> <span class="op">{</span> <span class="cf">return</span> t; <span class="op">}</span></span>
<span id="cb4-8"><a href="#cb4-8"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Wrapper <span class="kw">const</span><span class="op">&amp;)</span> <span class="kw">const</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb4-10"><a href="#cb4-10"></a>    T t;</span>
<span id="cb4-11"><a href="#cb4-11"></a><span class="op">}</span>;</span></code></pre></div>
</blockquote>
<p>I might take the strategy of just marking every function <code class="sourceCode cpp"><span class="kw">constexpr</span></code>. Both for consistency and also as a strategy to avoid forgetting to mark some functions <code class="sourceCode cpp"><span class="kw">constexpr</span></code>.</p>
<p>But then I try to use it:</p>
<blockquote>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">struct</span> X <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>    X<span class="op">()</span>;</span>
<span id="cb5-3"><a href="#cb5-3"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>X <span class="kw">const</span><span class="op">&amp;)</span> <span class="kw">const</span>;</span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="op">}</span>;</span>
<span id="cb5-5"><a href="#cb5-5"></a></span>
<span id="cb5-6"><a href="#cb5-6"></a>Wrapper<span class="op">&lt;</span>X<span class="op">&gt;</span> x;</span></code></pre></div>
</blockquote>
<p>None of this code is trying to evaluate anything during constant evaluation, yet it is already ill-formed. gcc and clang already diagnose at this point. msvc and icc do not, but this rule is a mandatory diagnostic, so they are mistaken. Although, even here, none of the compilers care that I erroneously marked the default constructor <code class="sourceCode cpp"><span class="kw">constexpr</span></code>. And none of them care that I erroneously marked the copy constructor <code class="sourceCode cpp"><span class="kw">constexpr</span></code>. gcc and clang are only diagnosing <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==</span></code> here (even though Iโm not even using it).</p>
<p>But why do we even have this rule in the first place? Note that if I wrote my equality operator this way:</p>
<blockquote>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Wrapper <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">const</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>    <span class="cf">return</span> t <span class="op">==</span> rhs<span class="op">.</span>t;</span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>That is, manually writing out what the defaulted version does, even with marking it <code class="sourceCode cpp"><span class="kw">constexpr</span></code>, this code is perfectly valid C++ code. It doesnโt matter that Iโm marking this function <code class="sourceCode cpp"><span class="kw">constexpr</span></code>, because in this context, the only requirement is that <em>some</em> instantiation can be a constant expression. But because I want to <code class="sourceCode cpp"><span class="op">=</span> <span class="cf">default</span></code> it, suddenly <em>every</em> instantiation has to be a constant expression?</p>
<p>What this means is that the correct way to write my wrapper type is:</p>
<blockquote>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="kw">struct</span> Wrapper <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>    Wrapper<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb7-4"><a href="#cb7-4"></a>    Wrapper<span class="op">(</span>Wrapper <span class="kw">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb7-5"><a href="#cb7-5"></a>    <span class="kw">constexpr</span> Wrapper<span class="op">(</span>T <span class="kw">const</span><span class="op">&amp;</span> t<span class="op">)</span> <span class="op">:</span> t<span class="op">(</span>t<span class="op">)</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb7-6"><a href="#cb7-6"></a></span>
<span id="cb7-7"><a href="#cb7-7"></a>    <span class="kw">constexpr</span> T get<span class="op">()</span> <span class="kw">const</span> <span class="op">{</span> <span class="cf">return</span> t; <span class="op">}</span></span>
<span id="cb7-8"><a href="#cb7-8"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Wrapper <span class="kw">const</span><span class="op">&amp;)</span> <span class="kw">const</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb7-9"><a href="#cb7-9"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb7-10"><a href="#cb7-10"></a>    T t;</span>
<span id="cb7-11"><a href="#cb7-11"></a><span class="op">}</span>;</span></code></pre></div>
</blockquote>
<p>So I have some functions marked <code class="sourceCode cpp"><span class="kw">constexpr</span></code> and some not, but all of them are still usable during constant evaluation time (where appropriate based on <code class="sourceCode cpp">T</code>). The lack of consistency here is a bit jarring. <code class="sourceCode cpp"><span class="kw">constexpr</span></code> functions should always be <em>maybe</em> <code class="sourceCode cpp"><span class="kw">constexpr</span></code>, not <em>must be</em> <code class="sourceCode cpp"><span class="kw">constexpr</span></code>.</p>
<h1 data-number="5" style="border-bottom:1px solid #cccccc" id="onwards-to-constexpr-classes"><span class="header-section-number">5</span> Onwards to constexpr classes<a href="#onwards-to-constexpr-classes" class="self-link"></a></h1>
<p>We have a proposal in front of us to allow annotating the entire class as being <code class="sourceCode cpp"><span class="kw">constexpr</span></code>, to avoid all these extra annotations <span class="citation" data-cites="P2350R1">[<a href="#ref-P2350R1" role="doc-biblioref">P2350R1</a>]</span>. And that proposal currently runs into both issues:</p>
<blockquote>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="kw">struct</span> Wrapper <span class="kw">constexpr</span> <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>    Wrapper<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb8-4"><a href="#cb8-4"></a>    Wrapper<span class="op">(</span>Wrapper <span class="kw">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb8-5"><a href="#cb8-5"></a>    Wrapper<span class="op">(</span>T <span class="kw">const</span><span class="op">&amp;</span> t<span class="op">)</span> <span class="op">:</span> t<span class="op">(</span>t<span class="op">)</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb8-6"><a href="#cb8-6"></a></span>
<span id="cb8-7"><a href="#cb8-7"></a>    <span class="dt">void</span> reset<span class="op">()</span> <span class="op">{</span> t<span class="op">.</span>reset<span class="op">()</span>; <span class="op">}</span></span>
<span id="cb8-8"><a href="#cb8-8"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Wrapper <span class="kw">const</span><span class="op">&amp;)</span> <span class="kw">const</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb8-10"><a href="#cb8-10"></a>    std<span class="op">::</span>optional<span class="op">&lt;</span>T<span class="op">&gt;</span> t;</span>
<span id="cb8-11"><a href="#cb8-11"></a><span class="op">}</span>;</span></code></pre></div>
</blockquote>
<p>Are all of these functions okay? I would argue that they <em>should</em> all be okay, but per the wording theyโre currently not.</p>
<p>I want <code class="sourceCode cpp">Wrapper</code> to be entirely <code class="sourceCode cpp"><span class="kw">constexpr</span></code> where feasible. Some of those functions may not be <code class="sourceCode cpp"><span class="kw">constexpr</span></code> for all types, and thatโs fine. Some of these functions may not be able to be <code class="sourceCode cpp"><span class="kw">constexpr</span></code> in C++N but may be later, and I donโt want to have to go back and either annotate against this (which I donโt think P2350 even allows room for) or stop using this feature and go back to manually marking and even more annotations.</p>
<h1 data-number="6" style="border-bottom:1px solid #cccccc" id="getting-rid-of-constexpr-compatible"><span class="header-section-number">6</span> Getting rid of constexpr-compatible<a href="#getting-rid-of-constexpr-compatible" class="self-link"></a></h1>
<p>With the wording suggested in the first revision of this paper <span class="citation" data-cites="P2448R0">[<a href="#ref-P2448R0" role="doc-biblioref">P2448R0</a>]</span>, functions (even defaulted special member functions) could be declared <code class="sourceCode cpp"><span class="kw">constexpr</span></code> without this leading to either a diagnostic or leading to a program being ill-formed, no diagnostic required.</p>
<p>During the CWG telecon discussing that paper, it was brought up that we can go further. For instance, we have a term <em>constexpr-compatible</em>. Currently used by <span>9.5.2 <a href="https://wg21.link/dcl.fct.def.default">[dcl.fct.def.default]</a></span>/3:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_1" id="pnum_1">3</a></span> An explicitly-defaulted function that is not defined as deleted may be declared <code class="sourceCode cpp"><span class="kw">constexpr</span></code> or <code class="sourceCode cpp"><span class="kw">consteval</span></code> only if it is constexpr-compatible ([special], [class.compare.default]). A function explicitly defaulted on its first declaration is implicitly inline ([dcl.inline]), and is implicitly constexpr ([dcl.constexpr]) if it is constexpr-compatible.</p>
</blockquote>
<p>Where special member functions are considered constexpr-compatible when:</p>
<ul>
<li><p>Comparisons (<span>11.10.1 <a href="https://wg21.link/class.compare.default">[class.compare.default]</a></span>/4):</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_2" id="pnum_2">4</a></span> A defaulted comparison function is constexpr-compatible if it satisfies the requirements for a constexpr function ([dcl.constexpr]) and no overload resolution performed when determining whether to delete the function results in a usable candidate that is a non-constexpr function.</p>
</blockquote></li>
<li><p>Special members (<span>11.4.4 <a href="https://wg21.link/special">[special]</a></span>/8):</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_3" id="pnum_3">8</a></span> A defaulted special member function is constexpr-compatible if the corresponding implicitly-declared special member function would be a constexpr function.</p>
</blockquote></li>
</ul>
<p>The special member case depends on the kind of special member function:</p>
<ul>
<li>default/copy/move constructor: satisfy the requirements of a constexpr constructor (every constructor selected for each base and member is constexpr, no virtual base classes)</li>
<li>copy/move assignment: class is literal, every assignment selected for each base and member is constexpr</li>
<li>destructor: satisfies the requirements for constexpr destructor (every destructor selected for each base and member is constexpr, no virtual bases)</li>
</ul>
<p>It would be, within the spirit of this paper, to significantly reduce these restrictions as follows. First, we can remove the restrictions on constexpr constructors and destructors(from <span>9.2.6 <a href="https://wg21.link/dcl.constexpr">[dcl.constexpr]</a></span>/4 and /5):</p>
<blockquote>
<div class="rm" style="color: #bf0303">
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_4" id="pnum_4">4</a></span> The definition of a constexpr constructor whose <em>function-body</em> is not <code class="sourceCode default">= delete</code> shall additionally satisfy the following requirements:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_5" id="pnum_5">(4.1)</a></span> for a non-delegating constructor, every constructor selected to initialize non-static data members and base class subobjects shall be a constexpr constructor;</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_6" id="pnum_6">(4.2)</a></span> for a delegating constructor, the target constructor shall be a constexpr constructor.</li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_7" id="pnum_7">5</a></span> The definition of a constexpr destructor whose <em>function-body</em> is not <code class="sourceCode default">= delete</code> shall additionally satisfy the following requirement:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_8" id="pnum_8">(5.1)</a></span> for every subobject of class type or (possibly multi-dimensional) array thereof, that class type shall have a constexpr destructor.</li>
</ul>

</div>
</blockquote>
<p>After this, if we allow a constexpr copy/move assignment even for non-literal classes, then we can basically make all defaulted functions constexpr except for constructors and destructors for types that have virtual base classes. This also means that we can remove the term <em>constexpr-compatible</em> since we would no longer need to use it anywhere. Thatโs a nice chunk of specification improvement, removing rules that nobody really needs.</p>
<h2 data-number="6.1" id="going-deeper"><span class="header-section-number">6.1</span> Going Deeper<a href="#going-deeper" class="self-link"></a></h2>
<p>We could go one step further and drop further uses of literal type in <span>9.2.6 <a href="https://wg21.link/dcl.constexpr">[dcl.constexpr]</a></span>/3:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_9" id="pnum_9">3</a></span> The definition of a constexpr function shall satisfy the following requirements:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_10" id="pnum_10">(3.1)</a></span> <span class="rm" style="color: #bf0303"><del>its return type (if any) shall be a literal type;</del></span></li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_11" id="pnum_11">(3.2)</a></span> <span class="rm" style="color: #bf0303"><del>each of its parameter types shall be a literal type;</del></span></li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_12" id="pnum_12">(3.3)</a></span> it shall not be a coroutine;</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_13" id="pnum_13">(3.4)</a></span> if the function is a constructor or destructor, its class shall not have any virtual base classes.</li>
</ul>
</blockquote>
<p>The first two sub-bullets are also very much in the spirit of this paper. A type could be not literal yet in C++N but could become literal in C++N+1, it would be nice if we could simply mark such functions <code class="sourceCode cpp"><span class="kw">constexpr</span></code> regardless (as Iโve already noted the desire to do for copy/move assignment in the previous section).</p>
<h2 data-number="6.2" id="going-deeper-1"><span class="header-section-number">6.2</span> Going Deeper<a href="#going-deeper-1" class="self-link"></a></h2>
<p>Once we eliminate those two bullets, we only have two rules for the requirements of a constexpr function: not a coroutine, and not a constuctor/destructor of a class that has virtual base classes. Iโm not entirely sure why we need the latter rule either, but it could also be moved elsewhere โ that is, the problem isnโt <em>declaring</em> a constexpr constructor for a class with a virtual base, the problem is trying to <em>initialize</em> such a type during constant evaluation. Similar to how we removed the restriction on <code class="sourceCode cpp"><span class="cf">try</span></code>/<code class="sourceCode cpp"><span class="cf">catch</span></code> while still disallowing throwing.</p>
<p>This would actually allow further specification cleanup, since now we could just say that all implicit constructors are <code class="sourceCode cpp"><span class="kw">constexpr</span></code>. But itโs a much bigger step and Iโm not sure that we should take it at this time.</p>
<h1 data-number="7" style="border-bottom:1px solid #cccccc" id="proposal"><span class="header-section-number">7</span> Proposal<a href="#proposal" class="self-link"></a></h1>
<p>Strike two bullets from <span>9.2.6 <a href="https://wg21.link/dcl.constexpr">[dcl.constexpr]</a></span>/3, as well as paragraphs /4, /5, /6, their examples, and part of 7:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_14" id="pnum_14">3</a></span> The definition of a constexpr function shall satisfy the following requirements:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_15" id="pnum_15">(3.1)</a></span> <span class="rm" style="color: #bf0303"><del>its return type (if any) shall be a literal type;</del></span></li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_16" id="pnum_16">(3.2)</a></span> <span class="rm" style="color: #bf0303"><del>each of its parameter types shall be a literal type;</del></span></li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_17" id="pnum_17">(3.3)</a></span> it shall not be a coroutine;</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_18" id="pnum_18">(3.4)</a></span> if the function is a constructor or destructor, its class shall not have any virtual base classes.</li>
</ul>
<p>[<em>Example 2:</em></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb9-1"><a href="#cb9-1"></a>// ...</span></code></pre></div>
<p><em>-end example</em>]</p>
<div class="rm" style="color: #bf0303">
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_19" id="pnum_19">4</a></span> The definition of a constexpr constructor whose <em>function-body</em> is not <code class="sourceCode default">= delete</code> shall additionally satisfy the following requirements:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_20" id="pnum_20">(4.1)</a></span> for a non-delegating constructor, every constructor selected to initialize non-static data members and base class subobjects shall be a constexpr constructor;</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_21" id="pnum_21">(4.2)</a></span> for a delegating constructor, the target constructor shall be a constexpr constructor.</li>
</ul>
<p>[<em>Example 3</em>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode default default"><code class="sourceCode default"><span id="cb10-1"><a href="#cb10-1"></a>struct Length {</span>
<span id="cb10-2"><a href="#cb10-2"></a>  constexpr explicit Length(int i = 0) : val(i) { }</span>
<span id="cb10-3"><a href="#cb10-3"></a>private:</span>
<span id="cb10-4"><a href="#cb10-4"></a>  int val;</span>
<span id="cb10-5"><a href="#cb10-5"></a>};</span></code></pre></div>
<p><em>โ end example</em>]</p>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_22" id="pnum_22">5</a></span> The definition of a constexpr destructor whose <em>function-body</em> is not <code class="sourceCode default">= delete</code> shall additionally satisfy the following requirement:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_23" id="pnum_23">(5.1)</a></span> for every subobject of class type or (possibly multi-dimensional) array thereof, that class type shall have a constexpr destructor.</li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_24" id="pnum_24">6</a></span> For a constexpr function or constexpr constructor that is neither defaulted nor a template, if no argument values exist such that an invocation of the function or constructor could be an evaluated subexpression of a core constant expression, or, for a constructor, an evaluated subexpression of the initialization full-expression of some constant-initialized object ([basic.start.static]), the program is ill-formed, no diagnostic required.</p>
<p>[<em>Example 4</em>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode default default"><code class="sourceCode default"><span id="cb11-1"><a href="#cb11-1"></a>constexpr int f(bool b)</span>
<span id="cb11-2"><a href="#cb11-2"></a>  { return b ? throw 0 : 0; }           // OK</span>
<span id="cb11-3"><a href="#cb11-3"></a>constexpr int f() { return f(true); }   // ill-formed, no diagnostic required</span>
<span id="cb11-4"><a href="#cb11-4"></a></span>
<span id="cb11-5"><a href="#cb11-5"></a>struct B {</span>
<span id="cb11-6"><a href="#cb11-6"></a>  constexpr B(int x) : i(0) { }         // x is unused</span>
<span id="cb11-7"><a href="#cb11-7"></a>  int i;</span>
<span id="cb11-8"><a href="#cb11-8"></a>};</span>
<span id="cb11-9"><a href="#cb11-9"></a></span>
<span id="cb11-10"><a href="#cb11-10"></a>int global;</span>
<span id="cb11-11"><a href="#cb11-11"></a></span>
<span id="cb11-12"><a href="#cb11-12"></a>struct D : B {</span>
<span id="cb11-13"><a href="#cb11-13"></a>  constexpr D() : B(global) { }         // ill-formed, no diagnostic required</span>
<span id="cb11-14"><a href="#cb11-14"></a>                                        // lvalue-to-rvalue conversion on non-constant global</span>
<span id="cb11-15"><a href="#cb11-15"></a>};</span></code></pre></div>
<ul>
<li><em>end example</em>]</li>
</ul>

</div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_25" id="pnum_25">7</a></span> If the instantiated template specialization of a constexpr function template or member function of a class template would fail to satisfy the requirements for a constexpr function, that specialization is still a constexpr function, even though a call to such a function cannot appear in a constant expression. <span class="rm" style="color: #bf0303"><del>If no specialization of the template would satisfy the requirements for a constexpr function when considered as a non-template function, the template is ill-formed, no diagnostic required.</del></span></p>
</blockquote>
<p>Adjust <span>9.5.2 <a href="https://wg21.link/dcl.fct.def.default">[dcl.fct.def.default]</a></span>/3 and fix the example (which is already wrong at the moment, since default-initializing an <code class="sourceCode cpp"><span class="dt">int</span></code> during constant evaluation is ok):</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_26" id="pnum_26">3</a></span> <span class="rm" style="color: #bf0303"><del>An explicitly-defaulted function that is not defined as deleted may be declared <span><code class="sourceCode default">constexpr</code></span> or <span><code class="sourceCode default">consteval</code></span> only if it is constexpr-compatible ([special], [class.compare.default])</del></span>. A function explicitly defaulted on its first declaration is implicitly inline ([dcl.inline]), and is implicitly constexpr ([dcl.constexpr]) if it <span class="rm" style="color: #bf0303"><del>is constexpr-compatible</del></span> <span class="addu">satisfies the requirements for a constexpr function</span>.</p>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_27" id="pnum_27">4</a></span> [<em>Example 1</em>:</p>
<div>
<div class="sourceCode" id="cb12"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb12-1"><a href="#cb12-1"></a>  struct S {</span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="st">-   constexpr S() = default;              // error: implicit S() is not constexpr</span></span>
<span id="cb12-3"><a href="#cb12-3"></a>    S(int a = 0) = default;               // error: default argument</span>
<span id="cb12-4"><a href="#cb12-4"></a>    void operator=(const S&amp;) = default;   // error: non-matching return type</span>
<span id="cb12-5"><a href="#cb12-5"></a>    ~S() noexcept(false) = default;       // OK, despite mismatched exception specification</span>
<span id="cb12-6"><a href="#cb12-6"></a>  private:</span>
<span id="cb12-7"><a href="#cb12-7"></a>    int i;</span>
<span id="cb12-8"><a href="#cb12-8"></a>    S(S&amp;);                                // OK: private copy constructor</span>
<span id="cb12-9"><a href="#cb12-9"></a>  };</span>
<span id="cb12-10"><a href="#cb12-10"></a>  S::S(S&amp;) = default;                     // OK: defines copy constructor</span>
<span id="cb12-11"><a href="#cb12-11"></a></span>
<span id="cb12-12"><a href="#cb12-12"></a>  struct T {</span>
<span id="cb12-13"><a href="#cb12-13"></a>    T();</span>
<span id="cb12-14"><a href="#cb12-14"></a>    T(T &amp;&amp;) noexcept(false);</span>
<span id="cb12-15"><a href="#cb12-15"></a>  };</span>
<span id="cb12-16"><a href="#cb12-16"></a>  struct U {</span>
<span id="cb12-17"><a href="#cb12-17"></a>    T t;</span>
<span id="cb12-18"><a href="#cb12-18"></a>    U();</span>
<span id="cb12-19"><a href="#cb12-19"></a>    U(U &amp;&amp;) noexcept = default;</span>
<span id="cb12-20"><a href="#cb12-20"></a>  };</span>
<span id="cb12-21"><a href="#cb12-21"></a>  U u1;</span>
<span id="cb12-22"><a href="#cb12-22"></a>  U u2 = static_cast&lt;U&amp;&amp;&gt;(u1);            // OK, calls stdโ::โterminate if Tโ::โT(T&amp;&amp;) throws</span></code></pre></div>
</div>
<p>โ <em>end example</em>]</p>
</blockquote>
<p>Strike use of constexpr-compatible in <span>11.4.4 <a href="https://wg21.link/special">[special]</a></span>/8:</p>
<blockquote>
<div class="rm" style="color: #bf0303">
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_28" id="pnum_28">8</a></span> A defaulted special member function is <em>constexpr-compatible</em> if the corresponding implicitly-declared special member function would be a constexpr function.</p>
</div>
</blockquote>
<p>Mark assignment as being constexpr in <span>11.4.6 <a href="https://wg21.link/class.copy.assign">[class.copy.assign]</a></span>/10:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_29" id="pnum_29">10</a></span> A copy/move assignment operator for a class <code class="sourceCode cpp">X</code> that is defaulted and not defined as deleted is <em>implicitly defined</em> when it is odr-used ([term.odr.use]) (e.g., when it is selected by overload resolution to assign to an object of its class type), when it is needed for constant evaluation ([expr.const]), or when it is explicitly defaulted after its first declaration. The implicitly-defined copy/move assignment operator is <code class="sourceCode cpp"><span class="kw">constexpr</span></code><span class="addu">.</span> <span class="rm" style="color: #bf0303"><del>if</del></span></p>
<div class="rm" style="color: #bf0303">

<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_30" id="pnum_30">(10.1)</a></span> X is a literal type, and</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_31" id="pnum_31">(10.2)</a></span> the assignment operator selected to copy/move each direct base class subobject is a constexpr function, and</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_32" id="pnum_32">(10.3)</a></span> for each non-static data member of X that is of class type (or array thereof), the assignment operator selected to copy/move that member is a constexpr function.</li>
</ul>

</div>
</blockquote>
<p>Remove this no-longer-necessary rule in <span>11.4.7 <a href="https://wg21.link/class.dtor">[class.dtor]</a></span>/9 (the requirements for constexpr destructor are now just the requirements for constexpr function, which is now covered by the [dcl.fct.def.default] rule):</p>
<blockquote>
<div class="rm" style="color: #bf0303">
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_33" id="pnum_33">9</a></span> A defaulted destructor is a constexpr destructor if it satisfies the requirements for a constexpr destructor ([dcl.constexpr]).</p>
</div>
</blockquote>
<p>Strike use of constexpr-compatible in <span>11.10.1 <a href="https://wg21.link/class.compare.default">[class.compare.default]</a></span>/4:</p>
<blockquote>
<div class="rm" style="color: #bf0303">
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_34" id="pnum_34">4</a></span> A defaulted comparison function is <em>constexpr-compatible</em> if it satisfies the requirements for a constexpr function ([dcl.constexpr]) and no overload resolution performed when determining whether to delete the function results in a usable candidate that is a non-constexpr function.</p>
<p>[<em>Note 1</em>: This includes the overload resolutions performed:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_35" id="pnum_35">(4.1)</a></span> for an <code class="sourceCode default">operator&lt;=&gt;</code> whose return type is not <code class="sourceCode default">auto</code>, when determining whether a synthesized three-way comparison is defined,</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_36" id="pnum_36">(4.2)</a></span> for an <code class="sourceCode default">operator&lt;=&gt;</code> whose return type is <code class="sourceCode default">auto</code> or for an <code class="sourceCode default">operator==</code>, for a comparison between an element of the expanded list of subobjects and itself, or</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_37" id="pnum_37">(4.3)</a></span> for a secondary comparison operator <code class="sourceCode default">@</code>, for the expression <code class="sourceCode default">x @ y</code>.</li>
</ul>
<p>โ <em>end note</em>]</p>
</div>
</blockquote>
<h1 data-number="8" style="border-bottom:1px solid #cccccc" id="bibliography"><span class="header-section-number">8</span> References<a href="#bibliography" class="self-link"></a></h1>
<div id="refs" class="references hanging-indent" role="doc-bibliography">
<div id="ref-P2231R1">
<p>[P2231R1] Barry Revzin. 2021-02-12. Add further constexpr support for optional/variant. <br />
<a href="https://wg21.link/p2231r1">https://wg21.link/p2231r1</a></p>
</div>
<div id="ref-P2350R1">
<p>[P2350R1] Andreas Fertig. 2021-07-15. constexpr class. <br />
<a href="https://wg21.link/p2350r1">https://wg21.link/p2350r1</a></p>
</div>
<div id="ref-P2448R0">
<p>[P2448R0] Barry Revzin. 2021-10-14. Relaxing some constexpr restrictions. <br />
<a href="https://wg21.link/p2448r0">https://wg21.link/p2448r0</a></p>
</div>
</div>
</div>
</div>
</body>
</html>
