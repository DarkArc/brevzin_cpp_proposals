<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="mpark/wg21" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2022-07-27" />
  <title>Various Designs for Pipelines</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
      div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
      ul.task-list{list-style: none;}
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode
        {  background-color: #f6f8fa; }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span. { } /* Normal */
      code span.al { color: #ff0000; } /* Alert */
      code span.an { } /* Annotation */
      code span.at { } /* Attribute */
      code span.bn { color: #9f6807; } /* BaseN */
      code span.bu { color: #9f6807; } /* BuiltIn */
      code span.cf { color: #00607c; } /* ControlFlow */
      code span.ch { color: #9f6807; } /* Char */
      code span.cn { } /* Constant */
      code span.co { color: #008000; font-style: italic; } /* Comment */
      code span.cv { color: #008000; font-style: italic; } /* CommentVar */
      code span.do { color: #008000; } /* Documentation */
      code span.dt { color: #00607c; } /* DataType */
      code span.dv { color: #9f6807; } /* DecVal */
      code span.er { color: #ff0000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #9f6807; } /* Float */
      code span.fu { } /* Function */
      code span.im { } /* Import */
      code span.in { color: #008000; } /* Information */
      code span.kw { color: #00607c; } /* Keyword */
      code span.op { color: #af1915; } /* Operator */
      code span.ot { } /* Other */
      code span.pp { color: #6f4e37; } /* Preprocessor */
      code span.re { } /* RegionMarker */
      code span.sc { color: #9f6807; } /* SpecialChar */
      code span.ss { color: #9f6807; } /* SpecialString */
      code span.st { color: #9f6807; } /* String */
      code span.va { } /* Variable */
      code span.vs { color: #9f6807; } /* VerbatimString */
      code span.wa { color: #008000; font-weight: bold; } /* Warning */
      code.diff {color: #898887}
      code.diff span.va {color: #006e28}
      code.diff span.st {color: #bf0303}
  </style>
  <style type="text/css">
body {
margin: 5em;
font-family: serif;

hyphens: auto;
line-height: 1.35;
}
div.wrapper {
max-width: 60em;
margin: auto;
}
ul {
list-style-type: none;
padding-left: 2em;
margin-top: -0.2em;
margin-bottom: -0.2em;
}
a {
text-decoration: none;
color: #4183C4;
}
a.hidden_link {
text-decoration: none;
color: inherit;
}
li {
margin-top: 0.6em;
margin-bottom: 0.6em;
}
h1, h2, h3, h4 {
position: relative;
line-height: 1;
}
a.self-link {
position: absolute;
top: 0;
left: calc(-1 * (3.5rem - 26px));
width: calc(3.5rem - 26px);
height: 2em;
text-align: center;
border: none;
transition: opacity .2s;
opacity: .5;
font-family: sans-serif;
font-weight: normal;
font-size: 83%;
}
a.self-link:hover { opacity: 1; }
a.self-link::before { content: "§"; }
ul > li:before {
content: "\2014";
position: absolute;
margin-left: -1.5em;
}
:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }
.abbr_ref { float: right; }
.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }
:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }
.secnum { display: inline-block; min-width: 35pt; }
.header-section-number { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }
div.sourceLinkParent {
float: right;
}
a.sourceLink {
position: absolute;
opacity: 0;
margin-left: 10pt;
}
a.sourceLink:hover {
opacity: 1;
}
a.itemDeclLink {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
opacity: 0;
}
a.itemDeclLink:hover { opacity: 1; }
span.marginalizedparent {
position: relative;
left: -5em;
}
li span.marginalizedparent { left: -7em; }
li ul > li span.marginalizedparent { left: -9em; }
li ul > li ul > li span.marginalizedparent { left: -11em; }
li ul > li ul > li ul > li span.marginalizedparent { left: -13em; }
div.footnoteNumberParent {
position: relative;
left: -4.7em;
}
a.marginalized {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
}
a.enumerated_item_num {
position: relative;
left: -3.5em;
display: inline-block;
margin-right: -3em;
text-align: right;
width: 3em;
}
div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }
span.indexparent {
display: inline;
position: relative;
float: right;
right: -1em;
}
a.index {
position: absolute;
display: none;
}
a.index:before { content: "⟵"; }

a.index:target {
display: inline;
}
.indexitems {
margin-left: 2em;
text-indent: -2em;
}
div.itemdescr {
margin-left: 3em;
}
.bnf {
font-family: serif;
margin-left: 40pt;
margin-top: 0.5em;
margin-bottom: 0.5em;
}
.ncbnf {
font-family: serif;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
}
.ncsimplebnf {
font-family: serif;
font-style: italic;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
background: inherit; 
}
span.textnormal {
font-style: normal;
font-family: serif;
white-space: normal;
display: inline-block;
}
span.rlap {
display: inline-block;
width: 0px;
}
span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }
span.phantom { color: white; }

span.math { font-style: normal; }
span.mathblock {
display: block;
margin-left: auto;
margin-right: auto;
margin-top: 1.2em;
margin-bottom: 1.2em;
text-align: center;
}
span.mathalpha {
font-style: italic;
}
span.synopsis {
font-weight: bold;
margin-top: 0.5em;
display: block;
}
span.definition {
font-weight: bold;
display: block;
}
.codeblock {
margin-left: 1.2em;
line-height: 127%;
}
.outputblock {
margin-left: 1.2em;
line-height: 127%;
}
div.itemdecl {
margin-top: 2ex;
}
code.itemdeclcode {
white-space: pre;
display: block;
}
span.textsuperscript {
vertical-align: super;
font-size: smaller;
line-height: 0;
}
.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }
.footnote {
font-size: small;
margin-left: 2em;
margin-right: 2em;
margin-top: 0.6em;
margin-bottom: 0.6em;
}
div.minipage {
display: inline-block;
margin-right: 3em;
}
div.numberedTable {
text-align: center;
margin: 2em;
}
div.figure {
text-align: center;
margin: 2em;
}
table {
border: 1px solid black;
border-collapse: collapse;
margin-left: auto;
margin-right: auto;
margin-top: 0.8em;
text-align: left;
hyphens: none; 
}
td, th {
padding-left: 1em;
padding-right: 1em;
vertical-align: top;
}
td.empty {
padding: 0px;
padding-left: 1px;
}
td.left {
text-align: left;
}
td.right {
text-align: right;
}
td.center {
text-align: center;
}
td.justify {
text-align: justify;
}
td.border {
border-left: 1px solid black;
}
tr.rowsep, td.cline {
border-top: 1px solid black;
}
tr.even, tr.odd {
border-bottom: 1px solid black;
}
tr.capsep {
border-top: 3px solid black;
border-top-style: double;
}
tr.header {
border-bottom: 3px solid black;
border-bottom-style: double;
}
th {
border-bottom: 1px solid black;
}
span.centry {
font-weight: bold;
}
div.table {
display: block;
margin-left: auto;
margin-right: auto;
text-align: center;
width: 90%;
}
span.indented {
display: block;
margin-left: 2em;
margin-bottom: 1em;
margin-top: 1em;
}
ol.enumeratea { list-style-type: none; background: inherit; }
ol.enumerate { list-style-type: none; background: inherit; }

code.sourceCode > span { display: inline; }
</style>
  <style type="text/css">a {
color : #4183C4;
text-decoration: underline;
}
a.marginalized {
text-decoration: none;
}
a.self-link {
text-decoration: none;
}
h1#toctitle {
border-bottom: 1px solid #cccccc;
}
#TOC li {
margin-top: 1px;
margin-bottom: 1px;
}
#TOC ul>li:before { display: none; }
h3.subtitle { margin-top: -15px; }
h1:target { background-color: transparent; }
h2:target { background-color: transparent; }
h3:target { background-color: transparent; }
h4:target { background-color: transparent; }
h5:target { background-color: transparent; }
h6:target { background-color: transparent; }
code span.co { font-family: monospace; }
table tr {
background-color: white;
}
table tr:nth-child(2n) {
background-color: #f6f8fa;
}
#title-block-header > table tr:nth-child(2n) {
background-color: white;
}
td > div.sourceCode {
background-color: inherit;
}
table {
border-collapse: collapse;
}
table td, table th {
border: 1px solid #cccccc;
}
table th {
border-bottom: 1px solid black;
text-align: center;
}
table tr:first-child th {
border-top: 0;
}
table tr:last-child td {
border-bottom: 0;
}
table tr td:first-child,
table tr th:first-child {
border-left: 0;
}
table tr td:last-child,
table tr th:last-child {
border-right: 0;
}
table tbody tr:first-child td {
border-top: 1px solid black;
}
#title-block-header td { border: 0; }
@media all {
body {
margin: 2em;
}
}
@media screen and (min-width: 480px) {
body {
margin: 5em;
}
}
#refs code{padding-left: 0px; text-indent: 0px;}
:root {
--diff-ins: #e6ffed;
--diff-strongins: #acf2bd;
--diff-del: #ffdddd;
--diff-strongdel: #ff8888;
}
span.diffins {
background-color: var(--diff-strongins);
}
span.diffdel {
background-color: var(--diff-strongdel);
}
div.rm { text-decoration: line-through; }
div.rm code.sourceCode { text-decoration: line-through; }
div.addu, span.addu {
color: #006e28;
background-color: var(--diff-ins);
}

div.rm pre, div.add pre { background-color: #f6f8fa; }
div.addu pre { background-color: var(--diff-ins); }
div.add, div.add pre { background-color: var(--diff-ins); }
div.addu blockquote {
border-left: 4px solid #00a000;
padding: 0 15px;
color: #006e28;
text-decoration: none;
}
div.addu blockquote code.sourceCode { text-decoration: none; }
div.addu blockquote pre { text-decoration: none; }
div.addu blockquote pre code { text-decoration: none; }
div.quote {
border-left: 7px solid #ccc;
background: #f9f9f9;
margin: 1.5em 10px;
padding-left: 20px;
}
code.diff span.va { color: #000000; background-color: var(--diff-ins); }
code.diff span.st { color: #000000; background-color: var(--diff-del); }
</style>
  <link href="data:image/x-icon;base64,AAABAAIAEBAAAAEAIABoBAAAJgAAACAgAAABACAAqBAAAI4EAAAoAAAAEAAAACAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAVoJEAN6CRADegkQAWIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wCCRAAAgkQAAIJEAACCRAAsgkQAvoJEAP+CRAD/gkQA/4JEAP+CRADAgkQALoJEAACCRAAAgkQAAP///wD///8AgkQAAIJEABSCRACSgkQA/IJEAP99PQD/dzMA/3czAP99PQD/gkQA/4JEAPyCRACUgkQAFIJEAAD///8A////AHw+AFiBQwDqgkQA/4BBAP9/PxP/uZd6/9rJtf/bybX/upd7/39AFP+AQQD/gkQA/4FDAOqAQgBc////AP///wDKklv4jlEa/3o7AP+PWC//8+3o///////////////////////z7un/kFox/35AAP+GRwD/mVYA+v///wD///8A0Zpk+NmibP+0d0T/8evj///////+/fv/1sKz/9bCs//9/fr//////+/m2/+NRwL/nloA/5xYAPj///8A////ANKaZPjRmGH/5cKh////////////k149/3UwAP91MQD/lmQ//86rhv+USg3/m1YA/5hSAP+bVgD4////AP///wDSmmT4zpJY/+/bx///////8+TV/8mLT/+TVx//gkIA/5lVAP+VTAD/x6B//7aEVv/JpH7/s39J+P///wD///8A0ppk+M6SWP/u2sf///////Pj1f/Nj1T/2KFs/8mOUv+eWhD/lEsA/8aee/+0glT/x6F7/7J8Rvj///8A////ANKaZPjRmGH/48Cf///////+/v7/2qt//82PVP/OkFX/37KJ/86siv+USg7/mVQA/5hRAP+bVgD4////AP///wDSmmT40ppk/9CVXP/69O////////7+/v/x4M//8d/P//7+/f//////9u7n/6tnJf+XUgD/nFgA+P///wD///8A0ppk+NKaZP/RmWL/1qNy//r07///////////////////////+vXw/9akdP/Wnmn/y5FY/6JfFvj///8A////ANKaZFTSmmTo0ppk/9GYYv/Ql1//5cWm//Hg0P/x4ND/5cWm/9GXYP/RmGH/0ppk/9KaZOjVnmpY////AP///wDSmmQA0ppkEtKaZI7SmmT60ppk/9CWX//OkVb/zpFW/9CWX//SmmT/0ppk/NKaZJDSmmQS0ppkAP///wD///8A0ppkANKaZADSmmQA0ppkKtKaZLrSmmT/0ppk/9KaZP/SmmT/0ppkvNKaZCrSmmQA0ppkANKaZAD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkUtKaZNzSmmTc0ppkVNKaZADSmmQA0ppkANKaZADSmmQA////AP5/AAD4HwAA4AcAAMADAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAMADAADgBwAA+B8AAP5/AAAoAAAAIAAAAEAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAyCRACMgkQA6oJEAOqCRACQgkQAEIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRABigkQA5oJEAP+CRAD/gkQA/4JEAP+CRADqgkQAZoJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAA4gkQAwoJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQAxIJEADyCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAP///wD///8A////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAWgkQAmIJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAJyCRAAYgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAdIJEAPCCRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAPSCRAB4gkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQASoJEANKCRAD/gkQA/4JEAP+CRAD/g0YA/39AAP9zLgD/bSQA/2shAP9rIQD/bSQA/3MuAP9/PwD/g0YA/4JEAP+CRAD/gkQA/4JEAP+CRADUgkQAToJEAACCRAAAgkQAAP///wD///8A////AP///wB+PwAAgkUAIoJEAKiCRAD/gkQA/4JEAP+CRAD/hEcA/4BBAP9sIwD/dTAA/5RfKv+viF7/vp56/76ee/+wiF7/lWAr/3YxAP9sIwD/f0AA/4RHAP+CRAD/gkQA/4JEAP+CRAD/gkQArIJEACaBQwAA////AP///wD///8A////AIBCAEBzNAD6f0EA/4NFAP+CRAD/gkQA/4VIAP92MwD/bSUA/6N1Tv/ezsL/////////////////////////////////38/D/6V3Uv9uJgD/dTEA/4VJAP+CRAD/gkQA/4JEAP+BQwD/fUAA/4FDAEj///8A////AP///wD///8AzJRd5qBlKf91NgD/dDUA/4JEAP+FSQD/cy4A/3YyAP/PuKP//////////////////////////////////////////////////////9K7qP94NQD/ciwA/4VJAP+CRAD/fkEA/35BAP+LSwD/mlYA6v///wD///8A////AP///wDdpnL/4qx3/8KJUv+PUhf/cTMA/3AsAP90LgD/4dK+/////////////////////////////////////////////////////////////////+TYxf91MAD/dTIA/31CAP+GRwD/llQA/6FcAP+gWwD8////AP///wD///8A////ANGZY/LSm2X/4ap3/92mcP+wdT3/byQA/8mwj////////////////////////////////////////////////////////////////////////////+LYxv9zLgP/jUoA/59bAP+hXAD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/RmWL/1p9q/9ubXv/XqXj////////////////////////////7+fD/vZyG/6BxS/+gcUr/vJuE//r37f//////////////////////3MOr/5dQBf+dVQD/nVkA/5xYAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmWP/yohJ//jo2P//////////////////////4NTG/4JDFf9lGAD/bSQA/20kAP9kGAD/fz8S/+Xb0f//////5NG9/6txN/+LOgD/m1QA/51aAP+cWAD/m1cA/5xYAP+cWADy////AP///wD///8A////ANKaZPLSmmT/0ppk/8+TWf/Unmv//v37//////////////////////+TWRr/VwsA/35AAP+ERgD/g0UA/4JGAP9lHgD/kFga/8KXX/+TRwD/jT4A/49CAP+VTQD/n10A/5xYAP+OQQD/lk4A/55cAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/y4tO/92yiP//////////////////////8NnE/8eCQP+rcTT/ez0A/3IyAP98PgD/gEMA/5FSAP+USwD/jj8A/5lUAP+JNwD/yqV2/694Mf+HNQD/jkAA/82rf/+laBj/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/LiUr/4byY///////////////////////gupX/0I5P/+Wuev/Lklz/l1sj/308AP+QSwD/ol0A/59aAP+aVQD/k0oA/8yoh///////+fXv/6pwO//Lp3v///////Pr4f+oay7y////AP///wD///8A////ANKaZPLSmmT/0ppk/8uJSv/hvJj//////////////////////+G7l//Jhkb/0ppk/96nc//fqXX/x4xO/6dkFP+QSQD/llEA/5xXAP+USgD/yaOA///////38uv/qG05/8ijdv//////8efb/6ZpLPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/zIxO/9yxh///////////////////////7dbA/8iEQf/Sm2X/0Zlj/9ScZv/eqHf/2KJv/7yAQf+XTgD/iToA/5lSAP+JNgD/yKFv/611LP+HNQD/jT8A/8qmeP+kZRT/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/Pk1n/1J5q//78+//////////////////+/fv/1aFv/8iEQv/Tm2b/0ppl/9GZY//Wn2z/1pZc/9eldf/Bl2b/kUcA/4w9AP+OQAD/lUwA/59eAP+cWQD/jT8A/5ZOAP+eXADy////AP///wD///8A////ANKaZPLSmmT/0ppk/9KZY//KiEn/8d/P///////////////////////47+f/05tm/8iCP//KiEj/yohJ/8eCP//RmGH//vfy///////n1sP/rXQ7/4k4AP+TTAD/nVoA/5xYAP+cVwD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/0ptl/8uLTf/aq37////////////////////////////+/fz/6c2y/961jv/etY7/6Myx//78+v//////////////////////3MWv/5xXD/+ORAD/mFQA/51ZAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmmT/0ppk/8mFRP/s1b//////////////////////////////////////////////////////////////////////////////+PD/0JFU/7NzMv+WUQD/kUsA/5tXAP+dWQDy////AP///wD///8A////ANKaZP/SmmT/0ppk/9KaZP/Sm2X/z5NZ/8yMT//z5NX/////////////////////////////////////////////////////////////////9Ofa/8yNUP/UmGH/36p5/8yTWv+qaSD/kksA/5ROAPz///8A////AP///wD///8A0ppk5NKaZP/SmmT/0ppk/9KaZP/TnGf/zY9T/82OUv/t1sD//////////////////////////////////////////////////////+7Yw//OkFX/zI5R/9OcZ//SmmP/26V0/9ymdf/BhUf/ol8R6P///wD///8A////AP///wDSmmQ80ppk9tKaZP/SmmT/0ppk/9KaZP/TnGj/zpFW/8qJSv/dson/8uHS//////////////////////////////////Lj0//etIv/y4lL/86QVf/TnGj/0ppk/9KaZP/RmWP/05xn/9ymdfjUnWdC////AP///wD///8A////ANKaZADSmmQc0ppkotKaZP/SmmT/0ppk/9KaZP/Tm2b/0Zli/8qJSf/NjlH/16Z3/+G8mP/myKr/5siq/+G8mP/Xp3f/zY5S/8qISf/RmGH/05tm/9KaZP/SmmT/0ppk/9KaZP/SmmSm0pljINWdaQD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkQtKaZMrSmmT/0ppk/9KaZP/SmmT/0ptl/9GYYf/Nj1P/y4lL/8qISP/KiEj/y4lK/82PU//RmGH/0ptl/9KaZP/SmmT/0ppk/9KaZP/SmmTO0ppkRtKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZGzSmmTu0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmTw0ppkcNKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZBLSmmSQ0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppklNKaZBTSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQy0ppkutKaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppkvtKaZDbSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkXNKaZODSmmT/0ppk/9KaZP/SmmT/0ppk5NKaZGDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkBtKaZIbSmmTo0ppk6tKaZIrSmmQK0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP/8P///+B///+AH//+AAf//AAD//AAAP/AAAA/gAAAHwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA+AAAAfwAAAP/AAAP/8AAP//gAH//+AH///4H////D//" rel="icon" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
</head>
<body>
<div class="wrapper">
<header id="title-block-header">
<h1 class="title" style="text-align:center">Various Designs for Pipelines</h1>

<table style="border:none;float:right">
  <tr>
    <td>Document #:</td>
    <td>DxxxxR0</td>
  </tr>
  <tr>
    <td>Date:</td>
    <td>2022-07-27</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Project:</td>
    <td>Programming Language C++</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Audience:</td>
    <td>
      EWG<br>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top">Reply-to:</td>
    <td>
      Barry Revzin<br>&lt;<a href="mailto:barry.revzin@gmail.com" class="email">barry.revzin@gmail.com</a>&gt;<br>
    </td>
  </tr>
</table>

</header>
<div style="clear:both">
<div id="TOC" role="doc-toc">
<h1 id="toctitle">Contents</h1>
<ul>
<li><a href="#various-designs-for-pipelines"><span class="toc-section-number">1</span> Various Designs for Pipelines<span></span></a>
<ul>
<li><a href="#left-threading"><span class="toc-section-number">1.1</span> Left-Threading<span></span></a></li>
<li><a href="#inverted-invocation"><span class="toc-section-number">1.2</span> Inverted Invocation<span></span></a></li>
<li><a href="#placeholder"><span class="toc-section-number">1.3</span> Placeholder<span></span></a></li>
<li><a href="#language-bind"><span class="toc-section-number">1.4</span> Language Bind<span></span></a></li>
</ul></li>
<li><a href="#comparing-the-designs"><span class="toc-section-number">2</span> Comparing the Designs<span></span></a>
<ul>
<li><a href="#rejecting-the-inverted-application-model"><span class="toc-section-number">2.1</span> Rejecting the Inverted Application Model<span></span></a></li>
<li><a href="#to-placehold-or-not-to-placehold"><span class="toc-section-number">2.2</span> To Placehold or Not To Placehold<span></span></a></li>
<li><a href="#placeholder-or-language-bind"><span class="toc-section-number">2.3</span> Placeholder or Language Bind<span></span></a></li>
</ul></li>
<li><a href="#placeholder-lambdas"><span class="toc-section-number">3</span> Placeholder Lambdas<span></span></a></li>
<li><a href="#bibliography"><span class="toc-section-number">4</span> References<span></span></a></li>
</ul>
</div>
<h1 data-number="1" style="border-bottom:1px solid #cccccc" id="various-designs-for-pipelines"><span class="header-section-number">1</span> Various Designs for Pipelines<a href="#various-designs-for-pipelines" class="self-link"></a></h1>
<p><span class="citation" data-cites="P2011R0">[<a href="#ref-P2011R0" role="doc-biblioref">P2011R0</a>]</span> proposed a new, non-overloadable binary operator <code class="sourceCode cpp"><span class="op">|&gt;</span></code> such that the expression</p>
<blockquote>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a>x <span class="op">|&gt;</span> f<span class="op">(</span>y<span class="op">)</span></span></code></pre></div>
</blockquote>
<p>was defined to be evaluated as:</p>
<blockquote>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a>f<span class="op">(</span>x, y<span class="op">)</span></span></code></pre></div>
</blockquote>
<p>without any intermediate <code class="sourceCode cpp">f<span class="op">(</span>y<span class="op">)</span></code> expression. The rules of this operator were fairly simple: the right-hand side had to be a call expression, and the left-hand expression was inserted as the first argument into the right-hand call.</p>
<p>But there are other potential designs for such an operator. The goal of this paper is to go over all of the possibilities and attempt to weigh their pros and cons. It would also be useful background to read the JavaScript proposal for this operator <span class="citation" data-cites="javascript.pipeline">[<a href="#ref-javascript.pipeline" role="doc-biblioref">javascript.pipeline</a>]</span>, which both provides a lot of rationale for the feature and goes through a similar exercise.</p>
<p>In short, there are four potential designs. I’ll first present all four and then discuss the pros and cons of each: <a href="#left-threading">Left-Threading</a>, <a href="#inverted-invocation">Inverted Invocation</a>, <a href="#placeholder">Placeholder</a>, and <a href="#placeholder-lambda">Language Bind</a>.</p>
<h2 data-number="1.1" id="left-threading"><span class="header-section-number">1.1</span> Left-Threading<a href="#left-threading" class="self-link"></a></h2>
<p>The left-threading model was what was proposed in <span class="citation" data-cites="P2011R0">[<a href="#ref-P2011R0" role="doc-biblioref">P2011R0</a>]</span> (and is used by Elixir). In <code class="sourceCode cpp">x <span class="op">|&gt;</span> e</code>, <code class="sourceCode cpp">e</code> has to be a call expression of the form <code class="sourceCode cpp">f<span class="op">(</span>args<span class="op">...)</span></code> and the evaluation of this operator is a rewrite which places the operand on the left-hand of the pipeline as the first call argument on the right-hand side. This is similar to how member function invocation works (especially in a deducing <code class="sourceCode cpp"><span class="kw">this</span></code> world).</p>
<p>For example:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Code</strong>
</div></th>
<th><div style="text-align:center">
<strong>Evaluation</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="sourceCode cpp">x <span class="op">|&gt;</span> f<span class="op">(</span>y<span class="op">)</span></code></td>
<td><code class="sourceCode cpp">f<span class="op">(</span>x, y<span class="op">)</span></code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">x <span class="op">|&gt;</span> f<span class="op">()</span></code></td>
<td><code class="sourceCode cpp">f<span class="op">(</span>x<span class="op">)</span></code></td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp">x <span class="op">|&gt;</span> f</code></td>
<td>ill-formed, because <code class="sourceCode cpp">f</code> is not a call expression</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">x <span class="op">|&gt;</span> f <span class="op">+</span> g</code></td>
<td>ill-formed, because <code class="sourceCode cpp">f <span class="op">+</span> g</code> is not a call expression</td>
</tr>
</tbody>
</table>
<h2 data-number="1.2" id="inverted-invocation"><span class="header-section-number">1.2</span> Inverted Invocation<a href="#inverted-invocation" class="self-link"></a></h2>
<p>In the inverted invocation model (which is used by F#, Julia, Elm, and OCaml), <code class="sourceCode cpp"><span class="op">|&gt;</span></code> is an inverted call invocation. <code class="sourceCode cpp">x <span class="op">|&gt;</span> f</code> is defined as <code class="sourceCode cpp">f<span class="op">(</span>x<span class="op">)</span></code>. The right-hand side can be arbitrarily involved, and <code class="sourceCode cpp"><span class="op">|&gt;</span></code> would be sufficiently low precedence to allow this flexibility:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Code</strong>
</div></th>
<th><div style="text-align:center">
<strong>Evaluation</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="sourceCode cpp">x <span class="op">|&gt;</span> f<span class="op">(</span>y<span class="op">)</span></code></td>
<td><code class="sourceCode cpp">f<span class="op">(</span>y<span class="op">)(</span>x<span class="op">)</span></code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">x <span class="op">|&gt;</span> f<span class="op">()</span></code></td>
<td><code class="sourceCode cpp">f<span class="op">()(</span>x<span class="op">)</span></code></td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp">x <span class="op">|&gt;</span> f</code></td>
<td><code class="sourceCode cpp">f<span class="op">(</span>x<span class="op">)</span></code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">x <span class="op">|&gt;</span> f <span class="op">+</span> g</code></td>
<td><code class="sourceCode cpp"><span class="op">(</span>f <span class="op">+</span> g<span class="op">)(</span>x<span class="op">)</span></code></td>
</tr>
</tbody>
</table>
<h2 data-number="1.3" id="placeholder"><span class="header-section-number">1.3</span> Placeholder<a href="#placeholder" class="self-link"></a></h2>
<p>In the placeholder model (which is used by Hack), the right-hand side of <code class="sourceCode cpp"><span class="op">|&gt;</span></code> is an arbitrary expression that must contain at least one placeholder. In Hack, that placeholder is <code>$$</code>. But for the purposes of this paper, I’m going to use <code class="sourceCode cpp"><span class="op">%</span></code>. The pipeline operator evaluates as if replacing all instances of the placeholder with the left-hand argument:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Code</strong>
</div></th>
<th><div style="text-align:center">
<strong>Evaluation</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="sourceCode cpp">x <span class="op">|&gt;</span> f</code></td>
<td>ill-formed, no placeholder</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">x <span class="op">|&gt;</span> f<span class="op">(</span>y<span class="op">)</span></code></td>
<td>ill-formed, no placeholder</td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp">x <span class="op">|&gt;</span> f<span class="op">(%</span>, y<span class="op">)</span></code></td>
<td><code class="sourceCode cpp">f<span class="op">(</span>x, y<span class="op">)</span></code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">x <span class="op">|&gt;</span> f<span class="op">(</span>y, <span class="op">%)</span></code></td>
<td><code class="sourceCode cpp">f<span class="op">(</span>y, x<span class="op">)</span></code></td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp">x <span class="op">|&gt;</span> y <span class="op">+</span> <span class="op">%</span></code></td>
<td><code class="sourceCode cpp">y <span class="op">+</span> x</code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">x <span class="op">|&gt;</span> f<span class="op">(</span>y<span class="op">)</span> <span class="op">+</span> g<span class="op">(%)</span></code></td>
<td><code class="sourceCode cpp">f<span class="op">(</span>y<span class="op">)</span> <span class="op">+</span> g<span class="op">(</span>x<span class="op">)</span></code></td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp">x <span class="op">|&gt;</span> <span class="kw">co_await</span> <span class="op">%</span></code></td>
<td><code class="sourceCode cpp"><span class="kw">co_await</span> x</code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">x <span class="op">|&gt;</span> f<span class="op">(</span><span class="dv">1</span>, <span class="op">%</span>, <span class="op">%)</span></code></td>
<td><code class="sourceCode cpp">f<span class="op">(</span><span class="dv">1</span>, x, x<span class="op">)</span></code></td>
</tr>
</tbody>
</table>
<h2 data-number="1.4" id="language-bind"><span class="header-section-number">1.4</span> Language Bind<a href="#language-bind" class="self-link"></a></h2>
<p>Consider again the expression <code class="sourceCode cpp">x <span class="op">|&gt;</span> f<span class="op">(</span>y, <span class="op">%)</span></code> above. What role does the <code class="sourceCode cpp">f<span class="op">(</span>y, <span class="op">%)</span></code> part serve? I don’t want to call it a sub-expression since it’s not technically a distinct operand here. But conceptually, it at least kind of is. And as such the role that it serves here is quite similar to:</p>
<blockquote>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a>std<span class="op">::</span>bind<span class="op">(</span>f, y, _1<span class="op">)(</span>x<span class="op">)</span></span></code></pre></div>
</blockquote>
<p>With two very notable differences:</p>
<ul>
<li>The <code class="sourceCode cpp">bind</code> expression is limited to solely functions, which the placeholder pipeline is not (as illustrated earlier). But more than that, the <code class="sourceCode cpp">bind</code> expression is limited to the kinds of functions we can pass as parameters, which <code class="sourceCode cpp">f</code> need not be (e.g. <code class="sourceCode cpp">std<span class="op">::</span>apply</code> or <code class="sourceCode cpp">std<span class="op">::</span>visit</code>, or any other function template)</li>
<li>The <code class="sourceCode cpp">bind</code> expression has to capture any additional arguments (the bound arguments) because, as a library facility, it is not knowable when those arguments will actually be used. How expensive is capturing <code class="sourceCode cpp">f</code> and <code class="sourceCode cpp">y</code>? But with the placeholder expression, we don’t need to capture anything, since we know we’re immediately evaluating the expression.</li>
</ul>
<p>That said, the not-quite-expression <code class="sourceCode cpp">f<span class="op">(</span>y, <span class="op">%)</span></code> is conceptually a lot like a unary function.</p>
<p>With that in mind, the language bind model is the inverted invocation model except also introducing the ability to use placeholders to introduce a language bind (sort of like partial application). That is:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Code</strong>
</div></th>
<th><div style="text-align:center">
<strong>Evaluation</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="sourceCode cpp">x <span class="op">|&gt;</span> f</code></td>
<td><code class="sourceCode cpp">f<span class="op">(</span>x<span class="op">)</span></code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">x <span class="op">|&gt;</span> f<span class="op">(</span>y<span class="op">)</span></code></td>
<td><code class="sourceCode cpp">f<span class="op">(</span>y<span class="op">)(</span>x<span class="op">)</span></code></td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp">x <span class="op">|&gt;</span> f<span class="op">(%</span>, y<span class="op">)</span></code></td>
<td><code class="sourceCode cpp">f<span class="op">(</span>x, y<span class="op">)</span></code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">x <span class="op">|&gt;</span> f<span class="op">(</span>y, <span class="op">%)</span></code></td>
<td><code class="sourceCode cpp">f<span class="op">(</span>y, x<span class="op">)</span></code></td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp">x <span class="op">|&gt;</span> y <span class="op">+</span> <span class="op">%</span></code></td>
<td><code class="sourceCode cpp">y <span class="op">+</span> x</code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">x <span class="op">|&gt;</span> f<span class="op">(</span>y<span class="op">)</span> <span class="op">+</span> g<span class="op">(%)</span></code></td>
<td><code class="sourceCode cpp">f<span class="op">(</span>y<span class="op">)</span> <span class="op">+</span> g<span class="op">(</span>x<span class="op">)</span></code></td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp">x <span class="op">|&gt;</span> f <span class="op">+</span> g</code></td>
<td><code class="sourceCode cpp"><span class="op">(</span>f <span class="op">+</span> g<span class="op">)(</span>x<span class="op">)</span></code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">x <span class="op">|&gt;</span> <span class="kw">co_await</span> <span class="op">%</span></code></td>
<td><code class="sourceCode cpp"><span class="kw">co_await</span> x</code></td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp">x <span class="op">|&gt;</span> f<span class="op">(</span><span class="dv">1</span>, <span class="op">%</span>, <span class="op">%)</span></code></td>
<td><code class="sourceCode cpp">f<span class="op">(</span><span class="dv">1</span>, x, x<span class="op">)</span></code></td>
</tr>
</tbody>
</table>
<h1 data-number="2" style="border-bottom:1px solid #cccccc" id="comparing-the-designs"><span class="header-section-number">2</span> Comparing the Designs<a href="#comparing-the-designs" class="self-link"></a></h1>
<p>Now let’s try to determine which of these we should pursue.</p>
<h2 data-number="2.1" id="rejecting-the-inverted-application-model"><span class="header-section-number">2.1</span> Rejecting the Inverted Application Model<a href="#rejecting-the-inverted-application-model" class="self-link"></a></h2>
<p>Of these, the inverted invocation model (or the F# model) the simplest to understand, specify, and implement. However, for C++ in particular, it is also the least useful.</p>
<p>It actually does happen to still work for Ranges:</p>
<blockquote>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="co">// this expression</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>r <span class="op">|&gt;</span> views<span class="op">::</span>transform<span class="op">(</span>f<span class="op">)</span> <span class="op">|&gt;</span> views<span class="op">::</span>filter<span class="op">(</span>g<span class="op">)</span></span>
<span id="cb4-3"><a href="#cb4-3"></a></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="co">// evaluates as</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>views<span class="op">::</span>filter<span class="op">(</span>g<span class="op">)(</span>views<span class="op">::</span>transform<span class="op">(</span>f<span class="op">)(</span>r<span class="op">))</span></span></code></pre></div>
</blockquote>
<p>Nobody would write the latter code today (probably), but it is valid - because <code class="sourceCode cpp">views<span class="op">::</span>transform<span class="op">(</span>f<span class="op">)</span></code> and <code class="sourceCode cpp">views<span class="op">::</span>filter<span class="op">(</span>g<span class="op">)</span></code> do give you unary function objects. But in order for that to be the case, additional library work has to be done - and it’s precisely that library work that we wrote <span class="citation" data-cites="P2011R0">[<a href="#ref-P2011R0" role="doc-biblioref">P2011R0</a>]</span> to avoid.</p>
<p>Without ready-made unary functions, we’d have to write lambdas, and our lambdas are not exactly terse:</p>
<blockquote>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a>r <span class="op">|&gt;</span> <span class="op">[=](</span><span class="kw">auto</span><span class="op">&amp;&amp;</span> r<span class="op">){</span> <span class="cf">return</span> views<span class="op">::</span>transform<span class="op">(</span>FWD<span class="op">(</span>r<span class="op">)</span>; f<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>  <span class="op">|&gt;</span> <span class="op">[=](</span><span class="kw">auto</span><span class="op">&amp;&amp;</span> r<span class="op">){</span> <span class="cf">return</span> views<span class="op">::</span>filter<span class="op">(</span>FWD<span class="op">(</span>r<span class="op">)</span>; g<span class="op">)</span>; <span class="op">}</span></span></code></pre></div>
</blockquote>
<p>Nor are our binders which additionally work on only a restricted set of potential callables:</p>
<blockquote>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a>r <span class="op">|&gt;</span> std<span class="op">::</span>bind_back<span class="op">(</span>views<span class="op">::</span>transform, f<span class="op">)</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>  <span class="op">|&gt;</span> std<span class="op">::</span>bind_back<span class="op">(</span>views<span class="op">::</span>filter, g<span class="op">)</span></span></code></pre></div>
</blockquote>
<p>And none of this avoids the unnecessary capture that this model would require. As such, it’s the easiest to reject.</p>
<h2 data-number="2.2" id="to-placehold-or-not-to-placehold"><span class="header-section-number">2.2</span> To Placehold or Not To Placehold<a href="#to-placehold-or-not-to-placehold" class="self-link"></a></h2>
<p>With placeholders, we get significantly more flexibility. There are situations where the the parameter we want to pipe into isn’t the first parameter of the function. There are multiple such examples in the standard library:</p>
<ul>
<li>In Ranges, <code class="sourceCode cpp">r1 <span class="op">|&gt;</span> zip_transform<span class="op">(</span>f, <span class="op">%</span>, r2<span class="op">)</span></code>. The function is the first parameter, but range pipelines are going to be built up of ranges.</li>
<li>Similarly, <code class="sourceCode cpp">some_tuple <span class="op">|&gt;</span> apply<span class="op">(</span>f, <span class="op">%)</span></code> and <code class="sourceCode cpp">some_variant <span class="op">|&gt;</span> visit<span class="op">(</span>f, <span class="op">%)</span></code> fall into the same boat: the function is the first parameter, but the “subject” of the operation is what you want to put on the left.</li>
</ul>
<p>Additionally there are going to be cases where the expression we want to pipe the left-hand argument into isn’t a function call, the fact that it could be anything allows for a wide variety of possibilities. Or that you could pipe into the expression multiple times.</p>
<p>Those are large plusses.</p>
<p>On the flip side, using a placeholder is necessarily more verbose than the left-threading model, by just a single character for unary adaptors (<code class="sourceCode cpp"><span class="op">|&gt;</span> f<span class="op">()</span></code> vs <code class="sourceCode cpp"><span class="op">|&gt;</span> f<span class="op">(%)</span></code>, the parentheses would be required in the left-threading model) and by three characters per invocation (<code class="sourceCode cpp"><span class="op">%</span>,</code> assuming you put a space between function arguments) for multiple arguments:</p>
<blockquote>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="co">// left-threading</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>r <span class="op">|&gt;</span> views<span class="op">::</span>transform<span class="op">(</span>f<span class="op">)</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>  <span class="op">|&gt;</span> views<span class="op">::</span>filter<span class="op">(</span>g<span class="op">)</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>  <span class="op">|&gt;</span> views<span class="op">::</span>reverse<span class="op">()</span>;</span>
<span id="cb7-5"><a href="#cb7-5"></a></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="co">// placeholder</span></span>
<span id="cb7-7"><a href="#cb7-7"></a>r <span class="op">|&gt;</span> views<span class="op">::</span>transform<span class="op">(%</span>, f<span class="op">)</span></span>
<span id="cb7-8"><a href="#cb7-8"></a>  <span class="op">|&gt;</span> views<span class="op">::</span>filter<span class="op">(%</span>, g<span class="op">)</span></span>
<span id="cb7-9"><a href="#cb7-9"></a>  <span class="op">|&gt;</span> views<span class="op">::</span>reverse<span class="op">(%)</span>;</span></code></pre></div>
</blockquote>
<p>Now, while the placeholder allows more flexibility in expressions, for certain kinds of libraries (like Ranges and the new Sender/Receiver model), the common case (indeed, the overwhelmingly common case) is to pipe into the first argument. With the left-threading model, we have no syntactic overhead as a result and don’t lose out on much. With the placeholder model, we’d end up with a veritable sea of <code class="sourceCode cpp">meow<span class="op">(%)</span></code> and <code class="sourceCode cpp">meow<span class="op">(%</span>, arg<span class="op">)</span></code>s.</p>
<p>Since left-threading is the one thing we can do today (by way of <code class="sourceCode cpp"><span class="op">|</span></code> and library machinery), it would arguably be more accurate to say that the placeholder model is four characters per call longer than the status quo:</p>
<blockquote>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="co">// status quo</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="op">|</span> views<span class="op">::</span>transform<span class="op">(</span>f<span class="op">)</span></span>
<span id="cb8-3"><a href="#cb8-3"></a></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="co">// left-threading</span></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="op">|&gt;</span> views<span class="op">::</span>transform<span class="op">(</span>f<span class="op">)</span></span>
<span id="cb8-6"><a href="#cb8-6"></a></span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="co">// placeholder</span></span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="op">|&gt;</span> views<span class="op">::</span>transform<span class="op">(%</span>, f<span class="op">)</span></span></code></pre></div>
</blockquote>
<p>Flexibility vs three extra characters may seem like a silly comparison, but ergonomics matters, and we do have libraries that are specifically designed around first-parameter-passing. It would be nice to not have to pay more syntax when we don’t need to.</p>
<p>On the whole though the argument seems to strongly favor placeholders, and if anything exploring a special case of the pipeline operator that does left-threading only and has a more restrictive right-hand side to avoid potential bugs. That might still allow the best of both worlds.</p>
<p>A recent <a href="https://youtu.be/NiferfBvN3s?t=4861">Conor Hoekstra talk</a> has a nice example that I’ll present multiple different ways (in all cases, I will not use the <code class="sourceCode cpp"><span class="op">|</span></code> from Ranges).</p>
<p>With left-threading, the example looks like:</p>
<blockquote>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">auto</span> filter_out_html_tags<span class="op">(</span>std<span class="op">::</span>string_view sv<span class="op">)</span> <span class="op">-&gt;</span> std<span class="op">::</span>string <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>  <span class="kw">auto</span> angle_bracket_mask <span class="op">=</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>    sv <span class="op">|&gt;</span> std<span class="op">::</span>views<span class="op">::</span>transform<span class="op">([](</span><span class="dt">char</span> c<span class="op">){</span> <span class="cf">return</span> c <span class="op">==</span> <span class="ch">&#39;&lt;&#39;</span> <span class="kw">or</span> c <span class="op">==</span> <span class="ch">&#39;&gt;&#39;</span>; <span class="op">})</span>;</span>
<span id="cb9-4"><a href="#cb9-4"></a></span>
<span id="cb9-5"><a href="#cb9-5"></a>  <span class="cf">return</span> std<span class="op">::</span>views<span class="op">::</span>zip_transform<span class="op">(</span></span>
<span id="cb9-6"><a href="#cb9-6"></a>      std<span class="op">::</span>logical_or<span class="op">()</span>,</span>
<span id="cb9-7"><a href="#cb9-7"></a>      angle_bracket_mask,</span>
<span id="cb9-8"><a href="#cb9-8"></a>      angle_bracket_mask <span class="op">|&gt;</span> rv<span class="op">::</span>scan_left<span class="op">(</span>std<span class="op">::</span>not_equal_to<span class="op">{})</span></span>
<span id="cb9-9"><a href="#cb9-9"></a>    <span class="op">|&gt;</span> std<span class="op">::</span>views<span class="op">::</span>zip<span class="op">(</span>sv<span class="op">)</span></span>
<span id="cb9-10"><a href="#cb9-10"></a>    <span class="op">|&gt;</span> std<span class="op">::</span>views<span class="op">::</span>filter<span class="op">([](</span><span class="kw">auto</span> t<span class="op">){</span> <span class="cf">return</span> <span class="kw">not</span> std<span class="op">::</span>get<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(</span>t<span class="op">)</span>; <span class="op">})</span></span>
<span id="cb9-11"><a href="#cb9-11"></a>    <span class="op">|&gt;</span> std<span class="op">::</span>views<span class="op">::</span>values<span class="op">()</span></span>
<span id="cb9-12"><a href="#cb9-12"></a>    <span class="op">|&gt;</span> std<span class="op">::</span>ranges<span class="op">::</span>to<span class="op">&lt;</span>std<span class="op">::</span>string<span class="op">&gt;()</span>;</span>
<span id="cb9-13"><a href="#cb9-13"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>Notably here we run into both of the limitations of left-threading: we need to pipe into a parameter other than the first and we need to pipe more than once. That requires introducing a new named variable, which is part of what this facility is trying to avoid the need for. This is not a problem for either of the placeholder-using models, as we’ll see shortly.</p>
<p>With the placeholder-mandatory model, we don’t need that temporary, since we can select which parameters of <code class="sourceCode cpp">zip_transform</code> to pipe into, and indeed we can pipe twice (I’ll have more to say about nested placeholders later):</p>
<blockquote>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">auto</span> filter_out_html_tags<span class="op">(</span>std<span class="op">::</span>string_view sv<span class="op">)</span> <span class="op">-&gt;</span> std<span class="op">::</span>string <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>  <span class="cf">return</span> sv</span>
<span id="cb10-3"><a href="#cb10-3"></a>    <span class="op">|&gt;</span> std<span class="op">::</span>views<span class="op">::</span>transform<span class="op">(%</span>, <span class="op">[](</span><span class="dt">char</span> c<span class="op">){</span> <span class="cf">return</span> c <span class="op">==</span> <span class="ch">&#39;&lt;&#39;</span> <span class="kw">or</span> c <span class="op">==</span> <span class="ch">&#39;&gt;&#39;</span>; <span class="op">})</span></span>
<span id="cb10-4"><a href="#cb10-4"></a>    <span class="op">|&gt;</span> std<span class="op">::</span>views<span class="op">::</span>zip_transform<span class="op">(</span>std<span class="op">::</span>logical_or<span class="op">{}</span>, <span class="op">%</span>, <span class="op">%</span> <span class="op">|&gt;</span> rv<span class="op">::</span>scan_left<span class="op">(%</span>, std<span class="op">::</span>not_equal_to<span class="op">{}))</span></span>
<span id="cb10-5"><a href="#cb10-5"></a>    <span class="op">|&gt;</span> std<span class="op">::</span>views<span class="op">::</span>zip<span class="op">(%</span>, sv<span class="op">)</span></span>
<span id="cb10-6"><a href="#cb10-6"></a>    <span class="op">|&gt;</span> std<span class="op">::</span>views<span class="op">::</span>filter<span class="op">(%</span>, <span class="op">[](</span><span class="kw">auto</span> t<span class="op">){</span> <span class="cf">return</span> <span class="kw">not</span> std<span class="op">::</span>get<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(</span>t<span class="op">)</span>; <span class="op">})</span></span>
<span id="cb10-7"><a href="#cb10-7"></a>    <span class="op">|&gt;</span> std<span class="op">::</span>views<span class="op">::</span>values<span class="op">(%)</span></span>
<span id="cb10-8"><a href="#cb10-8"></a>    <span class="op">|&gt;</span> std<span class="op">::</span>ranges<span class="op">::</span>to<span class="op">&lt;</span>std<span class="op">::</span>string<span class="op">&gt;(%)</span>;</span>
<span id="cb10-9"><a href="#cb10-9"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>With the language bind model, we can omit the two uses of <code class="sourceCode cpp"><span class="op">(%)</span></code> for the two unary range adaptors:</p>
<blockquote>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">auto</span> filter_out_html_tags<span class="op">(</span>std<span class="op">::</span>string_view sv<span class="op">)</span> <span class="op">-&gt;</span> std<span class="op">::</span>string <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>  <span class="cf">return</span> sv</span>
<span id="cb11-3"><a href="#cb11-3"></a>    <span class="op">|&gt;</span> std<span class="op">::</span>views<span class="op">::</span>transform<span class="op">(%</span>, <span class="op">[](</span><span class="dt">char</span> c<span class="op">){</span> <span class="cf">return</span> c <span class="op">==</span> <span class="ch">&#39;&lt;&#39;</span> <span class="kw">or</span> c <span class="op">==</span> <span class="ch">&#39;&gt;&#39;</span>; <span class="op">})</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>    <span class="op">|&gt;</span> std<span class="op">::</span>views<span class="op">::</span>zip_transform<span class="op">(</span>std<span class="op">::</span>logical_or<span class="op">{}</span>, <span class="op">%</span>, <span class="op">%</span> <span class="op">|&gt;</span> rv<span class="op">::</span>scan_left<span class="op">(%</span>, std<span class="op">::</span>not_equal_to<span class="op">{}))</span></span>
<span id="cb11-5"><a href="#cb11-5"></a>    <span class="op">|&gt;</span> std<span class="op">::</span>views<span class="op">::</span>zip<span class="op">(%</span>, sv<span class="op">)</span></span>
<span id="cb11-6"><a href="#cb11-6"></a>    <span class="op">|&gt;</span> std<span class="op">::</span>views<span class="op">::</span>filter<span class="op">(%</span>, <span class="op">[](</span><span class="kw">auto</span> t<span class="op">){</span> <span class="cf">return</span> <span class="kw">not</span> std<span class="op">::</span>get<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(</span>t<span class="op">)</span>; <span class="op">})</span></span>
<span id="cb11-7"><a href="#cb11-7"></a>    <span class="op">|&gt;</span> std<span class="op">::</span>views<span class="op">::</span>values</span>
<span id="cb11-8"><a href="#cb11-8"></a>    <span class="op">|&gt;</span> std<span class="op">::</span>ranges<span class="op">::</span>to<span class="op">&lt;</span>std<span class="op">::</span>string<span class="op">&gt;</span>;</span>
<span id="cb11-9"><a href="#cb11-9"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>And with the introduction of a dedicated operator for left-threading, say <code class="sourceCode cpp">\<span class="op">&gt;</span></code>, we can omit four more instances of placeholder:</p>
<blockquote>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">auto</span> filter_out_html_tags<span class="op">(</span>std<span class="op">::</span>string_view sv<span class="op">)</span> <span class="op">-&gt;</span> std<span class="op">::</span>string <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>  <span class="cf">return</span> sv</span>
<span id="cb12-3"><a href="#cb12-3"></a>    \<span class="op">&gt;</span> std<span class="op">::</span>views<span class="op">::</span>transform<span class="op">([](</span><span class="dt">char</span> c<span class="op">){</span> <span class="cf">return</span> c <span class="op">==</span> <span class="ch">&#39;&lt;&#39;</span> <span class="kw">or</span> c <span class="op">==</span> <span class="ch">&#39;&gt;&#39;</span>; <span class="op">})</span></span>
<span id="cb12-4"><a href="#cb12-4"></a>    <span class="op">|&gt;</span> std<span class="op">::</span>views<span class="op">::</span>zip_with<span class="op">(</span>std<span class="op">::</span>logical_or<span class="op">{}</span>, <span class="op">%</span>, <span class="op">%</span> \<span class="op">&gt;</span> rv<span class="op">::</span>scan_left<span class="op">(</span>std<span class="op">::</span>not_equal_to<span class="op">{}))</span></span>
<span id="cb12-5"><a href="#cb12-5"></a>    \<span class="op">&gt;</span> std<span class="op">::</span>views<span class="op">::</span>zip<span class="op">(</span>sv<span class="op">)</span></span>
<span id="cb12-6"><a href="#cb12-6"></a>    \<span class="op">&gt;</span> std<span class="op">::</span>views<span class="op">::</span>filter<span class="op">([](</span><span class="kw">auto</span> t<span class="op">){</span> <span class="cf">return</span> <span class="kw">not</span> std<span class="op">::</span>get<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(</span>t<span class="op">)</span>; <span class="op">})</span></span>
<span id="cb12-7"><a href="#cb12-7"></a>    <span class="op">|&gt;</span> std<span class="op">::</span>views<span class="op">::</span>values</span>
<span id="cb12-8"><a href="#cb12-8"></a>    <span class="op">|&gt;</span> std<span class="op">::</span>ranges<span class="op">::</span>to<span class="op">&lt;</span>std<span class="op">::</span>string<span class="op">&gt;</span>;</span>
<span id="cb12-9"><a href="#cb12-9"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>The difference the various placeholder models is about counting characters. For unary functions, can we write <code class="sourceCode cpp">x <span class="op">|&gt;</span> f</code> or do we have to write <code class="sourceCode cpp">x <span class="op">|&gt;</span> f<span class="op">(%)</span></code>? And then for left-threading, do we have to write <code class="sourceCode cpp">x <span class="op">|&gt;</span> f<span class="op">(%</span>, y<span class="op">)</span></code> or can we avoid the placeholder with a dedicated <code class="sourceCode cpp">x \<span class="op">&gt;</span> f<span class="op">(</span>y<span class="op">)</span></code>? Overall, the last solution (language bind with <code class="sourceCode cpp">\<span class="op">&gt;</span></code>) is 18 characters shorter than the placeholder solution, simply by removing what is arguably syntactic noise.</p>
<p>To be honest though, regardless of those 18 characters, the thing that annoys me the most in this example is the lambda. More on that later.</p>
<h2 data-number="2.3" id="placeholder-or-language-bind"><span class="header-section-number">2.3</span> Placeholder or Language Bind<a href="#placeholder-or-language-bind" class="self-link"></a></h2>
<p>These are the two most similar models, so let’s just compare them against each other using a representative example:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Placeholder</strong>
</div></th>
<th><div style="text-align:center">
<strong>Language Bind</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">auto</span> v <span class="op">=</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>  r <span class="op">|&gt;</span> views<span class="op">::</span>transform<span class="op">(%</span>, f<span class="op">)</span></span>
<span id="cb13-3"><a href="#cb13-3"></a>    <span class="op">|&gt;</span> views<span class="op">::</span>filter<span class="op">(%</span>, g<span class="op">)</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>    <span class="op">|&gt;</span> views<span class="op">::</span>reverse<span class="op">(%)</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>    <span class="op">|&gt;</span> ranges<span class="op">::</span>to<span class="op">&lt;</span>std<span class="op">::</span>vector<span class="op">&gt;(%)</span>;</span></code></pre></div></td>
<td><div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">auto</span> v <span class="op">=</span></span>
<span id="cb14-2"><a href="#cb14-2"></a>  r <span class="op">|&gt;</span> views<span class="op">::</span>transform<span class="op">(%</span>, f<span class="op">)</span></span>
<span id="cb14-3"><a href="#cb14-3"></a>    <span class="op">|&gt;</span> views<span class="op">::</span>filter<span class="op">(%</span>, g<span class="op">)</span></span>
<span id="cb14-4"><a href="#cb14-4"></a>    <span class="op">|&gt;</span> views<span class="op">::</span>reverse</span>
<span id="cb14-5"><a href="#cb14-5"></a>    <span class="op">|&gt;</span> ranges<span class="op">::</span>to<span class="op">&lt;</span>std<span class="op">::</span>vector<span class="op">&gt;</span>;</span></code></pre></div></td>
</tr>
</tbody>
</table>
<p>When the range adaptor is binary (as in <code class="sourceCode cpp">transform</code> or <code class="sourceCode cpp">filter</code> or many others), the two are equivalent. We use a placeholder (<code class="sourceCode cpp"><span class="op">%</span></code> in this case) for the left-hand side and then provide the other argument manually. No additional binding occurs.</p>
<p>But when the range adaptor is unary, in the placeholder (Hack) model, we still have to use a placeholder. Because we always have to use a placeholder, that’s the model. But in the language bind model, a unary adaptor is already a unary function, so there’s no need to use language bind to produce one. It just works. In the case where we already have a unary function, the language bind model is three characters shorter - no need to write the <code class="sourceCode cpp"><span class="op">(%)</span></code>.</p>
<p>Consider this alternative example, which would be the same syntax in both models:</p>
<blockquote>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">auto</span> squares<span class="op">()</span> <span class="op">-&gt;</span> std<span class="op">::</span>generator<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2"></a>    std<span class="op">::</span>views<span class="op">::</span>iota<span class="op">(</span><span class="dv">0</span><span class="op">)</span></span>
<span id="cb15-3"><a href="#cb15-3"></a>        <span class="op">|&gt;</span> std<span class="op">::</span>views<span class="op">::</span>transform<span class="op">(%</span>, <span class="op">[](</span><span class="dt">int</span> i<span class="op">){</span> <span class="cf">return</span> i <span class="op">*</span> i; <span class="op">})</span></span>
<span id="cb15-4"><a href="#cb15-4"></a>        <span class="op">|&gt;</span> <span class="kw">co_yield</span> std<span class="op">::</span>ranges<span class="op">::</span>elements_of<span class="op">(%)</span>;</span>
<span id="cb15-5"><a href="#cb15-5"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>Admittedly not the most straightforward way to write this function, but it works as an example and helps demonstrate the utility and flexibility of placeholders. Now, let’s talk about what this example means in the respective models.</p>
<p>In the placeholder model, this is a straightforward rewrite into a different expression - because the placeholder model is always a rewrite into a different expression. Even if that expression is a <code class="sourceCode cpp"><span class="kw">co_yield</span></code>.</p>
<p>But in the language bind model, this becomes a little fuzzier. If we say that <code class="sourceCode cpp"><span class="kw">co_yield</span> std<span class="op">::</span>ranges<span class="op">::</span>elements_of<span class="op">(%)</span></code> is effectively a language bind (even if we side-step the question of captures since we know we’re immediately evaluating), that sort of has to imply that the <code class="sourceCode cpp"><span class="kw">co_yield</span></code> happens in the body of some new function right? But <code class="sourceCode cpp"><span class="kw">co_yield</span></code> can’t work like that, it has to be invoked from <code class="sourceCode cpp">squares</code> and not from any other internal function. It’s not like we actually need to construct a lambda to evaluate this expression, but it does break the cleanliness of saying that this is just inverted function invocation.</p>
<p>Language bind is a more complex model than placeholders and requires a little hand-waving around what exactly we’re doing, for a benefit of three characters per unary function call. Is it worth it?</p>
<h1 data-number="3" style="border-bottom:1px solid #cccccc" id="placeholder-lambdas"><span class="header-section-number">3</span> Placeholder Lambdas<a href="#placeholder-lambdas" class="self-link"></a></h1>
<p>One reason I consider the language bind model attractive, despite the added complexity (both in having to handle <code class="sourceCode cpp">x <span class="op">|&gt;</span> f</code> in addition to <code class="sourceCode cpp">x <span class="op">|&gt;</span> f<span class="op">(%)</span></code> and also having to hand-wave around what <code class="sourceCode cpp">x <span class="op">|&gt;</span> <span class="kw">co_yield</span> <span class="op">%</span></code> means) is that it also offers a path towards placeholder lambdas. Allow me an aside.</p>
<p>There are basically three approaches that languages take to lambdas (some languages do more than one of these).</p>
<ol type="1">
<li>Direct language support for partial application</li>
<li>Placeholder expressions</li>
<li>Abbreviated function declarations</li>
</ol>
<p>I’ll illustrate what I mean here by using a simple example: how do you write a lambda that is a unary predicate which checks if its parameter is a negative integer?</p>
<p>For the languages that support partial application, that looks like:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Expression</strong>
</div></th>
<th><div style="text-align:center">
<strong>Language</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="op">(&lt;</span><span class="dv">0</span><span class="op">)</span></code></td>
<td>Haskell</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp"><span class="op">(&lt;)</span> <span class="dv">0</span></code></td>
<td>F#</td>
</tr>
</tbody>
</table>
<p>For the languages that provide abbreviated function declarations, we basically have a section that introduces names followed by a body that uses those names:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Expression</strong>
</div></th>
<th><div style="text-align:center">
<strong>Language</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="op">|</span>e<span class="op">|</span> e <span class="op">&lt;</span> <span class="dv">0</span></code></td>
<td>Rust</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">e <span class="op">-&gt;</span> e <span class="op">&lt;</span> <span class="dv">0</span></code></td>
<td>Java</td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp">e <span class="op">=&gt;</span> e <span class="op">&lt;</span> <span class="dv">0</span></code></td>
<td>C#, JavaScript, Scala</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">\e <span class="op">-&gt;</span> e <span class="op">&lt;</span> <span class="dv">0</span></code></td>
<td>Haskell</td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="op">{</span> <span class="op">|</span>e<span class="op">|</span> e <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">}</span></code></td>
<td>Ruby</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp"><span class="op">{</span> e in e <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">}</span></code></td>
<td>Swift</td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="op">{</span> e <span class="op">-&gt;</span> e <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">}</span></code></td>
<td>Kotlin</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">fun e <span class="op">-&gt;</span> e <span class="op">&lt;</span> <span class="dv">0</span></code></td>
<td>F#, OCaml</td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp">lambda e<span class="op">:</span> e <span class="op">&lt;</span> <span class="dv">0</span></code></td>
<td>Python</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">fn e <span class="op">-&gt;</span> e <span class="op">&lt;</span> <span class="dv">0</span> end</code></td>
<td>Elixir</td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="op">[](</span><span class="dt">int</span> e<span class="op">){</span> <span class="cf">return</span> e <span class="op">&lt;</span> <span class="dv">0</span>; <span class="op">}</span></code></td>
<td>C++</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">func<span class="op">(</span>e <span class="dt">int</span><span class="op">)</span> <span class="dt">bool</span> <span class="op">{</span> <span class="cf">return</span> e <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">}</span></code></td>
<td>Go</td>
</tr>
</tbody>
</table>
<p>On the plus side, C++ is not the longest.</p>
<p>But the interesting case I wanted to discuss here is those languages that support placeholder expressions:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Expression</strong>
</div></th>
<th><div style="text-align:center">
<strong>Language</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="sourceCode cpp">_ <span class="op">&lt;</span> <span class="dv">0</span></code></td>
<td>Scala</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">_1 <span class="op">&lt;</span> <span class="dv">0</span></code></td>
<td>Boost.Lambda (and other Boost libraries)</td>
</tr>
<tr class="odd">
<td><code class="x">#(&lt; % 0)</code></td>
<td>Clojure</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp"><span class="op">&amp;(&amp;</span><span class="dv">1</span> <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span></code></td>
<td>Elixir</td>
</tr>
<tr class="odd">
<td><code class="x">{ $0 &lt; 0 }</code></td>
<td>Swift</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp"><span class="op">{</span> it <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">}</span></code></td>
<td>Kotlin</td>
</tr>
</tbody>
</table>
<p>There’s a lot of variety in these placeholder lambdas. Some languages number their parameters and let you write whatever you want (Swift starts numbering at <code class="sourceCode cpp"><span class="dv">0</span></code>, Elixir at <code class="sourceCode cpp"><span class="dv">1</span></code>, Clojure also at <code class="sourceCode cpp"><span class="dv">1</span></code> but also provides <code class="sourceCode cpp"><span class="op">%</span></code> as a shorthand), Kotlin only provides the special variable <code class="sourceCode cpp">it</code> to be the first parameter and has no support if you want others.</p>
<p>Scala is unique in that it only provides <code class="sourceCode cpp">_</code>, but that placeholder refers to a different parameter on each use. So <code class="sourceCode cpp">_ <span class="op">&gt;</span> _</code> is a binary predicate that checks if the first parameter is greater than the second.</p>
<p>Now, for this particular example, we also have library solutions available to us, and have for quite some time. There are several libraries <em>just in Boost</em> that allow for either <code class="sourceCode cpp">_1 <span class="op">&lt;</span> <span class="dv">0</span></code> or <code class="sourceCode cpp">_ <span class="op">&lt;</span> <span class="dv">0</span></code> to mean the same thing as illustrated above (Boost.HOF’s <code class="sourceCode cpp">_</code> behaves similar to Scala - at least to the extent that is possible in a library). Having placeholder lambdas is quite popular precisely because there’s no noise; when writing a simple expression, having to deal with the ceremony of introducing names and dealing with the return type is excessive. For instance, to implement <span class="citation" data-cites="P2321R1">[<a href="#ref-P2321R1" role="doc-biblioref">P2321R1</a>]</span>’s <code class="sourceCode cpp">zip</code>, you need to dereference all the iterators in a tuple:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Regular Lambda</strong>
</div></th>
<th><div style="text-align:center">
<strong>Placeholder Lambda</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1"></a>tuple_transform<span class="op">([](</span><span class="kw">auto</span><span class="op">&amp;</span> it<span class="op">)</span> <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span><span class="kw">auto</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2"></a>    <span class="cf">return</span> <span class="op">*</span>it;</span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="op">}</span>, current_<span class="op">)</span></span></code></pre></div></td>
<td><div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1"></a>tuple_transform<span class="op">(*</span>_, current_<span class="op">)</span></span></code></pre></div></td>
</tr>
</tbody>
</table>
<p>The C++ library solutions are fundamentally limited to operators though. You can make <code class="sourceCode cpp">_1 <span class="op">==</span> <span class="dv">0</span></code> work, but you can’t really make <code class="sourceCode cpp">_1<span class="op">.</span>id<span class="op">()</span> <span class="op">==</span> <span class="dv">0</span></code> or <code class="sourceCode cpp">f<span class="op">(</span>_1<span class="op">)</span></code> work. As a language feature, having member functions work is trivial. But having non-member functions work is… not.</p>
<p>In the table of languages that support placeholder lambdas, four of them have <em>bounded</em> expressions: there is punctuation to mark where the lambda expression begins and ends. This is due to a fundamental ambiguity: what does <code class="sourceCode cpp">f<span class="op">(%)</span></code> mean? It could either mean invoking <code class="sourceCode cpp">f</code> with a unary lambda that returns its argument (i.e. <code class="sourceCode cpp">f<span class="op">(</span>e <span class="op">=&gt;</span> e<span class="op">)</span></code>) or it could mean a unary lambda that invokes <code class="sourceCode cpp">f</code> on its argument (i.e. <code class="sourceCode cpp">e <span class="op">=&gt;</span> f<span class="op">(</span>e<span class="op">)</span></code>). How do you know which one is which?</p>
<p>Scala, which does not have bounded placeholder expressions, takes an interesting direction here:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Expression</strong>
</div></th>
<th><div style="text-align:center">
<strong>Meaning</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="sourceCode cpp">f<span class="op">(</span>_<span class="op">)</span></code></td>
<td><code class="sourceCode cpp">e <span class="op">=&gt;</span> f<span class="op">(</span>e<span class="op">)</span></code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">f<span class="op">(</span>_, x<span class="op">)</span></code></td>
<td><code class="sourceCode cpp">e <span class="op">=&gt;</span> f<span class="op">(</span>e, x<span class="op">)</span></code></td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp">f<span class="op">(</span>_ <span class="op">+</span> <span class="dv">2</span><span class="op">)</span></code></td>
<td><code class="sourceCode cpp">e <span class="op">=&gt;</span> f<span class="op">(</span>e <span class="op">+</span> <span class="dv">2</span><span class="op">)</span></code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">f<span class="op">(</span><span class="dv">1</span>, <span class="dv">2</span>, g<span class="op">(</span>_<span class="op">))</span></code></td>
<td><code class="sourceCode cpp">f<span class="op">(</span><span class="dv">1</span>, <span class="dv">2</span>, e <span class="op">=&gt;</span> g<span class="op">(</span>e<span class="op">))</span></code></td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp">f<span class="op">(</span><span class="dv">1</span>, _<span class="op">)</span></code></td>
<td><code class="sourceCode cpp">e <span class="op">=&gt;</span> f<span class="op">(</span><span class="dv">1</span>, e<span class="op">)</span></code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">f<span class="op">(</span><span class="dv">1</span>, _ <span class="op">+</span> <span class="dv">1</span><span class="op">)</span></code></td>
<td><code class="sourceCode cpp">f<span class="op">(</span><span class="dv">1</span>, e <span class="op">=&gt;</span> e <span class="op">+</span> <span class="dv">1</span><span class="op">)</span></code></td>
</tr>
</tbody>
</table>
<p>I’m pretty sure we wouldn’t want to go that route in C++, where we come up with some rule for what constitutes the bounded expression around the placeholder.</p>
<p>But also more to the point, when the placeholder expression refers to (odr-uses) a variable, we need to capture it, and we need to know <em>how</em> to capture it.</p>
<p>So a C++ approach to placeholder lambdas might be: a <em>lambda-introducer</em>, followed by some token to distinguish it from a regular lambda (e.g. <code class="sourceCode cpp"><span class="op">:</span></code> or <code class="sourceCode cpp"><span class="op">=&gt;</span></code>), followed by a placeholder expression. That is, the placeholder lambda for the negative example might be <code class="sourceCode cpp"><span class="op">[]:</span> <span class="op">%</span><span class="dv">1</span> <span class="op">&lt;</span> <span class="dv">0</span></code> or just <code class="sourceCode cpp"><span class="op">[]:</span> <span class="op">%</span> <span class="op">&lt;</span> <span class="dv">0</span></code>. At 9 characters, this is substantially shorter than the C++ lambda we have to write today (26 characters), and this is about as short as a C++ lambda gets (the dereference example would be 7 characters as compared to 46). And while it’s longer than the various library approaches (Boost.HOF’s <code class="sourceCode cpp">_ <span class="op">&lt;</span> <span class="dv">0</span></code> is just 5), it would have the flexibility to do anything. Probably good enough.</p>
<p>Alternatively could do something closer to Elixir and wrap the placeholder lambda expression, so something like: <code class="sourceCode cpp"><span class="op">[]</span> <span class="op">%(%</span><span class="dv">1</span> <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span></code>.</p>
<p>For more on the topic of placeholder lambdas in C++, consider <code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;</span></code>’s blog posts “Now I Am Become Perl” <span class="citation" data-cites="vector-bool">[<a href="#ref-vector-bool" role="doc-biblioref">vector-bool</a>]</span> and his macro-based solution to the problem <span class="citation" data-cites="vector-bool-macro">[<a href="#ref-vector-bool-macro" role="doc-biblioref">vector-bool-macro</a>]</span>.</p>
<p>Getting back to the topic, when I talked originally about:</p>
<blockquote>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1"></a>x <span class="op">|&gt;</span> f<span class="op">(</span>y, <span class="op">%)</span>  <span class="co">// means f(y, x)</span></span></code></pre></div>
</blockquote>
<p>I noted that <code class="sourceCode cpp">f<span class="op">(</span>y, <span class="op">%)</span></code> kind of serves as language bind expression, which itself justifies having the model support <code class="sourceCode cpp">x <span class="op">|&gt;</span> f</code>. But it may also justify splitting the above expression in two:</p>
<blockquote>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1"></a><span class="co">// some version of lambda placeholder syntax</span></span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="kw">auto</span> fy <span class="op">=</span> <span class="op">[=]</span> <span class="op">%(</span>f<span class="op">(</span>y, <span class="op">%</span><span class="dv">1</span><span class="op">))</span>;</span>
<span id="cb19-3"><a href="#cb19-3"></a><span class="kw">auto</span> fy <span class="op">=</span> <span class="op">[=]</span> <span class="op">%(</span>f<span class="op">(</span>y, <span class="op">%))</span>;</span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="kw">auto</span> fy <span class="op">=</span> <span class="op">[=]:</span> f<span class="op">(</span>y, <span class="op">%</span><span class="dv">1</span><span class="op">)</span>;</span>
<span id="cb19-5"><a href="#cb19-5"></a><span class="kw">auto</span> fy <span class="op">=</span> <span class="op">[=]:</span> f<span class="op">(</span>y, <span class="op">%)</span>;</span>
<span id="cb19-6"><a href="#cb19-6"></a></span>
<span id="cb19-7"><a href="#cb19-7"></a><span class="co">// at which point it&#39;s just a lambda</span></span>
<span id="cb19-8"><a href="#cb19-8"></a>fy<span class="op">(</span>x<span class="op">)</span>         <span class="co">// evaluates to f(y, x)</span></span></code></pre></div>
</blockquote>
<p>Although note that with the lambda, you have to capture <code class="sourceCode cpp">y</code>, whereas with the pipeline expression, there was no intermediate step.</p>
<h1 data-number="4" style="border-bottom:1px solid #cccccc" id="bibliography"><span class="header-section-number">4</span> References<a href="#bibliography" class="self-link"></a></h1>
<div id="refs" class="references hanging-indent" role="doc-bibliography">
<div id="ref-javascript.pipeline">
<p>[javascript.pipeline] TC39. 2019. Proposals for <code class="sourceCode cpp"><span class="op">|&gt;</span></code> operator. <br />
<a href="https://github.com/tc39/proposal-pipeline-operator/">https://github.com/tc39/proposal-pipeline-operator/</a></p>
</div>
<div id="ref-P2011R0">
<p>[P2011R0] Barry Revzin, Colby Pike. 2020-01-07. A pipeline-rewrite operator. <br />
<a href="https://wg21.link/p2011r0">https://wg21.link/p2011r0</a></p>
</div>
<div id="ref-P2321R1">
<p>[P2321R1] Tim Song. 2021-04-11. zip. <br />
<a href="https://wg21.link/p2321r1">https://wg21.link/p2321r1</a></p>
</div>
<div id="ref-vector-bool">
<p>[vector-bool] Colby Pike. 2018. Now I Am Become Perl. <br />
<a href="https://vector-of-bool.github.io/2018/10/31/become-perl.html">https://vector-of-bool.github.io/2018/10/31/become-perl.html</a></p>
</div>
<div id="ref-vector-bool-macro">
<p>[vector-bool-macro] Colby Pike. 2021. A Macro-Based Terse Lambda Expression. <br />
<a href="https://vector-of-bool.github.io/2021/04/20/terse-lambda-macro.html">https://vector-of-bool.github.io/2021/04/20/terse-lambda-macro.html</a></p>
</div>
</div>
</div>
</div>
</body>
</html>
