<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="mpark/wg21" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2022-06-29" />
  <title>Exploring Placeholders</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
      div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
      ul.task-list{list-style: none;}
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode
        {  background-color: #f6f8fa; }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span. { } /* Normal */
      code span.al { color: #ff0000; } /* Alert */
      code span.an { } /* Annotation */
      code span.at { } /* Attribute */
      code span.bn { color: #9f6807; } /* BaseN */
      code span.bu { color: #9f6807; } /* BuiltIn */
      code span.cf { color: #00607c; } /* ControlFlow */
      code span.ch { color: #9f6807; } /* Char */
      code span.cn { } /* Constant */
      code span.co { color: #008000; font-style: italic; } /* Comment */
      code span.cv { color: #008000; font-style: italic; } /* CommentVar */
      code span.do { color: #008000; } /* Documentation */
      code span.dt { color: #00607c; } /* DataType */
      code span.dv { color: #9f6807; } /* DecVal */
      code span.er { color: #ff0000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #9f6807; } /* Float */
      code span.fu { } /* Function */
      code span.im { } /* Import */
      code span.in { color: #008000; } /* Information */
      code span.kw { color: #00607c; } /* Keyword */
      code span.op { color: #af1915; } /* Operator */
      code span.ot { } /* Other */
      code span.pp { color: #6f4e37; } /* Preprocessor */
      code span.re { } /* RegionMarker */
      code span.sc { color: #9f6807; } /* SpecialChar */
      code span.ss { color: #9f6807; } /* SpecialString */
      code span.st { color: #9f6807; } /* String */
      code span.va { } /* Variable */
      code span.vs { color: #9f6807; } /* VerbatimString */
      code span.wa { color: #008000; font-weight: bold; } /* Warning */
      code.diff {color: #898887}
      code.diff span.va {color: #006e28}
      code.diff span.st {color: #bf0303}
  </style>
  <style type="text/css">
body {
margin: 5em;
font-family: serif;

hyphens: auto;
line-height: 1.35;
}
div.wrapper {
max-width: 60em;
margin: auto;
}
ul {
list-style-type: none;
padding-left: 2em;
margin-top: -0.2em;
margin-bottom: -0.2em;
}
a {
text-decoration: none;
color: #4183C4;
}
a.hidden_link {
text-decoration: none;
color: inherit;
}
li {
margin-top: 0.6em;
margin-bottom: 0.6em;
}
h1, h2, h3, h4 {
position: relative;
line-height: 1;
}
a.self-link {
position: absolute;
top: 0;
left: calc(-1 * (3.5rem - 26px));
width: calc(3.5rem - 26px);
height: 2em;
text-align: center;
border: none;
transition: opacity .2s;
opacity: .5;
font-family: sans-serif;
font-weight: normal;
font-size: 83%;
}
a.self-link:hover { opacity: 1; }
a.self-link::before { content: "§"; }
ul > li:before {
content: "\2014";
position: absolute;
margin-left: -1.5em;
}
:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }
.abbr_ref { float: right; }
.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }
:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }
.secnum { display: inline-block; min-width: 35pt; }
.header-section-number { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }
div.sourceLinkParent {
float: right;
}
a.sourceLink {
position: absolute;
opacity: 0;
margin-left: 10pt;
}
a.sourceLink:hover {
opacity: 1;
}
a.itemDeclLink {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
opacity: 0;
}
a.itemDeclLink:hover { opacity: 1; }
span.marginalizedparent {
position: relative;
left: -5em;
}
li span.marginalizedparent { left: -7em; }
li ul > li span.marginalizedparent { left: -9em; }
li ul > li ul > li span.marginalizedparent { left: -11em; }
li ul > li ul > li ul > li span.marginalizedparent { left: -13em; }
div.footnoteNumberParent {
position: relative;
left: -4.7em;
}
a.marginalized {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
}
a.enumerated_item_num {
position: relative;
left: -3.5em;
display: inline-block;
margin-right: -3em;
text-align: right;
width: 3em;
}
div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }
span.indexparent {
display: inline;
position: relative;
float: right;
right: -1em;
}
a.index {
position: absolute;
display: none;
}
a.index:before { content: "⟵"; }

a.index:target {
display: inline;
}
.indexitems {
margin-left: 2em;
text-indent: -2em;
}
div.itemdescr {
margin-left: 3em;
}
.bnf {
font-family: serif;
margin-left: 40pt;
margin-top: 0.5em;
margin-bottom: 0.5em;
}
.ncbnf {
font-family: serif;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
}
.ncsimplebnf {
font-family: serif;
font-style: italic;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
background: inherit; 
}
span.textnormal {
font-style: normal;
font-family: serif;
white-space: normal;
display: inline-block;
}
span.rlap {
display: inline-block;
width: 0px;
}
span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }
span.phantom { color: white; }

span.math { font-style: normal; }
span.mathblock {
display: block;
margin-left: auto;
margin-right: auto;
margin-top: 1.2em;
margin-bottom: 1.2em;
text-align: center;
}
span.mathalpha {
font-style: italic;
}
span.synopsis {
font-weight: bold;
margin-top: 0.5em;
display: block;
}
span.definition {
font-weight: bold;
display: block;
}
.codeblock {
margin-left: 1.2em;
line-height: 127%;
}
.outputblock {
margin-left: 1.2em;
line-height: 127%;
}
div.itemdecl {
margin-top: 2ex;
}
code.itemdeclcode {
white-space: pre;
display: block;
}
span.textsuperscript {
vertical-align: super;
font-size: smaller;
line-height: 0;
}
.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }
.footnote {
font-size: small;
margin-left: 2em;
margin-right: 2em;
margin-top: 0.6em;
margin-bottom: 0.6em;
}
div.minipage {
display: inline-block;
margin-right: 3em;
}
div.numberedTable {
text-align: center;
margin: 2em;
}
div.figure {
text-align: center;
margin: 2em;
}
table {
border: 1px solid black;
border-collapse: collapse;
margin-left: auto;
margin-right: auto;
margin-top: 0.8em;
text-align: left;
hyphens: none; 
}
td, th {
padding-left: 1em;
padding-right: 1em;
vertical-align: top;
}
td.empty {
padding: 0px;
padding-left: 1px;
}
td.left {
text-align: left;
}
td.right {
text-align: right;
}
td.center {
text-align: center;
}
td.justify {
text-align: justify;
}
td.border {
border-left: 1px solid black;
}
tr.rowsep, td.cline {
border-top: 1px solid black;
}
tr.even, tr.odd {
border-bottom: 1px solid black;
}
tr.capsep {
border-top: 3px solid black;
border-top-style: double;
}
tr.header {
border-bottom: 3px solid black;
border-bottom-style: double;
}
th {
border-bottom: 1px solid black;
}
span.centry {
font-weight: bold;
}
div.table {
display: block;
margin-left: auto;
margin-right: auto;
text-align: center;
width: 90%;
}
span.indented {
display: block;
margin-left: 2em;
margin-bottom: 1em;
margin-top: 1em;
}
ol.enumeratea { list-style-type: none; background: inherit; }
ol.enumerate { list-style-type: none; background: inherit; }

code.sourceCode > span { display: inline; }
</style>
  <style type="text/css">a {
color : #4183C4;
text-decoration: underline;
}
a.marginalized {
text-decoration: none;
}
a.self-link {
text-decoration: none;
}
h1#toctitle {
border-bottom: 1px solid #cccccc;
}
#TOC li {
margin-top: 1px;
margin-bottom: 1px;
}
#TOC ul>li:before { display: none; }
h3.subtitle { margin-top: -15px; }
h1:target { background-color: transparent; }
h2:target { background-color: transparent; }
h3:target { background-color: transparent; }
h4:target { background-color: transparent; }
h5:target { background-color: transparent; }
h6:target { background-color: transparent; }
code span.co { font-family: monospace; }
table tr {
background-color: white;
}
table tr:nth-child(2n) {
background-color: #f6f8fa;
}
#title-block-header > table tr:nth-child(2n) {
background-color: white;
}
td > div.sourceCode {
background-color: inherit;
}
table {
border-collapse: collapse;
}
table td, table th {
border: 1px solid #cccccc;
}
table th {
border-bottom: 1px solid black;
text-align: center;
}
table tr:first-child th {
border-top: 0;
}
table tr:last-child td {
border-bottom: 0;
}
table tr td:first-child,
table tr th:first-child {
border-left: 0;
}
table tr td:last-child,
table tr th:last-child {
border-right: 0;
}
table tbody tr:first-child td {
border-top: 1px solid black;
}
#title-block-header td { border: 0; }
@media all {
body {
margin: 2em;
}
}
@media screen and (min-width: 480px) {
body {
margin: 5em;
}
}
#refs code{padding-left: 0px; text-indent: 0px;}
:root {
--diff-ins: #e6ffed;
--diff-strongins: #acf2bd;
--diff-del: #ffdddd;
--diff-strongdel: #ff8888;
}
span.diffins {
background-color: var(--diff-strongins);
}
span.diffdel {
background-color: var(--diff-strongdel);
}
div.rm { text-decoration: line-through; }
div.rm code.sourceCode { text-decoration: line-through; }
div.addu, span.addu {
color: #006e28;
background-color: var(--diff-ins);
}

div.rm pre, div.add pre { background-color: #f6f8fa; }
div.addu pre { background-color: var(--diff-ins); }
div.add, div.add pre { background-color: var(--diff-ins); }
div.addu blockquote {
border-left: 4px solid #00a000;
padding: 0 15px;
color: #006e28;
text-decoration: none;
}
div.addu blockquote code.sourceCode { text-decoration: none; }
div.addu blockquote pre { text-decoration: none; }
div.addu blockquote pre code { text-decoration: none; }
div.quote {
border-left: 7px solid #ccc;
background: #f9f9f9;
margin: 1.5em 10px;
padding-left: 20px;
}
code.diff span.va { color: #000000; background-color: var(--diff-ins); }
code.diff span.st { color: #000000; background-color: var(--diff-del); }
</style>
  <link href="data:image/x-icon;base64,AAABAAIAEBAAAAEAIABoBAAAJgAAACAgAAABACAAqBAAAI4EAAAoAAAAEAAAACAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAVoJEAN6CRADegkQAWIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wCCRAAAgkQAAIJEAACCRAAsgkQAvoJEAP+CRAD/gkQA/4JEAP+CRADAgkQALoJEAACCRAAAgkQAAP///wD///8AgkQAAIJEABSCRACSgkQA/IJEAP99PQD/dzMA/3czAP99PQD/gkQA/4JEAPyCRACUgkQAFIJEAAD///8A////AHw+AFiBQwDqgkQA/4BBAP9/PxP/uZd6/9rJtf/bybX/upd7/39AFP+AQQD/gkQA/4FDAOqAQgBc////AP///wDKklv4jlEa/3o7AP+PWC//8+3o///////////////////////z7un/kFox/35AAP+GRwD/mVYA+v///wD///8A0Zpk+NmibP+0d0T/8evj///////+/fv/1sKz/9bCs//9/fr//////+/m2/+NRwL/nloA/5xYAPj///8A////ANKaZPjRmGH/5cKh////////////k149/3UwAP91MQD/lmQ//86rhv+USg3/m1YA/5hSAP+bVgD4////AP///wDSmmT4zpJY/+/bx///////8+TV/8mLT/+TVx//gkIA/5lVAP+VTAD/x6B//7aEVv/JpH7/s39J+P///wD///8A0ppk+M6SWP/u2sf///////Pj1f/Nj1T/2KFs/8mOUv+eWhD/lEsA/8aee/+0glT/x6F7/7J8Rvj///8A////ANKaZPjRmGH/48Cf///////+/v7/2qt//82PVP/OkFX/37KJ/86siv+USg7/mVQA/5hRAP+bVgD4////AP///wDSmmT40ppk/9CVXP/69O////////7+/v/x4M//8d/P//7+/f//////9u7n/6tnJf+XUgD/nFgA+P///wD///8A0ppk+NKaZP/RmWL/1qNy//r07///////////////////////+vXw/9akdP/Wnmn/y5FY/6JfFvj///8A////ANKaZFTSmmTo0ppk/9GYYv/Ql1//5cWm//Hg0P/x4ND/5cWm/9GXYP/RmGH/0ppk/9KaZOjVnmpY////AP///wDSmmQA0ppkEtKaZI7SmmT60ppk/9CWX//OkVb/zpFW/9CWX//SmmT/0ppk/NKaZJDSmmQS0ppkAP///wD///8A0ppkANKaZADSmmQA0ppkKtKaZLrSmmT/0ppk/9KaZP/SmmT/0ppkvNKaZCrSmmQA0ppkANKaZAD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkUtKaZNzSmmTc0ppkVNKaZADSmmQA0ppkANKaZADSmmQA////AP5/AAD4HwAA4AcAAMADAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAMADAADgBwAA+B8AAP5/AAAoAAAAIAAAAEAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAyCRACMgkQA6oJEAOqCRACQgkQAEIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRABigkQA5oJEAP+CRAD/gkQA/4JEAP+CRADqgkQAZoJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAA4gkQAwoJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQAxIJEADyCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAP///wD///8A////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAWgkQAmIJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAJyCRAAYgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAdIJEAPCCRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAPSCRAB4gkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQASoJEANKCRAD/gkQA/4JEAP+CRAD/g0YA/39AAP9zLgD/bSQA/2shAP9rIQD/bSQA/3MuAP9/PwD/g0YA/4JEAP+CRAD/gkQA/4JEAP+CRADUgkQAToJEAACCRAAAgkQAAP///wD///8A////AP///wB+PwAAgkUAIoJEAKiCRAD/gkQA/4JEAP+CRAD/hEcA/4BBAP9sIwD/dTAA/5RfKv+viF7/vp56/76ee/+wiF7/lWAr/3YxAP9sIwD/f0AA/4RHAP+CRAD/gkQA/4JEAP+CRAD/gkQArIJEACaBQwAA////AP///wD///8A////AIBCAEBzNAD6f0EA/4NFAP+CRAD/gkQA/4VIAP92MwD/bSUA/6N1Tv/ezsL/////////////////////////////////38/D/6V3Uv9uJgD/dTEA/4VJAP+CRAD/gkQA/4JEAP+BQwD/fUAA/4FDAEj///8A////AP///wD///8AzJRd5qBlKf91NgD/dDUA/4JEAP+FSQD/cy4A/3YyAP/PuKP//////////////////////////////////////////////////////9K7qP94NQD/ciwA/4VJAP+CRAD/fkEA/35BAP+LSwD/mlYA6v///wD///8A////AP///wDdpnL/4qx3/8KJUv+PUhf/cTMA/3AsAP90LgD/4dK+/////////////////////////////////////////////////////////////////+TYxf91MAD/dTIA/31CAP+GRwD/llQA/6FcAP+gWwD8////AP///wD///8A////ANGZY/LSm2X/4ap3/92mcP+wdT3/byQA/8mwj////////////////////////////////////////////////////////////////////////////+LYxv9zLgP/jUoA/59bAP+hXAD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/RmWL/1p9q/9ubXv/XqXj////////////////////////////7+fD/vZyG/6BxS/+gcUr/vJuE//r37f//////////////////////3MOr/5dQBf+dVQD/nVkA/5xYAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmWP/yohJ//jo2P//////////////////////4NTG/4JDFf9lGAD/bSQA/20kAP9kGAD/fz8S/+Xb0f//////5NG9/6txN/+LOgD/m1QA/51aAP+cWAD/m1cA/5xYAP+cWADy////AP///wD///8A////ANKaZPLSmmT/0ppk/8+TWf/Unmv//v37//////////////////////+TWRr/VwsA/35AAP+ERgD/g0UA/4JGAP9lHgD/kFga/8KXX/+TRwD/jT4A/49CAP+VTQD/n10A/5xYAP+OQQD/lk4A/55cAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/y4tO/92yiP//////////////////////8NnE/8eCQP+rcTT/ez0A/3IyAP98PgD/gEMA/5FSAP+USwD/jj8A/5lUAP+JNwD/yqV2/694Mf+HNQD/jkAA/82rf/+laBj/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/LiUr/4byY///////////////////////gupX/0I5P/+Wuev/Lklz/l1sj/308AP+QSwD/ol0A/59aAP+aVQD/k0oA/8yoh///////+fXv/6pwO//Lp3v///////Pr4f+oay7y////AP///wD///8A////ANKaZPLSmmT/0ppk/8uJSv/hvJj//////////////////////+G7l//Jhkb/0ppk/96nc//fqXX/x4xO/6dkFP+QSQD/llEA/5xXAP+USgD/yaOA///////38uv/qG05/8ijdv//////8efb/6ZpLPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/zIxO/9yxh///////////////////////7dbA/8iEQf/Sm2X/0Zlj/9ScZv/eqHf/2KJv/7yAQf+XTgD/iToA/5lSAP+JNgD/yKFv/611LP+HNQD/jT8A/8qmeP+kZRT/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/Pk1n/1J5q//78+//////////////////+/fv/1aFv/8iEQv/Tm2b/0ppl/9GZY//Wn2z/1pZc/9eldf/Bl2b/kUcA/4w9AP+OQAD/lUwA/59eAP+cWQD/jT8A/5ZOAP+eXADy////AP///wD///8A////ANKaZPLSmmT/0ppk/9KZY//KiEn/8d/P///////////////////////47+f/05tm/8iCP//KiEj/yohJ/8eCP//RmGH//vfy///////n1sP/rXQ7/4k4AP+TTAD/nVoA/5xYAP+cVwD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/0ptl/8uLTf/aq37////////////////////////////+/fz/6c2y/961jv/etY7/6Myx//78+v//////////////////////3MWv/5xXD/+ORAD/mFQA/51ZAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmmT/0ppk/8mFRP/s1b//////////////////////////////////////////////////////////////////////////////+PD/0JFU/7NzMv+WUQD/kUsA/5tXAP+dWQDy////AP///wD///8A////ANKaZP/SmmT/0ppk/9KaZP/Sm2X/z5NZ/8yMT//z5NX/////////////////////////////////////////////////////////////////9Ofa/8yNUP/UmGH/36p5/8yTWv+qaSD/kksA/5ROAPz///8A////AP///wD///8A0ppk5NKaZP/SmmT/0ppk/9KaZP/TnGf/zY9T/82OUv/t1sD//////////////////////////////////////////////////////+7Yw//OkFX/zI5R/9OcZ//SmmP/26V0/9ymdf/BhUf/ol8R6P///wD///8A////AP///wDSmmQ80ppk9tKaZP/SmmT/0ppk/9KaZP/TnGj/zpFW/8qJSv/dson/8uHS//////////////////////////////////Lj0//etIv/y4lL/86QVf/TnGj/0ppk/9KaZP/RmWP/05xn/9ymdfjUnWdC////AP///wD///8A////ANKaZADSmmQc0ppkotKaZP/SmmT/0ppk/9KaZP/Tm2b/0Zli/8qJSf/NjlH/16Z3/+G8mP/myKr/5siq/+G8mP/Xp3f/zY5S/8qISf/RmGH/05tm/9KaZP/SmmT/0ppk/9KaZP/SmmSm0pljINWdaQD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkQtKaZMrSmmT/0ppk/9KaZP/SmmT/0ptl/9GYYf/Nj1P/y4lL/8qISP/KiEj/y4lK/82PU//RmGH/0ptl/9KaZP/SmmT/0ppk/9KaZP/SmmTO0ppkRtKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZGzSmmTu0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmTw0ppkcNKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZBLSmmSQ0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppklNKaZBTSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQy0ppkutKaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppkvtKaZDbSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkXNKaZODSmmT/0ppk/9KaZP/SmmT/0ppk5NKaZGDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkBtKaZIbSmmTo0ppk6tKaZIrSmmQK0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP/8P///+B///+AH//+AAf//AAD//AAAP/AAAA/gAAAHwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA+AAAAfwAAAP/AAAP/8AAP//gAH//+AH///4H////D//" rel="icon" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
</head>
<body>
<div class="wrapper">
<header id="title-block-header">
<h1 class="title" style="text-align:center">Exploring Placeholders</h1>

<table style="border:none;float:right">
  <tr>
    <td>Document #:</td>
    <td>DxxxxR0</td>
  </tr>
  <tr>
    <td>Date:</td>
    <td>2022-06-29</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Project:</td>
    <td>Programming Language C++</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Audience:</td>
    <td>
      EWG<br>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top">Reply-to:</td>
    <td>
      Barry Revzin<br>&lt;<a href="mailto:barry.revzin@gmail.com" class="email">barry.revzin@gmail.com</a>&gt;<br>
    </td>
  </tr>
</table>

</header>
<div style="clear:both">
<div id="TOC" role="doc-toc">
<h1 id="toctitle">Contents</h1>
<ul>
<li><a href="#placeholders-in-pipelines"><span class="toc-section-number">1</span> Placeholders in Pipelines<span></span></a></li>
<li><a href="#placeholder-lambdas"><span class="toc-section-number">2</span> Placeholder Lambdas<span></span></a></li>
<li><a href="#march-of-the-placeholders"><span class="toc-section-number">3</span> March of the Placeholders<span></span></a></li>
<li><a href="#placeholders-in-templates"><span class="toc-section-number">4</span> Placeholders in Templates<span></span></a>
<ul>
<li><a href="#alias-or-constraint"><span class="toc-section-number">4.1</span> Alias or Constraint<span></span></a></li>
<li><a href="#how-many-autos"><span class="toc-section-number">4.2</span> How many <code class="sourceCode cpp"><span class="kw">auto</span></code>s<span></span></a></li>
<li><a href="#concept-template-parameters"><span class="toc-section-number">4.3</span> Concept template parameters<span></span></a></li>
<li><a href="#what-about-non-type-template-parameters"><span class="toc-section-number">4.4</span> What about non-type template parameters?<span></span></a></li>
</ul></li>
<li><a href="#bibliography"><span class="toc-section-number">5</span> References<span></span></a></li>
</ul>
</div>
<h1 data-number="1" style="border-bottom:1px solid #cccccc" id="placeholders-in-pipelines"><span class="header-section-number">1</span> Placeholders in Pipelines<a href="#placeholders-in-pipelines" class="self-link"></a></h1>
<p><span class="citation" data-cites="P2011R0">[<a href="#ref-P2011R0" role="doc-biblioref">P2011R0</a>]</span> proposed a new, non-overloadable binary operator <code class="sourceCode cpp"><span class="op">|&gt;</span></code> such that the expression</p>
<blockquote>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a>x <span class="op">|&gt;</span> f<span class="op">(</span>y<span class="op">)</span></span></code></pre></div>
</blockquote>
<p>was defined to be evaluated as:</p>
<blockquote>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a>f<span class="op">(</span>x, y<span class="op">)</span></span></code></pre></div>
</blockquote>
<p>without any intermediate <code class="sourceCode cpp">f<span class="op">(</span>y<span class="op">)</span></code> expression. The rules of this operator were fairly simple: the right-hand side had to be a call expression, and the left-hand expression was inserted as the first argument into the right-hand call.</p>
<p><span class="citation" data-cites="P2011R1">[<a href="#ref-P2011R1" role="doc-biblioref">P2011R1</a>]</span> introduced the possibility of a different variant of this idea, where instead of unconditionally inserting the left-hand expression as the first argument of the right-hand call expression, the user would specify <em>where</em> it was inserted into with a placeholder. For the purposes of this paper, I will use <code class="sourceCode cpp"><span class="er">$</span></code> as the placeholder. As such</p>
<blockquote>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a>x <span class="op">|&gt;</span> f<span class="op">(</span><span class="er">$</span>, y<span class="op">)</span></span></code></pre></div>
</blockquote>
<p>was defined to be evaluated as:</p>
<blockquote>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a>f<span class="op">(</span>x, y<span class="op">)</span></span></code></pre></div>
</blockquote>
<p>while also allowing</p>
<blockquote>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a>x <span class="op">|&gt;</span> f<span class="op">(</span>y, <span class="er">$</span><span class="op">)</span></span></code></pre></div>
</blockquote>
<p>to be evaluated as</p>
<blockquote>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a>f<span class="op">(</span>y, x<span class="op">)</span></span></code></pre></div>
</blockquote>
<p>In a telecon <span class="citation" data-cites="pipeline-minutes">[<a href="#ref-pipeline-minutes" role="doc-biblioref">pipeline-minutes</a>]</span>, EWG indicated preference for exploring the user of placeholders in pipelining:</p>
<blockquote>
<p>We’re generally interested in some pipeline operator, assuming my preferred placeholder syntax and precedence is chosen.</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>SF</strong>
</div></th>
<th><div style="text-align:center">
<strong>F</strong>
</div></th>
<th><div style="text-align:center">
<strong>N</strong>
</div></th>
<th><div style="text-align:center">
<strong>A</strong>
</div></th>
<th><div style="text-align:center">
<strong>SA</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>11</td>
<td>8</td>
<td>3</td>
<td>2</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Pipeline operator should have a placeholder, with design to be determined.</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>SF</strong>
</div></th>
<th><div style="text-align:center">
<strong>F</strong>
</div></th>
<th><div style="text-align:center">
<strong>N</strong>
</div></th>
<th><div style="text-align:center">
<strong>A</strong>
</div></th>
<th><div style="text-align:center">
<strong>SA</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>6</td>
<td>12</td>
<td>4</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Pipeline operator should not have a placeholder.</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>SF</strong>
</div></th>
<th><div style="text-align:center">
<strong>F</strong>
</div></th>
<th><div style="text-align:center">
<strong>N</strong>
</div></th>
<th><div style="text-align:center">
<strong>A</strong>
</div></th>
<th><div style="text-align:center">
<strong>SA</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>3</td>
<td>10</td>
<td>6</td>
<td>2</td>
</tr>
</tbody>
</table>
</blockquote>
<p>The advantage of placeholders in pipelines is significantly added flexibility: you can express any operation that you want to express, regardless of the order of parameters that the function takes. There are numerous examples in the standard library where the most likely candidate for the expression to put on the left-hand side of a pipe expression is not actually the first parameter of the function:</p>
<ul>
<li>In Ranges, <code class="sourceCode cpp">r1 <span class="op">|&gt;</span> zip_transform<span class="op">(</span>f, <span class="er">$</span>, r2<span class="op">)</span></code>. The function is the first parameter, but range pipelines are going to be built up of ranges.</li>
<li>Similarly, <code class="sourceCode cpp">some_tuple <span class="op">|&gt;</span> apply<span class="op">(</span>f, <span class="er">$</span><span class="op">)</span></code> and <code class="sourceCode cpp">some_variant <span class="op">|&gt;</span> visit<span class="op">(</span>f, <span class="er">$</span><span class="op">)</span></code> fall into the same boat: the function is the first parameter, but the “subject” of the operation is what you want to put on the left.</li>
</ul>
<p>Moreover, pipelines with placeholders are even more flexible than that: there is no reason to limit the right-hand side to a call expression. For instance, the expression <code class="sourceCode cpp"><span class="op">(</span><span class="kw">co_await</span> GetString<span class="op">(</span>i<span class="op">)).</span>size<span class="op">()</span></code> (from <span class="citation" data-cites="P0973R0">[<a href="#ref-P0973R0" role="doc-biblioref">P0973R0</a>]</span>) has awkward parenthesization based on operator precedence. This could instead be rewritten as <code class="sourceCode cpp">GetString<span class="op">(</span>i<span class="op">)</span> <span class="op">|&gt;</span> <span class="kw">co_await</span> <span class="er">$</span> <span class="op">|&gt;</span> <span class="er">$</span><span class="op">.</span>size<span class="op">()</span></code>. That is: pipelines with placeholders can effectively introduce postfix <code class="sourceCode cpp"><span class="kw">co_await</span></code> or <code class="sourceCode cpp"><span class="kw">co_yield</span></code>. They became a mechanism for controlling operator precedence.</p>
<p>Obviously there are questions about pipeline placeholders that need to be answered, such as where and how the placeholder needs to appear. Can it appear in an unevaluated operand? In the body of a lambda? More than once?</p>
<p>Put in a pin in those questions for now, and let’s just carefully consider the expression:</p>
<blockquote>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a>std<span class="op">::</span>tuple<span class="op">(</span><span class="dv">1</span>, <span class="dv">2</span><span class="op">)</span> <span class="op">|&gt;</span> std<span class="op">::</span>apply<span class="op">(</span>std<span class="op">::</span>plus<span class="op">()</span>, <span class="er">$</span><span class="op">)</span></span></code></pre></div>
</blockquote>
<p>In particular, what role does the <code class="sourceCode cpp">std<span class="op">::</span>apply<span class="op">(</span>std<span class="op">::</span>plus<span class="op">()</span>, <span class="er">$</span><span class="op">)</span></code> part serve? I don’t want to call it a sub-expression since it’s not technically a distinct operand here. But conceptually, it at least kind of is. And as such the role that it serves here is quite similar to:</p>
<blockquote>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a>std<span class="op">::</span>bind<span class="op">(</span>std<span class="op">::</span>apply, std<span class="op">::</span>plus<span class="op">()</span>, _1<span class="op">)(</span>std<span class="op">::</span>tuple<span class="op">(</span><span class="dv">1</span>, <span class="dv">2</span><span class="op">))</span></span></code></pre></div>
</blockquote>
<p>With two very notable differences:</p>
<ul>
<li>The <code class="sourceCode cpp">bind</code> expression is limited to solely functions, which the placeholder pipeline is not (as illustrated earlier). But more than that, the <code class="sourceCode cpp">bind</code> expression is limited to the kinds of functions we can pass as parameters, which <code class="sourceCode cpp">std<span class="op">::</span>apply</code> (being a function template) is not.</li>
<li>The <code class="sourceCode cpp">bind</code> expression has to capture any additional arguments (the bound arguments) because, as a library facility, it is not knowable when those arguments will actually be used. In this case, capturing <code class="sourceCode cpp">std<span class="op">::</span>plus<span class="op">()</span></code> is basically free as it’s an empty type anyway. But that could be real cycles that need to be spent. With the placeholder expression, we don’t need to capture anything, since we know we’re immediately evaluating the expression.</li>
</ul>
<p>That said, the not-quite-expression <code class="sourceCode cpp">std<span class="op">::</span>apply<span class="op">(</span>std<span class="op">::</span>plus<span class="op">()</span>, <span class="er">$</span><span class="op">)</span></code> is conceptually a lot like a unary function. So what if we keep exploring that route.</p>
<h1 data-number="2" style="border-bottom:1px solid #cccccc" id="placeholder-lambdas"><span class="header-section-number">2</span> Placeholder Lambdas<a href="#placeholder-lambdas" class="self-link"></a></h1>
<p>There are basically three approaches that languages take to lambdas (some languages do more than one of these).</p>
<ol type="1">
<li>Direct language support for partial application</li>
<li>Placeholder expressions</li>
<li>Abbreviated function declarations</li>
</ol>
<p>I’ll illustrate what I mean here by using a simple example: how do you write a lambda that is a unary predicate which checks if its parameter is a negative integer?</p>
<p>For the languages that support partial application, that looks like:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Expression</strong>
</div></th>
<th><div style="text-align:center">
<strong>Language</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="op">(&lt;</span><span class="dv">0</span><span class="op">)</span></code></td>
<td>Haskell</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp"><span class="op">(&lt;)</span> <span class="dv">0</span></code></td>
<td>F#</td>
</tr>
</tbody>
</table>
<p>For the languages that provide abbreviated function declarations, we basically have a section that introduces names followed by a body that uses those names:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Expression</strong>
</div></th>
<th><div style="text-align:center">
<strong>Language</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="op">|</span>e<span class="op">|</span> e <span class="op">&lt;</span> <span class="dv">0</span></code></td>
<td>Rust</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">e <span class="op">-&gt;</span> e <span class="op">&lt;</span> <span class="dv">0</span></code></td>
<td>Java</td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp">e <span class="op">=&gt;</span> e <span class="op">&lt;</span> <span class="dv">0</span></code></td>
<td>C#, JavaScript, Scala</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">\e <span class="op">-&gt;</span> e <span class="op">&lt;</span> <span class="dv">0</span></code></td>
<td>Haskell</td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="op">{</span> <span class="op">|</span>e<span class="op">|</span> e <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">}</span></code></td>
<td>Ruby</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp"><span class="op">{</span> e in e <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">}</span></code></td>
<td>Swift</td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="op">{</span> e <span class="op">-&gt;</span> e <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">}</span></code></td>
<td>Kotlin</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">fun e <span class="op">-&gt;</span> e <span class="op">&lt;</span> <span class="dv">0</span></code></td>
<td>F#, OCaml</td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp">lambda e<span class="op">:</span> e <span class="op">&lt;</span> <span class="dv">0</span></code></td>
<td>Python</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">fn e <span class="op">-&gt;</span> e <span class="op">&lt;</span> <span class="dv">0</span> end</code></td>
<td>Elixir</td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="op">[](</span><span class="dt">int</span> e<span class="op">){</span> <span class="cf">return</span> e <span class="op">&lt;</span> <span class="dv">0</span>; <span class="op">}</span></code></td>
<td>C++</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">func<span class="op">(</span>e <span class="dt">int</span><span class="op">)</span> <span class="dt">bool</span> <span class="op">{</span> <span class="cf">return</span> e <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">}</span></code></td>
<td>Go</td>
</tr>
</tbody>
</table>
<p>On the plus side, C++ is not the longest.</p>
<p>But the interesting case I wanted to discuss here is those languages that support placeholder expressions:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Expression</strong>
</div></th>
<th><div style="text-align:center">
<strong>Language</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="sourceCode cpp">_ <span class="op">&lt;</span> <span class="dv">0</span></code></td>
<td>Scala</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">_1 <span class="op">&lt;</span> <span class="dv">0</span></code></td>
<td>Boost.Lambda (and other Boost libraries)</td>
</tr>
<tr class="odd">
<td><code class="x">#(&lt; % 0)</code></td>
<td>Clojure</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp"><span class="op">&amp;(&amp;</span><span class="dv">1</span> <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span></code></td>
<td>Elixir</td>
</tr>
<tr class="odd">
<td><code class="x">{ $0 &lt; 0 }</code></td>
<td>Swift</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp"><span class="op">{</span> it <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">}</span></code></td>
<td>Kotlin</td>
</tr>
</tbody>
</table>
<p>There’s a lot of variety in these placeholder lambdas. Some languages number their parameters and let you write whatever you want (Swift starts numbering at <code class="sourceCode cpp"><span class="dv">0</span></code>, Elixir at <code class="sourceCode cpp"><span class="dv">1</span></code>, Clojure also at <code class="sourceCode cpp"><span class="dv">1</span></code> but also provides <code class="sourceCode cpp"><span class="op">%</span></code> as a shorthand), Kotlin only provides the special variable <code class="sourceCode cpp">it</code> to be the first parameter.</p>
<p>Scala is unique in that it only provides <code class="sourceCode cpp">_</code>, but that placeholder refers to a different parameter on each use. So <code class="sourceCode cpp">_ <span class="op">&gt;</span> _</code> is a binary predicate that checks if the first parameter is greater than the second.</p>
<p>Now, for this particular example, we also have library solutions available to us, and have for quite some time. There are several libraries <em>just in Boost</em> that allow for either <code class="sourceCode cpp">_1 <span class="op">&lt;</span> <span class="dv">0</span></code> or <code class="sourceCode cpp">_ <span class="op">&lt;</span> <span class="dv">0</span></code> to mean the same thing as illustrated above (Boost.HOF’s <code class="sourceCode cpp">_</code> behaves similar to Scala - at least to the extent that is possible in a library). Having placeholder lambdas is quite popular precisely because there’s no noise; when writing a simple expression, having to deal with the ceremony of introducing names and dealing with the return type is excessive. For instance, to implement <span class="citation" data-cites="P2321R1">[<a href="#ref-P2321R1" role="doc-biblioref">P2321R1</a>]</span>’s <code class="sourceCode cpp">zip</code>, you need to dereference all the iterators in a tuple:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Regular Lambda</strong>
</div></th>
<th><div style="text-align:center">
<strong>Placeholder Lambda</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a>tuple_transform<span class="op">([](</span><span class="kw">auto</span><span class="op">&amp;</span> it<span class="op">)</span> <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span><span class="kw">auto</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>    <span class="cf">return</span> <span class="op">*</span>it;</span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="op">}</span>, current_<span class="op">)</span></span></code></pre></div></td>
<td><div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a>tuple_transform<span class="op">(*</span>_, current_<span class="op">)</span></span></code></pre></div></td>
</tr>
</tbody>
</table>
<p>The C++ library solutions are fundamentally limited to operators though. You can make <code class="sourceCode cpp">_1 <span class="op">==</span> <span class="dv">0</span></code> work, but you can’t really make <code class="sourceCode cpp">_1<span class="op">.</span>id<span class="op">()</span> <span class="op">==</span> <span class="dv">0</span></code> or <code class="sourceCode cpp">f<span class="op">(</span>_1<span class="op">)</span></code> work. As a language feature, having member functions work is trivial. But having non-member functions work is… not.</p>
<p>In the table of languages that support placeholder lambdas, four of them have <em>bounded</em> expressions: there is punctuation to mark where the lambda expression begins and ends. This is due to a fundamental ambiguity: what does <code class="sourceCode cpp">f<span class="op">(</span><span class="er">$</span><span class="op">)</span></code> mean? It could either mean invoking <code class="sourceCode cpp">f</code> with a unary lambda that returns its argument (i.e. <code class="sourceCode cpp">f<span class="op">(</span>e <span class="op">=&gt;</span> e<span class="op">)</span></code>) or it could mean a unary lambda that invokes <code class="sourceCode cpp">f</code> on its argument (i.e. <code class="sourceCode cpp">e <span class="op">=&gt;</span> f<span class="op">(</span>e<span class="op">)</span></code>). How do you know which one is which?</p>
<p>Scala, which does not have bounded placeholder expressions, takes an interesting direction here:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Expression</strong>
</div></th>
<th><div style="text-align:center">
<strong>Meaning</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="sourceCode cpp">f<span class="op">(</span>_<span class="op">)</span></code></td>
<td><code class="sourceCode cpp">e <span class="op">=&gt;</span> f<span class="op">(</span>e<span class="op">)</span></code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">f<span class="op">(</span>_, x<span class="op">)</span></code></td>
<td><code class="sourceCode cpp">e <span class="op">=&gt;</span> f<span class="op">(</span>e, x<span class="op">)</span></code></td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp">f<span class="op">(</span>_ <span class="op">+</span> <span class="dv">2</span><span class="op">)</span></code></td>
<td><code class="sourceCode cpp">e <span class="op">=&gt;</span> f<span class="op">(</span>e <span class="op">+</span> <span class="dv">2</span><span class="op">)</span></code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">f<span class="op">(</span><span class="dv">1</span>, <span class="dv">2</span>, g<span class="op">(</span>_<span class="op">))</span></code></td>
<td><code class="sourceCode cpp">f<span class="op">(</span><span class="dv">1</span>, <span class="dv">2</span>, e <span class="op">=&gt;</span> g<span class="op">(</span>e<span class="op">))</span></code></td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp">f<span class="op">(</span><span class="dv">1</span>, _<span class="op">)</span></code></td>
<td><code class="sourceCode cpp">e <span class="op">=&gt;</span> f<span class="op">(</span><span class="dv">1</span>, e<span class="op">)</span></code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">f<span class="op">(</span><span class="dv">1</span>, _ <span class="op">+</span> <span class="dv">1</span><span class="op">)</span></code></td>
<td><code class="sourceCode cpp">f<span class="op">(</span><span class="dv">1</span>, e <span class="op">=&gt;</span> e <span class="op">+</span> <span class="dv">1</span><span class="op">)</span></code></td>
</tr>
</tbody>
</table>
<p>I’m pretty sure we wouldn’t want to go that route in C++, where we come up with some rule for what constitutes the bounded expression around the placeholder.</p>
<p>But also more to the point, when the placeholder expression refers to (odr-uses) a variable, we need to capture it, and we need to know <em>how</em> to capture it.</p>
<p>So a C++ approach to placeholder lambdas might be: a <em>lambda-introducer</em>, followed by some token to distinguish it from a regular lambda (e.g. <code class="sourceCode cpp"><span class="op">:</span></code> or <code class="sourceCode cpp"><span class="op">=&gt;</span></code>), followed by a placeholder expression. That is, the placeholder lambda for the negative example might be <code class="sourceCode cpp"><span class="op">[]:</span> <span class="er">$</span><span class="dv">1</span> <span class="op">&lt;</span> <span class="dv">0</span></code> or just <code class="sourceCode cpp"><span class="op">[]:</span> <span class="er">$</span> <span class="op">&lt;</span> <span class="dv">0</span></code>. At 9 characters, this is substantially shorter than the C++ lambda we have to write today (26 characters), and this is about as short as a C++ lambda gets (the dereference example would be 7 characters as compared to 46). And while it’s longer than the various library approaches (Boost.HOF’s <code class="sourceCode cpp">_ <span class="op">&lt;</span> <span class="dv">0</span></code> is just 5), it would have the flexibility to do anything. Probably good enough.</p>
<p>For more on the topic of placeholder lambdas in C++, consider <code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;</span></code>’s blog posts “Now I Am Become Perl” <span class="citation" data-cites="vector-bool">[<a href="#ref-vector-bool" role="doc-biblioref">vector-bool</a>]</span> and his macro-based solution to the problem <span class="citation" data-cites="vector-bool-macro">[<a href="#ref-vector-bool-macro" role="doc-biblioref">vector-bool-macro</a>]</span>.</p>
<p>Getting back to the topic at hand, we had:</p>
<blockquote>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a>std<span class="op">::</span>tuple<span class="op">(</span><span class="dv">1</span>, <span class="dv">2</span><span class="op">)</span> <span class="op">|&gt;</span> std<span class="op">::</span>apply<span class="op">(</span>std<span class="op">::</span>plus<span class="op">()</span>, <span class="er">$</span><span class="op">)</span></span></code></pre></div>
</blockquote>
<p>And now I’m saying that perhaps:</p>
<blockquote>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">auto</span> apply_plus <span class="op">=</span> <span class="op">[]:</span> std<span class="op">::</span>apply<span class="op">(</span>std<span class="op">::</span>plus<span class="op">()</span>, <span class="er">$</span><span class="op">)</span>;</span></code></pre></div>
</blockquote>
<p>Could the lambda that does that.</p>
<p>Which actually suggests that the model for pipelines in placeholders might be that <code class="sourceCode cpp">x <span class="op">|&gt;</span> f</code> simply evaluates as <code class="sourceCode cpp">f<span class="op">(</span>x<span class="op">)</span></code>, except that we allow <code class="sourceCode cpp">f</code> to be a <em>placeholder-expression</em> which is allowed to omit the capture introducer (since we know we are not capturing in this context and we have the <code class="sourceCode cpp"><span class="op">|&gt;</span></code>s as our bounds to avoid ambiguity).</p>
<p>This is a pretty cool model (and is in fact how F# defines its <code class="sourceCode cpp"><span class="op">|&gt;</span></code>, it’s merely inverted function application) in that it’s pretty easy to understand while also giving us placeholder lambdas as a drive-by language feature.</p>
<p>Except…</p>
<h1 data-number="3" style="border-bottom:1px solid #cccccc" id="march-of-the-placeholders"><span class="header-section-number">3</span> March of the Placeholders<a href="#march-of-the-placeholders" class="self-link"></a></h1>
<p>One of the library features that the Ranges library provides is the ability to do partial function composition, as a library feature. Let’s say, for instance, that we want to send some swag to all of our employees named Tim. We could find their locations like so:</p>
<blockquote>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1"></a>employees</span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="op">|</span> views<span class="op">::</span>filter<span class="op">([](</span><span class="kw">auto</span><span class="op">&amp;&amp;</span> e<span class="op">){</span> <span class="cf">return</span> e<span class="op">.</span>name<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;Tim&quot;</span>; <span class="op">})</span></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="op">|</span> views<span class="op">::</span>transform<span class="op">([](</span><span class="kw">auto</span><span class="op">&amp;&amp;</span> e<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> e<span class="op">.</span>address<span class="op">()</span>; <span class="op">})</span></span></code></pre></div>
</blockquote>
<p>But maybe we actually frequently need to locate the Tims. So we can produce a new range adaptor closure object to hold onto and use for future compositions like so:</p>
<blockquote>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">auto</span> tim_locations <span class="op">=</span></span>
<span id="cb14-2"><a href="#cb14-2"></a>    views<span class="op">::</span>filter<span class="op">([](</span><span class="kw">auto</span><span class="op">&amp;&amp;</span> e<span class="op">){</span> <span class="cf">return</span> e<span class="op">.</span>name<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;Tim&quot;</span>; <span class="op">})</span></span>
<span id="cb14-3"><a href="#cb14-3"></a>    <span class="op">|</span> views<span class="op">::</span>transform<span class="op">([](</span><span class="kw">auto</span><span class="op">&amp;&amp;</span> e<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> e<span class="op">.</span>address<span class="op">()</span>; <span class="op">})</span></span>
<span id="cb14-4"><a href="#cb14-4"></a>employees <span class="op">|</span> tim_locations</span></code></pre></div>
</blockquote>
<p>Part of the goal of <code class="sourceCode cpp"><span class="op">|&gt;</span></code> as a language feature is to obviate the need for any library <code class="sourceCode cpp"><span class="op">|</span></code> machinery. So the question is, how do we do this partial function with <code class="sourceCode cpp"><span class="op">|&gt;</span></code>? Let’s start with just getting all the Tims. We start out by writing:</p>
<blockquote>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">auto</span> tims <span class="op">=</span> <span class="op">[](</span><span class="kw">auto</span><span class="op">&amp;&amp;</span> r<span class="op">){</span></span>
<span id="cb15-2"><a href="#cb15-2"></a>    <span class="cf">return</span> r <span class="op">|&gt;</span> views<span class="op">::</span>filter<span class="op">(</span><span class="er">$</span>, <span class="op">[](</span><span class="kw">auto</span><span class="op">&amp;&amp;</span> e<span class="op">){</span> <span class="cf">return</span> e<span class="op">.</span>name<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;Tim&quot;</span>; <span class="op">})</span>;</span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="op">}</span>;</span></code></pre></div>
</blockquote>
<p>But this is (a) much longer than the existing <code class="sourceCode cpp">views<span class="op">::</span>filter<span class="op">(</span><span class="co">/* that lambda */</span><span class="op">)</span></code> while also (b) not being SFINAE-friendly. So that’s a no-go. But maybe we need to combine it with the placeholder lambdas, to make both parts of this much shorter:</p>
<blockquote>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">auto</span> tims <span class="op">=</span> <span class="op">[]:</span> <span class="er">$</span><sub>a</sub> <span class="op">|&gt;</span> views<span class="op">::</span>filter<span class="op">(</span><span class="er">$</span><sub>b</sub>, <span class="op">[]:</span> <span class="er">$</span><sub>c</sub><span class="op">.</span>name<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;Tim&quot;</span><span class="op">)</span>;</span></code></pre></div>
</blockquote>
<p>Alright, what’s going on here? We have three uses of <code class="sourceCode cpp"><span class="er">$</span></code> here, that actually refer to three different things. I took the liberty of adding subscripts to them to be able to describe what they mean a little better:</p>
<ul>
<li><code class="sourceCode cpp"><span class="er">$</span><sub>a</sub></code>: this is the parameter to the lambda that we’re declaring. This will be some kind of <code class="sourceCode cpp">viewable_range</code>, the input to our <code class="sourceCode cpp">filter</code>.</li>
<li><code class="sourceCode cpp"><span class="er">$</span><sub>b</sub></code>: this refers to the left-hand side of the <code class="sourceCode cpp"><span class="op">|&gt;</span></code> expression, it’s a placeholder for the pipeline rather than the lambda</li>
<li><code class="sourceCode cpp"><span class="er">$</span><sub>c</sub></code>: this is the parameter of the predicate being passed to <code class="sourceCode cpp">filter</code></li>
</ul>
<p>Now, <code class="sourceCode cpp"><span class="er">$</span><sub>a</sub></code> and <code class="sourceCode cpp"><span class="er">$</span><sub>b</sub></code> actually refer to the same expression here (literally: <code class="sourceCode cpp"><span class="er">$</span><sub>b</sub></code> simply refers to <code class="sourceCode cpp"><span class="er">$</span><sub>a</sub></code>), so this could be reduced to:</p>
<blockquote>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">auto</span> tims <span class="op">=</span> <span class="op">[]:</span> views<span class="op">::</span>filter<span class="op">(</span><span class="er">$</span><sub>ab</sub>, <span class="op">[]:</span> <span class="er">$</span><sub>c</sub><span class="op">.</span>name<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;Tim&quot;</span><span class="op">)</span>;</span></code></pre></div>
</blockquote>
<p>But if we then add the <code class="sourceCode cpp">transform</code> on top of these to find the locations of all of our Tims, that would end up being:</p>
<blockquote>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">auto</span> tims_locations <span class="op">=</span> <span class="op">[]:</span> views<span class="op">::</span>filter<span class="op">(</span><span class="er">$</span><sub>ab</sub>, <span class="op">[]:</span> <span class="er">$</span><sub>c</sub><span class="op">.</span>name<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;Tim&quot;</span><span class="op">)</span> <span class="op">|&gt;</span> views<span class="op">::</span>transform<span class="op">(</span><span class="er">$</span><sub>d</sub>, <span class="op">[]:</span> <span class="er">$</span><sub>e</sub><span class="op">.</span>address<span class="op">())</span>;</span></code></pre></div>
</blockquote>
<p>Where, to add clarity:</p>
<ul>
<li><code class="sourceCode cpp"><span class="er">$</span><sub>d</sub></code>: this refers to the left-hand side of the <code class="sourceCode cpp"><span class="op">|&gt;</span></code> expression, which is the <code class="sourceCode cpp">filter</code> view expression</li>
<li><code class="sourceCode cpp"><span class="er">$</span><sub>e</sub></code>: this is the parameter of the unary projection that we’re passing into transform</li>
</ul>
<p>Now, this is certainly shorter than what we started with and, importantly, avoids quite a bit of library machinery. Doing this entirely in the language doesn’t just lead to terser code, it will almost certainly lead to better compile times and certainly lead to improved diagnostics on incorrect usages.</p>
<p>As described in the original pipeline paper, this also easily extends to arbitrary algorithms without any additional library work:</p>
<blockquote>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1"></a><span class="kw">auto</span> tims_salaries <span class="op">=</span> <span class="op">[]:</span> views<span class="op">::</span>filter<span class="op">(</span><span class="er">$</span>, <span class="op">[]:</span> <span class="er">$</span><span class="op">.</span>name<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;Tim&quot;</span><span class="op">)</span></span>
<span id="cb19-2"><a href="#cb19-2"></a>                      <span class="op">|&gt;</span> ranges<span class="op">::</span>fold_left<span class="op">(</span><span class="er">$</span>, <span class="fl">0.0</span>, std<span class="op">::</span>plus<span class="op">()</span>, <span class="op">[]:</span> <span class="er">$</span><span class="op">.</span>salary<span class="op">())</span></span></code></pre></div>
</blockquote>
<p>Now, if we adopted placeholder lambdas along the lines presented here, but instead kept the non-placeholder pipelines, the above would look like:</p>
<blockquote>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1"></a><span class="kw">auto</span> tims_locations <span class="op">=</span> <span class="op">[]:</span> <span class="er">$</span><sub>a</sub> <span class="op">|&gt;</span> views<span class="op">::</span>filter<span class="op">([]:</span> <span class="er">$</span><sub>c</sub><span class="op">.</span>name<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;Tim&quot;</span><span class="op">)</span> <span class="op">|&gt;</span> views<span class="op">::</span>transform<span class="op">([]:</span> <span class="er">$</span><sub>e</sub><span class="op">.</span>address<span class="op">())</span>;</span></code></pre></div>
</blockquote>
<p>Because in this world, placeholders <em>only</em> appear in placeholder-lambdas (as opposed to also appearing in pipelines), it’s <em>may</em> be possible to potentially reduce the above further to (since we have no capture and are using no non-member functions, so the bounds are clear):</p>
<blockquote>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">auto</span> tims_locations <span class="op">=</span> <span class="er">$</span><sub>a</sub> <span class="op">|&gt;</span> views<span class="op">::</span>filter<span class="op">(</span><span class="er">$</span><sub>c</sub><span class="op">.</span>name<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;Tim&quot;</span><span class="op">)</span> <span class="op">|&gt;</span> views<span class="op">::</span>transform<span class="op">(</span><span class="er">$</span><sub>e</sub><span class="op">.</span>address<span class="op">())</span>;</span></code></pre></div>
</blockquote>
<p>The introducer would be impossible to take away if <code class="sourceCode cpp"><span class="op">|&gt;</span></code> took a placeholder, since given the code <code class="sourceCode cpp">e <span class="op">|&gt;</span> views<span class="op">::</span>transform<span class="op">(</span><span class="er">$</span>, <span class="er">$</span><span class="op">.</span>address<span class="op">())</span></code>, how do you know that <code class="sourceCode cpp"><span class="er">$</span><span class="op">.</span>address<span class="op">()</span></code> is intended to be a placeholder-lambda by itself, rather than intending to evaluate as <code class="sourceCode cpp">views<span class="op">::</span>transform<span class="op">(</span>e, e<span class="op">.</span>address<span class="op">())</span></code> (which is obviously nonsense in this particular example, but could be a perfectly reasonable expression in a different context).</p>
<p>So the takeaway here is… this is <em>quite</em> messy. A pipeline operator with a placeholder is very flexible, and naturally lends itself to being defined in terms of a placeholder lambda. And placeholder lambdas themselves are very useful (the numerous libraries in existence which allow them is testament to that).</p>
<p>But somehow, combining a placeholder pipeline with a placeholder lambda leads to code that might be quite a bit worse than if we had the pipeline with no placeholder (as originally proposed) but still adopted placeholder lambdas. Placeholder lambdas also allow us to claw back some of value of placeholder pipelines in function calls, albeit with a much more awkward syntax:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Placeholder Pipeline</strong>
</div></th>
<th><div style="text-align:center">
<strong>Placeholder Lambda</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1"></a>x <span class="op">|&gt;</span> zip<span class="op">(</span><span class="er">$</span>, y<span class="op">)</span></span></code></pre></div></td>
<td><div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1"></a>x <span class="op">|&gt;</span> zip<span class="op">(</span>y<span class="op">)</span></span></code></pre></div></td>
</tr>
<tr class="even">
<td><div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1"></a>x <span class="op">|&gt;</span> zip<span class="op">(</span>y, <span class="er">$</span><span class="op">)</span></span></code></pre></div></td>
<td><div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1"></a><span class="co">// As-is, this has to capture y, but it may</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="co">// make sense to special-case placeholder-lambdas</span></span>
<span id="cb25-3"><a href="#cb25-3"></a><span class="co">// in pipeline-expressions to avoid having to</span></span>
<span id="cb25-4"><a href="#cb25-4"></a><span class="co">// capture because they&#39;re immediately-evaluated</span></span>
<span id="cb25-5"><a href="#cb25-5"></a>x <span class="op">|&gt;</span> <span class="op">([</span>y<span class="op">]:</span> zip<span class="op">(</span>y, <span class="er">$</span><span class="op">))()</span></span>
<span id="cb25-6"><a href="#cb25-6"></a></span>
<span id="cb25-7"><a href="#cb25-7"></a><span class="co">// ... as in just (but the parentheses are still necessary):</span></span>
<span id="cb25-8"><a href="#cb25-8"></a>x <span class="op">|&gt;</span> <span class="op">(</span>zip<span class="op">(</span>y, <span class="er">$</span><span class="op">))()</span></span></code></pre></div></td>
</tr>
<tr class="odd">
<td><div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1"></a>employees <span class="op">|&gt;</span> filter<span class="op">(</span><span class="er">$</span>, <span class="op">[](</span><span class="kw">auto</span><span class="op">&amp;&amp;</span> e<span class="op">){</span></span>
<span id="cb26-2"><a href="#cb26-2"></a>                           <span class="cf">return</span> e<span class="op">.</span>name<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;Tim&quot;</span>;</span>
<span id="cb26-3"><a href="#cb26-3"></a>                       <span class="op">})</span></span>
<span id="cb26-4"><a href="#cb26-4"></a></span>
<span id="cb26-5"><a href="#cb26-5"></a><span class="co">// unclear if this is viable</span></span>
<span id="cb26-6"><a href="#cb26-6"></a>employees <span class="op">|&gt;</span> filter<span class="op">(</span><span class="er">$</span>, <span class="op">[]:</span> <span class="er">$</span><span class="op">.</span>name<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;Tim&quot;</span><span class="op">)</span></span></code></pre></div></td>
<td><div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1"></a>employees <span class="op">|&gt;</span> filter<span class="op">([]:</span> <span class="er">$</span><span class="op">.</span>name<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;Tim&quot;</span><span class="op">)</span></span>
<span id="cb27-2"><a href="#cb27-2"></a></span>
<span id="cb27-3"><a href="#cb27-3"></a></span>
<span id="cb27-4"><a href="#cb27-4"></a></span>
<span id="cb27-5"><a href="#cb27-5"></a><span class="co">// unclear if this is viable</span></span>
<span id="cb27-6"><a href="#cb27-6"></a>employees <span class="op">|&gt;</span> filter<span class="op">(</span><span class="er">$</span><span class="op">.</span>name<span class="op">()</span> <span class="op">==</span> <span class="st">&quot;Tim&quot;</span><span class="op">)</span></span></code></pre></div></td>
</tr>
<tr class="even">
<td><div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1"></a>std<span class="op">::</span>tuple<span class="op">(</span><span class="dv">1</span>, <span class="dv">2</span><span class="op">)</span> <span class="op">|&gt;</span> std<span class="op">::</span>apply<span class="op">(</span>std<span class="op">::</span>plus<span class="op">()</span>, <span class="er">$</span><span class="op">)</span></span></code></pre></div></td>
<td><div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1"></a>std<span class="op">::</span>tuple<span class="op">(</span><span class="dv">1</span>, <span class="dv">2</span><span class="op">)</span> <span class="op">|&gt;</span> <span class="op">(</span>std<span class="op">::</span>apply<span class="op">(</span>std<span class="op">::</span>plus<span class="op">()</span>, <span class="er">$</span><span class="op">))()</span></span></code></pre></div></td>
</tr>
<tr class="odd">
<td><div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1"></a>GetString<span class="op">(</span>i<span class="op">)</span> <span class="op">|&gt;</span> <span class="kw">co_await</span> <span class="er">$</span> <span class="op">|&gt;</span> <span class="er">$</span><span class="op">.</span>size<span class="op">()</span></span></code></pre></div></td>
<td><div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1"></a><span class="co">// there&#39;s no |&gt; way to do this without placeholders</span></span>
<span id="cb31-2"><a href="#cb31-2"></a><span class="op">(</span><span class="kw">co_await</span> GetString<span class="op">(</span>i<span class="op">)).</span>size<span class="op">()</span></span></code></pre></div></td>
</tr>
<tr class="even">
<td><div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1"></a><span class="dt">FILE</span><span class="op">*</span> file <span class="op">=</span> fopen<span class="op">(</span><span class="st">&quot;a.txt&quot;</span>, <span class="st">&quot;wb&quot;</span><span class="op">)</span>;</span>
<span id="cb32-2"><a href="#cb32-2"></a><span class="cf">if</span> <span class="op">(</span>file<span class="op">)</span> <span class="op">{</span></span>
<span id="cb32-3"><a href="#cb32-3"></a>    file <span class="op">|&gt;</span> fputs<span class="op">(</span><span class="st">&quot;Hello world&quot;</span>, <span class="er">$</span><span class="op">)</span>;</span>
<span id="cb32-4"><a href="#cb32-4"></a>    file <span class="op">|&gt;</span> fseek<span class="op">(</span><span class="er">$</span>, <span class="dv">9</span>, SEEK_SET<span class="op">)</span>;</span>
<span id="cb32-5"><a href="#cb32-5"></a>    file <span class="op">|&gt;</span> fclose<span class="op">(</span><span class="er">$</span><span class="op">)</span>;</span>
<span id="cb32-6"><a href="#cb32-6"></a><span class="op">}</span></span></code></pre></div></td>
<td><div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1"></a><span class="dt">FILE</span><span class="op">*</span> file <span class="op">=</span> fopen<span class="op">(</span><span class="st">&quot;a.txt&quot;</span>, <span class="st">&quot;wb&quot;</span><span class="op">)</span>;</span>
<span id="cb33-2"><a href="#cb33-2"></a><span class="cf">if</span> <span class="op">(</span>file<span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-3"><a href="#cb33-3"></a>    file <span class="op">|&gt;</span> <span class="op">(</span>fputs<span class="op">(</span><span class="st">&quot;Hello world&quot;</span>, <span class="er">$</span><span class="op">))()</span>;</span>
<span id="cb33-4"><a href="#cb33-4"></a>    file <span class="op">|&gt;</span> fseek<span class="op">(</span><span class="dv">9</span>, SEEK_SET<span class="op">)</span>;</span>
<span id="cb33-5"><a href="#cb33-5"></a>    file <span class="op">|&gt;</span> fclose<span class="op">()</span>;</span>
<span id="cb33-6"><a href="#cb33-6"></a><span class="op">}</span></span></code></pre></div></td>
</tr>
</tbody>
</table>
<h1 data-number="4" style="border-bottom:1px solid #cccccc" id="placeholders-in-templates"><span class="header-section-number">4</span> Placeholders in Templates<a href="#placeholders-in-templates" class="self-link"></a></h1>
<p>There’s at least one more other context, completely separate from pipelining expressions and lambdas, where using placeholders is valuable: creating alias templates on the fly.</p>
<p>There are two problems with alias templates today: they <em>must</em> be declared as their own statement and that statement <em>cannot</em> be in local scope. This means that when you need an alias template, it could easily end up being declared quite far away from use. This is very similar to the problem of having to create function objects on their own line, far away from use - a problem that was solved with the introduction of lambdas in C++11.</p>
<p>One particularly interesting use of alias templates that merits consideration for a more convenient syntax is class template argument deduction. Since C++20, the following is valid:</p>
<blockquote>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">using</span> int_pair <span class="op">=</span> pair<span class="op">&lt;</span><span class="dt">int</span>, T<span class="op">&gt;</span>;</span>
<span id="cb34-2"><a href="#cb34-2"></a>int_pair x<span class="op">(</span><span class="dv">1</span>, <span class="dv">2</span><span class="op">)</span>; <span class="co">// ok, x is a pair&lt;int, int&gt;</span></span></code></pre></div>
</blockquote>
<p>This is fine if <code class="sourceCode cpp">int_pair</code> is a commonly used alias that actually merits a name. But is quite inconvenient if that is not the case: you have to introduce a (likely-meaningless) name, somewhere away from its intended use, to be only used a single time. But consider, instead, the following:</p>
<blockquote>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1"></a>pair<span class="op">&lt;</span><span class="dt">int</span>, <span class="er">$</span><span class="op">&gt;</span> x<span class="op">(</span><span class="dv">1</span>, <span class="dv">2</span><span class="op">)</span>;</span></code></pre></div>
</blockquote>
<p>If we define <code class="sourceCode cpp">pair<span class="op">&lt;</span><span class="dt">int</span>, <span class="er">$</span><span class="op">&gt;</span></code> as creating, on the fly, a uniquely-named alias template (in the same way that a lambda creates, on the fly, a uniquely-named function object), that might look like:</p>
<blockquote>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> _T1<span class="op">&gt;</span> <span class="kw">using</span> __pair_alias <span class="op">=</span> pair<span class="op">&lt;</span><span class="dt">int</span>, _T1<span class="op">&gt;</span>;</span></code></pre></div>
</blockquote>
<p>And the class template argument deduction rules we already have kick in and have the desired behavior. This is a frequently desired extension. For instance, some of <span class="citation" data-cites="P1021R1">[<a href="#ref-P1021R1" role="doc-biblioref">P1021R1</a>]</span>’s examples could be written as:</p>
<blockquote>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1"></a><span class="kw">using</span> <span class="kw">namespace</span> ba <span class="op">=</span> boost<span class="op">::</span>algorithm;</span>
<span id="cb37-2"><a href="#cb37-2"></a></span>
<span id="cb37-3"><a href="#cb37-3"></a>set<span class="op">&lt;</span>string, <span class="er">$</span><span class="op">&gt;</span> case_insensitive_strings<span class="op">(</span>ba<span class="op">::</span>ilexicographic_compare<span class="op">)</span>;</span>
<span id="cb37-4"><a href="#cb37-4"></a></span>
<span id="cb37-5"><a href="#cb37-5"></a><span class="co">// Lambda comparators are great for algorithms like sort</span></span>
<span id="cb37-6"><a href="#cb37-6"></a><span class="co">// Now with associative containers, too!</span></span>
<span id="cb37-7"><a href="#cb37-7"></a>set<span class="op">&lt;</span><span class="dt">int</span>, <span class="er">$</span><span class="op">&gt;</span> s<span class="op">([](</span><span class="dt">int</span> i, <span class="dt">int</span> j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb37-8"><a href="#cb37-8"></a>                 <span class="cf">return</span> std<span class="op">::</span>popcount<span class="op">(</span>i<span class="op">)</span> <span class="op">&lt;</span> std<span class="op">::</span>popcount<span class="op">(</span>j<span class="op">)</span>;</span>
<span id="cb37-9"><a href="#cb37-9"></a>               <span class="op">})</span>;</span>
<span id="cb37-10"><a href="#cb37-10"></a></span>
<span id="cb37-11"><a href="#cb37-11"></a><span class="co">// and container adaptors!</span></span>
<span id="cb37-12"><a href="#cb37-12"></a>priority_queue<span class="op">&lt;</span>Task, <span class="er">$</span><span class="op">&gt;</span> tasks<span class="op">([](</span>Task a, Task b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb37-13"><a href="#cb37-13"></a>                                 <span class="cf">return</span> a<span class="op">.</span>priority <span class="op">&lt;</span> b<span class="op">.</span>priority;</span>
<span id="cb37-14"><a href="#cb37-14"></a>                              <span class="op">})</span>;</span></code></pre></div>
</blockquote>
<p>The difference here is that I’m annotating, with a placeholder, the type that needs to be filled in… rather than omitting it entirely (which has the problem that <code class="sourceCode cpp">set<span class="op">&lt;</span>string<span class="op">&gt;</span></code> is already a valid type which is <em>not</em> the desired type for the variable <code class="sourceCode cpp">case_insensitive_strings</code>).</p>
<p>In this use-case, the choice of placeholder in particular should probably be <code class="sourceCode cpp"><span class="kw">auto</span></code>. As in:</p>
<blockquote>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1"></a>pair<span class="op">&lt;</span><span class="dt">int</span>, <span class="kw">auto</span><span class="op">&gt;</span> x<span class="op">(</span><span class="dv">1</span>, <span class="dv">2</span><span class="op">)</span>;</span></code></pre></div>
</blockquote>
<p>But there’s a few interesting questions around this usage:</p>
<h2 data-number="4.1" id="alias-or-constraint"><span class="header-section-number">4.1</span> Alias or Constraint<a href="#alias-or-constraint" class="self-link"></a></h2>
<p>Should a <em>template-id</em> with a placeholder be a constraint or an alias template? The interesting example might be <code class="sourceCode cpp">optional<span class="op">&lt;</span><span class="kw">auto</span><span class="op">&gt;</span> x <span class="op">=</span> <span class="dv">7</span>;</code> If <code class="sourceCode cpp">optional<span class="op">&lt;</span><span class="kw">auto</span><span class="op">&gt;</span></code> is a constraint, then this is ill-formed because <code class="sourceCode cpp"><span class="dv">7</span></code> is not some kind of <code class="sourceCode cpp">optional<span class="op">&lt;</span>T<span class="op">&gt;</span></code>. If it’s just an alias template, then this is fine and behaves the same as <code class="sourceCode cpp">optional x <span class="op">=</span> <span class="dv">7</span>;</code>, which wraps the <code class="sourceCode cpp"><span class="dv">7</span></code>, declaring <code class="sourceCode cpp">x</code> to be an <code class="sourceCode cpp">optional<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span></code>. Both forms are useful: it’s just a question of whether the intent is to do pattern matching or to do class template argument deduction.</p>
<p>However, if <code class="sourceCode cpp">optional<span class="op">&lt;</span><span class="kw">auto</span><span class="op">&gt;</span></code> <em>were</em> a constraint, how would you use it in a <em>requires-clause</em>? What would that syntax be? There doesn’t really seem to be an obvious choice here (<code class="sourceCode cpp">optional<span class="op">&lt;</span><span class="kw">auto</span><span class="op">&gt;&lt;</span>T<span class="op">&gt;</span></code>? Nope.) This is a separate problem that’s also important to consider, since this does come up: we need a way to unpack types. Perhaps the right way here is to allow a <code class="sourceCode cpp"><span class="kw">using</span></code> declaration in the middle of a template parameter list:</p>
<blockquote>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T, <span class="kw">typename</span> F,</span>
<span id="cb39-2"><a href="#cb39-2"></a>          <span class="kw">using</span> optional<span class="op">&lt;</span><span class="kw">typename</span> U<span class="op">&gt;</span> <span class="op">=</span> invoke_result_t<span class="op">&lt;</span>F<span class="op">&amp;</span>, T <span class="kw">const</span><span class="op">&amp;&gt;&gt;</span></span>
<span id="cb39-3"><a href="#cb39-3"></a><span class="kw">auto</span> and_then<span class="op">(</span>optional<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span>, F<span class="op">)</span> <span class="op">-&gt;</span> optional<span class="op">&lt;</span>U<span class="op">&gt;</span>;</span></code></pre></div>
</blockquote>
<h2 data-number="4.2" id="how-many-autos"><span class="header-section-number">4.2</span> How many <code class="sourceCode cpp"><span class="kw">auto</span></code>s<a href="#how-many-autos" class="self-link"></a></h2>
<p>Let’s say rather than <code class="sourceCode cpp"><span class="kw">auto</span></code> we wanted some kind of constraint:</p>
<blockquote>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1"></a>pair<span class="op">&lt;</span><span class="dt">int</span>, invocable<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> auto<sub>1</sub><span class="op">&gt;</span>  auto<sub>2</sub> p <span class="op">=</span> <span class="co">/* ... */</span>;</span></code></pre></div>
</blockquote>
<p>Which of those two <code class="sourceCode cpp"><span class="kw">auto</span></code>s is necessary?</p>
<ul>
<li><code class="sourceCode cpp">auto<sub>1</sub></code> is very likely necessary. <code class="sourceCode cpp">invocable<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span></code> is a valid expression in its own right (that evaluates to <code class="sourceCode cpp"><span class="kw">false</span></code>) so you have to know if this is a <em>concept-id</em> or a <em>type-constraint</em>. The <code class="sourceCode cpp"><span class="kw">auto</span></code> would signal that this is clearly a <em>type-constraint</em> and thus a placeholder.</li>
<li><code class="sourceCode cpp">auto<sub>2</sub></code>, given the necessity of <code class="sourceCode cpp">auto<sub>1</sub></code>, may not be necessary. Perhaps it could be used to differentiate the alias vs constraint cases, where <code class="sourceCode cpp">optional<span class="op">&lt;</span><span class="kw">auto</span><span class="op">&gt;</span> a <span class="op">=</span> <span class="dv">7</span>;</code> is an alias with a placeholder but <code class="sourceCode cpp">optional<span class="op">&lt;</span><span class="kw">auto</span><span class="op">&gt;</span> <span class="kw">auto</span> b <span class="op">=</span> <span class="dv">7</span>;</code> (which is the syntax we use for constrained variable declarations) is a constraint (that fails because <code class="sourceCode cpp"><span class="dv">7</span></code> is not an <code class="sourceCode cpp">optional<span class="op">&lt;</span><span class="kw">auto</span><span class="op">&gt;</span></code>). But this seems a bit subtle and, if anything, is an argument <em>against</em> using <code class="sourceCode cpp">auto<sub>2</sub></code> to avoid the association with constrained variable declarations.</li>
</ul>
<p>Alternatively, <code class="sourceCode cpp"><span class="kw">auto</span></code> might be the wrong choice of placeholder for the concept case, and we may want a placeholder for the hole:</p>
<blockquote>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1"></a>pair<span class="op">&lt;</span><span class="dt">int</span>, invocable<span class="op">&lt;</span><span class="er">$</span>, <span class="dt">int</span><span class="op">&gt;&gt;</span> <span class="kw">auto</span> p <span class="op">=</span> <span class="co">/* ... */</span>;</span></code></pre></div>
</blockquote>
<p>One reason for that might be …</p>
<h2 data-number="4.3" id="concept-template-parameters"><span class="header-section-number">4.3</span> Concept template parameters<a href="#concept-template-parameters" class="self-link"></a></h2>
<p>One related idea is the desire to have concept template parameters. One example might be <code class="sourceCode cpp">RangeOf</code>: there’s a lot of additional things you might want to check about a range, so a general concept that can check whatever you ask seems pretty valuable (since sometimes you want a <code class="sourceCode cpp">same_as</code>, sometimes a <code class="sourceCode cpp">convertible_to</code>, sometimes a completely different concept). Let’s say we can declare such a thing this way:</p>
<blockquote>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> R, <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">&gt;</span> <span class="kw">concept</span> C<span class="op">&gt;</span></span>
<span id="cb42-2"><a href="#cb42-2"></a><span class="kw">concept</span> range_of <span class="op">=</span> ranges<span class="op">::</span>input_range<span class="op">&lt;</span>R<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> C<span class="op">&lt;</span>ranges<span class="op">::</span>range_reference_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;</span>;</span></code></pre></div>
</blockquote>
<p>This would fairly straightforward allow something like <code class="sourceCode cpp">range_of<span class="op">&lt;</span>R, ranges<span class="op">::</span>input_range<span class="op">&gt;</span></code>, since <code class="sourceCode cpp">input_range</code> is already itself a unary concept.</p>
<p>But sometimes we’d want to partially apply a binary concept, like <code class="sourceCode cpp">range_of<span class="op">&lt;</span>R, same_as<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span></code>. This has the same potential issue I showed with <code class="sourceCode cpp">invocable</code>: <code class="sourceCode cpp">C<span class="op">&lt;</span>T<span class="op">&gt;</span></code> may itself be a valid expression, so we need to be clear that we want to synthesize something. A placeholder could work here too:</p>
<blockquote>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1"></a><span class="kw">template</span> <span class="op">&lt;</span>range_of<span class="op">&lt;</span>convertible_to<span class="op">&lt;</span><span class="er">$</span>, <span class="dt">int</span><span class="op">&gt;&gt;</span> R<span class="op">&gt;</span></span>
<span id="cb43-2"><a href="#cb43-2"></a><span class="dt">void</span> algo<span class="op">(</span>R<span class="op">&amp;&amp;)</span>;</span></code></pre></div>
</blockquote>
<p>Where the base case would be to just provide a placeholder where today we don’t actually need one:</p>
<blockquote>
<div class="sourceCode" id="cb44"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1"></a><span class="kw">template</span> <span class="op">&lt;</span>ranges<span class="op">::</span>range<span class="op">&lt;</span><span class="er">$</span><span class="op">&gt;</span> R<span class="op">&gt;</span></span>
<span id="cb44-2"><a href="#cb44-2"></a><span class="dt">void</span> algo<span class="op">(</span>R<span class="op">&amp;&amp;)</span>;</span></code></pre></div>
</blockquote>
<h2 data-number="4.4" id="what-about-non-type-template-parameters"><span class="header-section-number">4.4</span> What about non-type template parameters?<a href="#what-about-non-type-template-parameters" class="self-link"></a></h2>
<p>What about this case:</p>
<blockquote>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1"></a>std<span class="op">::</span>array<span class="op">&lt;</span><span class="dt">int</span>, <span class="er">$</span><span class="op">&gt;</span> x <span class="op">=</span> <span class="op">{</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span><span class="op">}</span>;</span></code></pre></div>
</blockquote>
<p>Can this deduce <code class="sourceCode cpp">x</code> as an <code class="sourceCode cpp">array<span class="op">&lt;</span><span class="dt">int</span>, <span class="dv">5</span><span class="op">&gt;</span></code>? I’d expect so - this is just another example of the limitation of class template argument deduction of not being able to provide some of the arguments.</p>
<h1 data-number="5" style="border-bottom:1px solid #cccccc" id="bibliography"><span class="header-section-number">5</span> References<a href="#bibliography" class="self-link"></a></h1>
<div id="refs" class="references hanging-indent" role="doc-bibliography">
<div id="ref-P0973R0">
<p>[P0973R0] Geoff Romer, James Dennett. 2018-03-23. Coroutines TS Use Cases and Design Issues. <br />
<a href="https://wg21.link/p0973r0">https://wg21.link/p0973r0</a></p>
</div>
<div id="ref-P1021R1">
<p>[P1021R1] Mike Spertus, Timur Doumler, Richard Smith. 2018-10-07. Filling holes in Class Template Argument Deduction. <br />
<a href="https://wg21.link/p1021r1">https://wg21.link/p1021r1</a></p>
</div>
<div id="ref-P2011R0">
<p>[P2011R0] Barry Revzin, Colby Pike. 2020-01-07. A pipeline-rewrite operator. <br />
<a href="https://wg21.link/p2011r0">https://wg21.link/p2011r0</a></p>
</div>
<div id="ref-P2011R1">
<p>[P2011R1] Barry Revzin, Colby Pike. 2020-04-16. A pipeline-rewrite operator. <br />
<a href="https://wg21.link/p2011r1">https://wg21.link/p2011r1</a></p>
</div>
<div id="ref-P2321R1">
<p>[P2321R1] Tim Song. 2021-04-11. zip. <br />
<a href="https://wg21.link/p2321r1">https://wg21.link/p2321r1</a></p>
</div>
<div id="ref-pipeline-minutes">
<p>[pipeline-minutes] EWG. 2020. P2011R1 Telecon - September 2020. <br />
<a href="https://wiki.edg.com/bin/view/Wg21summer2020/EWG-P2011R1-10-Sep-2020">https://wiki.edg.com/bin/view/Wg21summer2020/EWG-P2011R1-10-Sep-2020</a></p>
</div>
<div id="ref-vector-bool">
<p>[vector-bool] Colby Pike. 2018. Now I Am Become Perl. <br />
<a href="https://vector-of-bool.github.io/2018/10/31/become-perl.html">https://vector-of-bool.github.io/2018/10/31/become-perl.html</a></p>
</div>
<div id="ref-vector-bool-macro">
<p>[vector-bool-macro] Colby Pike. 2021. A Macro-Based Terse Lambda Expression. <br />
<a href="https://vector-of-bool.github.io/2021/04/20/terse-lambda-macro.html">https://vector-of-bool.github.io/2021/04/20/terse-lambda-macro.html</a></p>
</div>
</div>
</div>
</div>
</body>
</html>
