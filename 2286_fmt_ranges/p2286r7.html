<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="mpark/wg21" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2022-04-19" />
  <title>Formatting Ranges</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
      div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
      ul.task-list{list-style: none;}
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode
        {  background-color: #f6f8fa; }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span. { } /* Normal */
      code span.al { color: #ff0000; } /* Alert */
      code span.an { } /* Annotation */
      code span.at { } /* Attribute */
      code span.bn { color: #9f6807; } /* BaseN */
      code span.bu { color: #9f6807; } /* BuiltIn */
      code span.cf { color: #00607c; } /* ControlFlow */
      code span.ch { color: #9f6807; } /* Char */
      code span.cn { } /* Constant */
      code span.co { color: #008000; font-style: italic; } /* Comment */
      code span.cv { color: #008000; font-style: italic; } /* CommentVar */
      code span.do { color: #008000; } /* Documentation */
      code span.dt { color: #00607c; } /* DataType */
      code span.dv { color: #9f6807; } /* DecVal */
      code span.er { color: #ff0000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #9f6807; } /* Float */
      code span.fu { } /* Function */
      code span.im { } /* Import */
      code span.in { color: #008000; } /* Information */
      code span.kw { color: #00607c; } /* Keyword */
      code span.op { color: #af1915; } /* Operator */
      code span.ot { } /* Other */
      code span.pp { color: #6f4e37; } /* Preprocessor */
      code span.re { } /* RegionMarker */
      code span.sc { color: #9f6807; } /* SpecialChar */
      code span.ss { color: #9f6807; } /* SpecialString */
      code span.st { color: #9f6807; } /* String */
      code span.va { } /* Variable */
      code span.vs { color: #9f6807; } /* VerbatimString */
      code span.wa { color: #008000; font-weight: bold; } /* Warning */
      code.diff {color: #898887}
      code.diff span.va {color: #006e28}
      code.diff span.st {color: #bf0303}
  </style>
  <style type="text/css">
body {
margin: 5em;
font-family: serif;

hyphens: auto;
line-height: 1.35;
}
div.wrapper {
max-width: 60em;
margin: auto;
}
ul {
list-style-type: none;
padding-left: 2em;
margin-top: -0.2em;
margin-bottom: -0.2em;
}
a {
text-decoration: none;
color: #4183C4;
}
a.hidden_link {
text-decoration: none;
color: inherit;
}
li {
margin-top: 0.6em;
margin-bottom: 0.6em;
}
h1, h2, h3, h4 {
position: relative;
line-height: 1;
}
a.self-link {
position: absolute;
top: 0;
left: calc(-1 * (3.5rem - 26px));
width: calc(3.5rem - 26px);
height: 2em;
text-align: center;
border: none;
transition: opacity .2s;
opacity: .5;
font-family: sans-serif;
font-weight: normal;
font-size: 83%;
}
a.self-link:hover { opacity: 1; }
a.self-link::before { content: "§"; }
ul > li:before {
content: "\2014";
position: absolute;
margin-left: -1.5em;
}
:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }
.abbr_ref { float: right; }
.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }
:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }
.secnum { display: inline-block; min-width: 35pt; }
.header-section-number { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }
div.sourceLinkParent {
float: right;
}
a.sourceLink {
position: absolute;
opacity: 0;
margin-left: 10pt;
}
a.sourceLink:hover {
opacity: 1;
}
a.itemDeclLink {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
opacity: 0;
}
a.itemDeclLink:hover { opacity: 1; }
span.marginalizedparent {
position: relative;
left: -5em;
}
li span.marginalizedparent { left: -7em; }
li ul > li span.marginalizedparent { left: -9em; }
li ul > li ul > li span.marginalizedparent { left: -11em; }
li ul > li ul > li ul > li span.marginalizedparent { left: -13em; }
div.footnoteNumberParent {
position: relative;
left: -4.7em;
}
a.marginalized {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
}
a.enumerated_item_num {
position: relative;
left: -3.5em;
display: inline-block;
margin-right: -3em;
text-align: right;
width: 3em;
}
div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }
span.indexparent {
display: inline;
position: relative;
float: right;
right: -1em;
}
a.index {
position: absolute;
display: none;
}
a.index:before { content: "⟵"; }

a.index:target {
display: inline;
}
.indexitems {
margin-left: 2em;
text-indent: -2em;
}
div.itemdescr {
margin-left: 3em;
}
.bnf {
font-family: serif;
margin-left: 40pt;
margin-top: 0.5em;
margin-bottom: 0.5em;
}
.ncbnf {
font-family: serif;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
}
.ncsimplebnf {
font-family: serif;
font-style: italic;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
background: inherit; 
}
span.textnormal {
font-style: normal;
font-family: serif;
white-space: normal;
display: inline-block;
}
span.rlap {
display: inline-block;
width: 0px;
}
span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }
span.phantom { color: white; }

span.math { font-style: normal; }
span.mathblock {
display: block;
margin-left: auto;
margin-right: auto;
margin-top: 1.2em;
margin-bottom: 1.2em;
text-align: center;
}
span.mathalpha {
font-style: italic;
}
span.synopsis {
font-weight: bold;
margin-top: 0.5em;
display: block;
}
span.definition {
font-weight: bold;
display: block;
}
.codeblock {
margin-left: 1.2em;
line-height: 127%;
}
.outputblock {
margin-left: 1.2em;
line-height: 127%;
}
div.itemdecl {
margin-top: 2ex;
}
code.itemdeclcode {
white-space: pre;
display: block;
}
span.textsuperscript {
vertical-align: super;
font-size: smaller;
line-height: 0;
}
.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }
.footnote {
font-size: small;
margin-left: 2em;
margin-right: 2em;
margin-top: 0.6em;
margin-bottom: 0.6em;
}
div.minipage {
display: inline-block;
margin-right: 3em;
}
div.numberedTable {
text-align: center;
margin: 2em;
}
div.figure {
text-align: center;
margin: 2em;
}
table {
border: 1px solid black;
border-collapse: collapse;
margin-left: auto;
margin-right: auto;
margin-top: 0.8em;
text-align: left;
hyphens: none; 
}
td, th {
padding-left: 1em;
padding-right: 1em;
vertical-align: top;
}
td.empty {
padding: 0px;
padding-left: 1px;
}
td.left {
text-align: left;
}
td.right {
text-align: right;
}
td.center {
text-align: center;
}
td.justify {
text-align: justify;
}
td.border {
border-left: 1px solid black;
}
tr.rowsep, td.cline {
border-top: 1px solid black;
}
tr.even, tr.odd {
border-bottom: 1px solid black;
}
tr.capsep {
border-top: 3px solid black;
border-top-style: double;
}
tr.header {
border-bottom: 3px solid black;
border-bottom-style: double;
}
th {
border-bottom: 1px solid black;
}
span.centry {
font-weight: bold;
}
div.table {
display: block;
margin-left: auto;
margin-right: auto;
text-align: center;
width: 90%;
}
span.indented {
display: block;
margin-left: 2em;
margin-bottom: 1em;
margin-top: 1em;
}
ol.enumeratea { list-style-type: none; background: inherit; }
ol.enumerate { list-style-type: none; background: inherit; }

code.sourceCode > span { display: inline; }
</style>
  <style type="text/css">a {
color : #4183C4;
text-decoration: underline;
}
a.marginalized {
text-decoration: none;
}
a.self-link {
text-decoration: none;
}
h1#toctitle {
border-bottom: 1px solid #cccccc;
}
#TOC li {
margin-top: 1px;
margin-bottom: 1px;
}
#TOC ul>li:before { display: none; }
h3.subtitle { margin-top: -15px; }
h1:target { background-color: transparent; }
h2:target { background-color: transparent; }
h3:target { background-color: transparent; }
h4:target { background-color: transparent; }
h5:target { background-color: transparent; }
h6:target { background-color: transparent; }
code span.co { font-family: monospace; }
table tr {
background-color: white;
}
table tr:nth-child(2n) {
background-color: #f6f8fa;
}
#title-block-header > table tr:nth-child(2n) {
background-color: white;
}
td > div.sourceCode {
background-color: inherit;
}
table {
border-collapse: collapse;
}
table td, table th {
border: 1px solid #cccccc;
}
table th {
border-bottom: 1px solid black;
text-align: center;
}
table tr:first-child th {
border-top: 0;
}
table tr:last-child td {
border-bottom: 0;
}
table tr td:first-child,
table tr th:first-child {
border-left: 0;
}
table tr td:last-child,
table tr th:last-child {
border-right: 0;
}
table tbody tr:first-child td {
border-top: 1px solid black;
}
#title-block-header td { border: 0; }
@media all {
body {
margin: 2em;
}
}
@media screen and (min-width: 480px) {
body {
margin: 5em;
}
}
#refs code{padding-left: 0px; text-indent: 0px;}
:root {
--diff-ins: #e6ffed;
--diff-strongins: #acf2bd;
--diff-del: #ffdddd;
--diff-strongdel: #ff8888;
}
span.diffins {
background-color: var(--diff-strongins);
}
span.diffdel {
background-color: var(--diff-strongdel);
}
div.rm { text-decoration: line-through; }
div.rm code.sourceCode { text-decoration: line-through; }
div.addu, span.addu {
color: #006e28;
background-color: var(--diff-ins);
}

div.rm pre, div.add pre { background-color: #f6f8fa; }
div.addu pre { background-color: var(--diff-ins); }
div.add, div.add pre { background-color: var(--diff-ins); }
div.addu blockquote {
border-left: 4px solid #00a000;
padding: 0 15px;
color: #006e28;
text-decoration: none;
}
div.addu blockquote code.sourceCode { text-decoration: none; }
div.addu blockquote pre { text-decoration: none; }
div.addu blockquote pre code { text-decoration: none; }
div.quote {
border-left: 7px solid #ccc;
background: #f9f9f9;
margin: 1.5em 10px;
padding-left: 20px;
}
code.diff span.va { color: #000000; background-color: var(--diff-ins); }
code.diff span.st { color: #000000; background-color: var(--diff-del); }
</style>
  <link href="data:image/x-icon;base64,AAABAAIAEBAAAAEAIABoBAAAJgAAACAgAAABACAAqBAAAI4EAAAoAAAAEAAAACAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAVoJEAN6CRADegkQAWIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wCCRAAAgkQAAIJEAACCRAAsgkQAvoJEAP+CRAD/gkQA/4JEAP+CRADAgkQALoJEAACCRAAAgkQAAP///wD///8AgkQAAIJEABSCRACSgkQA/IJEAP99PQD/dzMA/3czAP99PQD/gkQA/4JEAPyCRACUgkQAFIJEAAD///8A////AHw+AFiBQwDqgkQA/4BBAP9/PxP/uZd6/9rJtf/bybX/upd7/39AFP+AQQD/gkQA/4FDAOqAQgBc////AP///wDKklv4jlEa/3o7AP+PWC//8+3o///////////////////////z7un/kFox/35AAP+GRwD/mVYA+v///wD///8A0Zpk+NmibP+0d0T/8evj///////+/fv/1sKz/9bCs//9/fr//////+/m2/+NRwL/nloA/5xYAPj///8A////ANKaZPjRmGH/5cKh////////////k149/3UwAP91MQD/lmQ//86rhv+USg3/m1YA/5hSAP+bVgD4////AP///wDSmmT4zpJY/+/bx///////8+TV/8mLT/+TVx//gkIA/5lVAP+VTAD/x6B//7aEVv/JpH7/s39J+P///wD///8A0ppk+M6SWP/u2sf///////Pj1f/Nj1T/2KFs/8mOUv+eWhD/lEsA/8aee/+0glT/x6F7/7J8Rvj///8A////ANKaZPjRmGH/48Cf///////+/v7/2qt//82PVP/OkFX/37KJ/86siv+USg7/mVQA/5hRAP+bVgD4////AP///wDSmmT40ppk/9CVXP/69O////////7+/v/x4M//8d/P//7+/f//////9u7n/6tnJf+XUgD/nFgA+P///wD///8A0ppk+NKaZP/RmWL/1qNy//r07///////////////////////+vXw/9akdP/Wnmn/y5FY/6JfFvj///8A////ANKaZFTSmmTo0ppk/9GYYv/Ql1//5cWm//Hg0P/x4ND/5cWm/9GXYP/RmGH/0ppk/9KaZOjVnmpY////AP///wDSmmQA0ppkEtKaZI7SmmT60ppk/9CWX//OkVb/zpFW/9CWX//SmmT/0ppk/NKaZJDSmmQS0ppkAP///wD///8A0ppkANKaZADSmmQA0ppkKtKaZLrSmmT/0ppk/9KaZP/SmmT/0ppkvNKaZCrSmmQA0ppkANKaZAD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkUtKaZNzSmmTc0ppkVNKaZADSmmQA0ppkANKaZADSmmQA////AP5/AAD4HwAA4AcAAMADAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAMADAADgBwAA+B8AAP5/AAAoAAAAIAAAAEAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAyCRACMgkQA6oJEAOqCRACQgkQAEIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRABigkQA5oJEAP+CRAD/gkQA/4JEAP+CRADqgkQAZoJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAA4gkQAwoJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQAxIJEADyCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAP///wD///8A////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAWgkQAmIJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAJyCRAAYgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAdIJEAPCCRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAPSCRAB4gkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQASoJEANKCRAD/gkQA/4JEAP+CRAD/g0YA/39AAP9zLgD/bSQA/2shAP9rIQD/bSQA/3MuAP9/PwD/g0YA/4JEAP+CRAD/gkQA/4JEAP+CRADUgkQAToJEAACCRAAAgkQAAP///wD///8A////AP///wB+PwAAgkUAIoJEAKiCRAD/gkQA/4JEAP+CRAD/hEcA/4BBAP9sIwD/dTAA/5RfKv+viF7/vp56/76ee/+wiF7/lWAr/3YxAP9sIwD/f0AA/4RHAP+CRAD/gkQA/4JEAP+CRAD/gkQArIJEACaBQwAA////AP///wD///8A////AIBCAEBzNAD6f0EA/4NFAP+CRAD/gkQA/4VIAP92MwD/bSUA/6N1Tv/ezsL/////////////////////////////////38/D/6V3Uv9uJgD/dTEA/4VJAP+CRAD/gkQA/4JEAP+BQwD/fUAA/4FDAEj///8A////AP///wD///8AzJRd5qBlKf91NgD/dDUA/4JEAP+FSQD/cy4A/3YyAP/PuKP//////////////////////////////////////////////////////9K7qP94NQD/ciwA/4VJAP+CRAD/fkEA/35BAP+LSwD/mlYA6v///wD///8A////AP///wDdpnL/4qx3/8KJUv+PUhf/cTMA/3AsAP90LgD/4dK+/////////////////////////////////////////////////////////////////+TYxf91MAD/dTIA/31CAP+GRwD/llQA/6FcAP+gWwD8////AP///wD///8A////ANGZY/LSm2X/4ap3/92mcP+wdT3/byQA/8mwj////////////////////////////////////////////////////////////////////////////+LYxv9zLgP/jUoA/59bAP+hXAD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/RmWL/1p9q/9ubXv/XqXj////////////////////////////7+fD/vZyG/6BxS/+gcUr/vJuE//r37f//////////////////////3MOr/5dQBf+dVQD/nVkA/5xYAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmWP/yohJ//jo2P//////////////////////4NTG/4JDFf9lGAD/bSQA/20kAP9kGAD/fz8S/+Xb0f//////5NG9/6txN/+LOgD/m1QA/51aAP+cWAD/m1cA/5xYAP+cWADy////AP///wD///8A////ANKaZPLSmmT/0ppk/8+TWf/Unmv//v37//////////////////////+TWRr/VwsA/35AAP+ERgD/g0UA/4JGAP9lHgD/kFga/8KXX/+TRwD/jT4A/49CAP+VTQD/n10A/5xYAP+OQQD/lk4A/55cAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/y4tO/92yiP//////////////////////8NnE/8eCQP+rcTT/ez0A/3IyAP98PgD/gEMA/5FSAP+USwD/jj8A/5lUAP+JNwD/yqV2/694Mf+HNQD/jkAA/82rf/+laBj/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/LiUr/4byY///////////////////////gupX/0I5P/+Wuev/Lklz/l1sj/308AP+QSwD/ol0A/59aAP+aVQD/k0oA/8yoh///////+fXv/6pwO//Lp3v///////Pr4f+oay7y////AP///wD///8A////ANKaZPLSmmT/0ppk/8uJSv/hvJj//////////////////////+G7l//Jhkb/0ppk/96nc//fqXX/x4xO/6dkFP+QSQD/llEA/5xXAP+USgD/yaOA///////38uv/qG05/8ijdv//////8efb/6ZpLPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/zIxO/9yxh///////////////////////7dbA/8iEQf/Sm2X/0Zlj/9ScZv/eqHf/2KJv/7yAQf+XTgD/iToA/5lSAP+JNgD/yKFv/611LP+HNQD/jT8A/8qmeP+kZRT/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/Pk1n/1J5q//78+//////////////////+/fv/1aFv/8iEQv/Tm2b/0ppl/9GZY//Wn2z/1pZc/9eldf/Bl2b/kUcA/4w9AP+OQAD/lUwA/59eAP+cWQD/jT8A/5ZOAP+eXADy////AP///wD///8A////ANKaZPLSmmT/0ppk/9KZY//KiEn/8d/P///////////////////////47+f/05tm/8iCP//KiEj/yohJ/8eCP//RmGH//vfy///////n1sP/rXQ7/4k4AP+TTAD/nVoA/5xYAP+cVwD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/0ptl/8uLTf/aq37////////////////////////////+/fz/6c2y/961jv/etY7/6Myx//78+v//////////////////////3MWv/5xXD/+ORAD/mFQA/51ZAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmmT/0ppk/8mFRP/s1b//////////////////////////////////////////////////////////////////////////////+PD/0JFU/7NzMv+WUQD/kUsA/5tXAP+dWQDy////AP///wD///8A////ANKaZP/SmmT/0ppk/9KaZP/Sm2X/z5NZ/8yMT//z5NX/////////////////////////////////////////////////////////////////9Ofa/8yNUP/UmGH/36p5/8yTWv+qaSD/kksA/5ROAPz///8A////AP///wD///8A0ppk5NKaZP/SmmT/0ppk/9KaZP/TnGf/zY9T/82OUv/t1sD//////////////////////////////////////////////////////+7Yw//OkFX/zI5R/9OcZ//SmmP/26V0/9ymdf/BhUf/ol8R6P///wD///8A////AP///wDSmmQ80ppk9tKaZP/SmmT/0ppk/9KaZP/TnGj/zpFW/8qJSv/dson/8uHS//////////////////////////////////Lj0//etIv/y4lL/86QVf/TnGj/0ppk/9KaZP/RmWP/05xn/9ymdfjUnWdC////AP///wD///8A////ANKaZADSmmQc0ppkotKaZP/SmmT/0ppk/9KaZP/Tm2b/0Zli/8qJSf/NjlH/16Z3/+G8mP/myKr/5siq/+G8mP/Xp3f/zY5S/8qISf/RmGH/05tm/9KaZP/SmmT/0ppk/9KaZP/SmmSm0pljINWdaQD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkQtKaZMrSmmT/0ppk/9KaZP/SmmT/0ptl/9GYYf/Nj1P/y4lL/8qISP/KiEj/y4lK/82PU//RmGH/0ptl/9KaZP/SmmT/0ppk/9KaZP/SmmTO0ppkRtKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZGzSmmTu0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmTw0ppkcNKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZBLSmmSQ0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppklNKaZBTSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQy0ppkutKaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppkvtKaZDbSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkXNKaZODSmmT/0ppk/9KaZP/SmmT/0ppk5NKaZGDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkBtKaZIbSmmTo0ppk6tKaZIrSmmQK0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP/8P///+B///+AH//+AAf//AAD//AAAP/AAAA/gAAAHwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA+AAAAfwAAAP/AAAP/8AAP//gAH//+AH///4H////D//" rel="icon" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
</head>
<body>
<div class="wrapper">
<header id="title-block-header">
<h1 class="title" style="text-align:center">Formatting Ranges</h1>

<table style="border:none;float:right">
  <tr>
    <td>Document #:</td>
    <td>P2286R7</td>
  </tr>
  <tr>
    <td>Date:</td>
    <td>2022-04-19</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Project:</td>
    <td>Programming Language C++</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Audience:</td>
    <td>
      LEWG<br>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top">Reply-to:</td>
    <td>
      Barry Revzin<br>&lt;<a href="mailto:barry.revzin@gmail.com" class="email">barry.revzin@gmail.com</a>&gt;<br>
    </td>
  </tr>
</table>

</header>
<div style="clear:both">
<div id="TOC" role="doc-toc">
<h1 id="toctitle">Contents</h1>
<ul>
<li><a href="#revision-history"><span class="toc-section-number">1</span> Revision History<span></span></a></li>
<li><a href="#introduction"><span class="toc-section-number">2</span> Introduction<span></span></a>
<ul>
<li><a href="#implementation-experience"><span class="toc-section-number">2.1</span> Implementation Experience<span></span></a></li>
</ul></li>
<li><a href="#proposal-considerations"><span class="toc-section-number">3</span> Proposal Considerations<span></span></a>
<ul>
<li><a href="#what-types-to-print"><span class="toc-section-number">3.1</span> What types to print?<span></span></a></li>
<li><a href="#detecting-whether-a-type-is-formattable"><span class="toc-section-number">3.2</span> Detecting whether a type is formattable<span></span></a></li>
<li><a href="#what-representation"><span class="toc-section-number">3.3</span> What representation?<span></span></a>
<ul>
<li><a href="#vector-and-other-ranges"><span class="toc-section-number">3.3.1</span> <code class="sourceCode cpp">vector</code> (and other ranges)<span></span></a></li>
<li><a href="#pair-and-tuple"><span class="toc-section-number">3.3.2</span> <code class="sourceCode cpp">pair</code> and <code class="sourceCode cpp">tuple</code><span></span></a></li>
<li><a href="#map-and-set-and-other-associative-containers"><span class="toc-section-number">3.3.3</span> <code class="sourceCode cpp">map</code> and <code class="sourceCode cpp">set</code> (and other associative containers)<span></span></a></li>
<li><a href="#char-and-string-and-other-string-like-types-in-ranges-or-tuples"><span class="toc-section-number">3.3.4</span> <code class="sourceCode cpp"><span class="dt">char</span></code> and <code class="sourceCode cpp">string</code> (and other string-like types) in ranges or tuples<span></span></a></li>
<li><a href="#filesystempath"><span class="toc-section-number">3.3.5</span> <code class="sourceCode cpp">filesystem<span class="op">::</span>path</code><span></span></a></li>
<li><a href="#format-specifiers"><span class="toc-section-number">3.3.6</span> Format Specifiers<span></span></a></li>
<li><a href="#explanation-of-added-specifiers"><span class="toc-section-number">3.3.7</span> Explanation of Added Specifiers<span></span></a>
<ul>
<li><a href="#the-debug-specifier"><span class="toc-section-number">3.3.7.1</span> The debug specifier <code class="sourceCode cpp"><span class="op">?</span></code><span></span></a></li>
<li><a href="#range-specifiers"><span class="toc-section-number">3.3.7.2</span> Range specifiers<span></span></a></li>
<li><a href="#pair-and-tuple-specifiers"><span class="toc-section-number">3.3.7.3</span> Pair and Tuple Specifiers<span></span></a></li>
</ul></li>
<li><a href="#escaping-behavior"><span class="toc-section-number">3.3.8</span> Escaping Behavior<span></span></a>
<ul>
<li><a href="#python"><span class="toc-section-number">3.3.8.1</span> Python<span></span></a></li>
<li><a href="#rust"><span class="toc-section-number">3.3.8.2</span> Rust<span></span></a></li>
<li><a href="#golang"><span class="toc-section-number">3.3.8.3</span> Golang<span></span></a></li>
<li><a href="#proposed-for-c"><span class="toc-section-number">3.3.8.4</span> Proposed for C++<span></span></a></li>
</ul></li>
</ul></li>
<li><a href="#implementation-challenges"><span class="toc-section-number">3.4</span> Implementation Challenges<span></span></a></li>
<li><a href="#how-to-support-those-views-which-are-not-const-iterable"><span class="toc-section-number">3.5</span> How to support those views which are not <code class="sourceCode cpp"><span class="kw">const</span></code>-iterable?<span></span></a></li>
<li><a href="#interface-of-the-proposed-solution"><span class="toc-section-number">3.6</span> Interface of the proposed solution<span></span></a></li>
<li><a href="#what-additional-functionality"><span class="toc-section-number">3.7</span> What additional functionality?<span></span></a></li>
<li><a href="#format-or-stdcout"><span class="toc-section-number">3.8</span> <code class="sourceCode cpp">format</code> or <code class="sourceCode cpp">std<span class="op">::</span>cout</code>?<span></span></a></li>
<li><a href="#what-about-vectorbool"><span class="toc-section-number">3.9</span> What about <code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;</span></code>?<span></span></a></li>
<li><a href="#what-about-container-adaptors"><span class="toc-section-number">3.10</span> What about container adaptors?<span></span></a></li>
<li><a href="#examples-with-user-defined-types"><span class="toc-section-number">3.11</span> Examples with user-defined types<span></span></a></li>
</ul></li>
<li><a href="#proposal"><span class="toc-section-number">4</span> Proposal<span></span></a></li>
<li><a href="#wording"><span class="toc-section-number">5</span> Wording<span></span></a>
<ul>
<li><a href="#concept-formattable"><span class="toc-section-number">5.1</span> Concept <code class="sourceCode cpp">formattable</code><span></span></a></li>
<li><a href="#additional-formatting-support-for-characters-and-strings"><span class="toc-section-number">5.2</span> Additional formatting support for characters and strings<span></span></a></li>
<li><a href="#formatting-for-ranges"><span class="toc-section-number">5.3</span> Formatting for ranges<span></span></a>
<ul>
<li><a href="#formatting-for-specific-ranges-all-the-maps-and-sets"><span class="toc-section-number">5.3.1</span> Formatting for specific ranges: all the maps and sets<span></span></a></li>
<li><a href="#formatting-for-specific-ranges-all-the-container-adaptors"><span class="toc-section-number">5.3.2</span> Formatting for specific ranges: all the container adaptors<span></span></a></li>
</ul></li>
<li><a href="#formatting-for-pair-and-tuple"><span class="toc-section-number">5.4</span> Formatting for <code class="sourceCode cpp">pair</code> and <code class="sourceCode cpp">tuple</code><span></span></a></li>
<li><a href="#formatter-for-vectorboolreference"><span class="toc-section-number">5.5</span> Formatter for <code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;::</span>reference</code><span></span></a></li>
<li><a href="#feature-test-macro"><span class="toc-section-number">5.6</span> Feature-test Macro<span></span></a></li>
</ul></li>
<li><a href="#acknowledgments"><span class="toc-section-number">6</span> Acknowledgments<span></span></a></li>
<li><a href="#bibliography"><span class="toc-section-number">7</span> References<span></span></a></li>
</ul>
</div>
<h1 data-number="1" style="border-bottom:1px solid #cccccc" id="revision-history"><span class="header-section-number">1</span> Revision History<a href="#revision-history" class="self-link"></a></h1>
<p>Since <span class="citation" data-cites="P2286R6">[<a href="#ref-P2286R6" role="doc-biblioref">P2286R6</a>]</span>, wording.</p>
<p>Since <span class="citation" data-cites="P2286R5">[<a href="#ref-P2286R5" role="doc-biblioref">P2286R5</a>]</span>, missing feature test macro and few wording changes, including:</p>
<ul>
<li><code class="sourceCode cpp">formatter<span class="op">&lt;</span>R, charT<span class="op">&gt;</span></code> for ranges no longer specified to inherit from <code class="sourceCode cpp">range_formatter<span class="op">&lt;</span>range_reference_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;</span></code></li>
<li>the output iterator for the <code class="sourceCode cpp">formattable</code> concept is now unspecified rather than implementation-defined</li>
</ul>
<p>Since <span class="citation" data-cites="P2286R4">[<a href="#ref-P2286R4" role="doc-biblioref">P2286R4</a>]</span>, several major changes:</p>
<ul>
<li>Removed the <code class="sourceCode cpp">d</code> specifier for delimiters. This paper offers no direct support for changing delimiters (which this paper also in the wording refers to as separators).</li>
<li>Removed the extra APIs (<code class="sourceCode cpp">retargeted_format_context</code> and <code class="sourceCode cpp">end_sentry</code>), and the motivation for their existence.</li>
<li>Added clearer description of why <code class="sourceCode cpp">range_formatter</code> is desired and what its <a href="#interface-of-the-proposed-solution">exposed API is</a>.</li>
<li>Updated <a href="#escaping-behavior">escaping behavior</a> description with how some other languages do this.</li>
<li>Added section on <a href="#what-about-container-adaptors">container adaptors</a>.</li>
<li>Added wording.</li>
</ul>
<p>Since <span class="citation" data-cites="P2286R3">[<a href="#ref-P2286R3" role="doc-biblioref">P2286R3</a>]</span>, several major changes:</p>
<ul>
<li>Removed the special <code class="sourceCode cpp">pair</code>/<code class="sourceCode cpp">tuple</code> parsing for individual elements. This proved complicated and illegible, and led to having to deal with more issues that would make this paper harder to make it for C++23.</li>
<li>Adding sections on <a href="#dynamic-delimiter-for-ranges">dynamic</a> and <a href="#static-delimiter-for-ranges">static</a> delimiters for ranges. Removing <code class="sourceCode cpp">std<span class="op">::</span>format_join</code> in their favor.</li>
<li>Renaming <code class="sourceCode cpp">format_as_debug</code> to <code class="sourceCode cpp">set_debug_format</code> (since it’s not actually <em>formatting</em> anything, it’s just setting up)</li>
<li>Discussing <code class="sourceCode cpp">std<span class="op">::</span>filesystem<span class="op">::</span>path</code></li>
</ul>
<p>Since <span class="citation" data-cites="P2286R2">[<a href="#ref-P2286R2" role="doc-biblioref">P2286R2</a>]</span>, several major changes:</p>
<ul>
<li>This paper assumes the adoption of <span class="citation" data-cites="P2418R0">[<a href="#ref-P2418R0" role="doc-biblioref">P2418R0</a>]</span>, which affects how <a href="#how-to-support-those-views-which-are-not-const-iterable">non-<code class="sourceCode cpp"><span class="kw">const</span></code>-iterable views</a> are handled. This paper now introduces two concepts (<code class="sourceCode cpp">formattable</code> and <code class="sourceCode cpp">const_formattable</code>) instead of just one.</li>
<li>Extended discussion and functionality for various <a href="#what-representation">representations</a>, including how to quote strings properly and how to format associative ranges.</li>
<li>Introduction of format specifiers of all kinds and discussion of how to make them work more broadly.</li>
<li>Removed the wording, since the priority is the design.</li>
</ul>
<p>Since <span class="citation" data-cites="P2286R1">[<a href="#ref-P2286R1" role="doc-biblioref">P2286R1</a>]</span>, adding a sketch of wording.</p>
<p><span class="citation" data-cites="P2286R0">[<a href="#ref-P2286R0" role="doc-biblioref">P2286R0</a>]</span> suggested making all the formatting implementation-defined. Several people reached out to me suggesting in no uncertain terms that this is unacceptable. This revision lays out options for such formatting.</p>
<h1 data-number="2" style="border-bottom:1px solid #cccccc" id="introduction"><span class="header-section-number">2</span> Introduction<a href="#introduction" class="self-link"></a></h1>
<p><span class="citation" data-cites="LWG3478">[<a href="#ref-LWG3478" role="doc-biblioref">LWG3478</a>]</span> addresses the issue of what happens when you split a string and the last character in the string is the delimiter that you are splitting on. One of the things I wanted to look at in research in that issue is: what do <em>other</em> languages do here?</p>
<p>For most languages, this is a pretty easy proposition. Do the split, print the results. This is usually only a few lines of code.</p>
<p>Python:</p>
<blockquote>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="bu">print</span>(<span class="st">&quot;xyx&quot;</span>.split(<span class="st">&quot;x&quot;</span>))</span></code></pre></div>
<p>outputs</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1"></a>[&#39;&#39;, &#39;y&#39;, &#39;&#39;]</span></code></pre></div>
</blockquote>
<p>Java (where the obvious thing prints something useless, but there’s a non-obvious thing that is useful):</p>
<blockquote>
<div class="sourceCode" id="cb2"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">import</span><span class="im"> java.util.Arrays;</span></span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="kw">class</span> Main {</span>
<span id="cb2-4"><a href="#cb2-4"></a>  <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(<span class="bu">String</span> args[]) {</span>
<span id="cb2-5"><a href="#cb2-5"></a>    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;xyx&quot;</span>.<span class="fu">split</span>(<span class="st">&quot;x&quot;</span>));</span>
<span id="cb2-6"><a href="#cb2-6"></a>    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="bu">Arrays</span>.<span class="fu">toString</span>(<span class="st">&quot;xyx&quot;</span>.<span class="fu">split</span>(<span class="st">&quot;x&quot;</span>)));</span>
<span id="cb2-7"><a href="#cb2-7"></a>  }</span>
<span id="cb2-8"><a href="#cb2-8"></a>}</span></code></pre></div>
<p>outputs</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb2-1"><a href="#cb2-1"></a>[Ljava.lang.String;@76ed5528</span>
<span id="cb2-2"><a href="#cb2-2"></a>[, y]</span></code></pre></div>
</blockquote>
<p>Rust (a couple options, including also another false friend):</p>
<blockquote>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">use</span> <span class="pp">itertools::</span>Itertools<span class="op">;</span></span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>    <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> <span class="st">&quot;xyx&quot;</span><span class="op">.</span>split(<span class="ch">&#39;x&#39;</span>))<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>    <span class="pp">println!</span>(<span class="st">&quot;[{}]&quot;</span><span class="op">,</span> <span class="st">&quot;xyx&quot;</span><span class="op">.</span>split(<span class="ch">&#39;x&#39;</span>)<span class="op">.</span>format(<span class="st">&quot;, &quot;</span>))<span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>    <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> <span class="st">&quot;xyx&quot;</span><span class="op">.</span>split(<span class="ch">&#39;x&#39;</span>)<span class="op">.</span><span class="pp">collect::</span><span class="op">&lt;</span><span class="dt">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;&gt;</span>())<span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="op">}</span></span></code></pre></div>
<p>outputs</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb3-1"><a href="#cb3-1"></a>Split(SplitInternal { start: 0, end: 3, matcher: CharSearcher { haystack: &quot;xyx&quot;, finger: 0, finger_back: 3, needle: &#39;x&#39;, utf8_size: 1, utf8_encoded: [120, 0, 0, 0] }, allow_trailing_empty: true, finished: false })</span>
<span id="cb3-2"><a href="#cb3-2"></a>[, y, ]</span>
<span id="cb3-3"><a href="#cb3-3"></a>[&quot;&quot;, &quot;y&quot;, &quot;&quot;]</span></code></pre></div>
</blockquote>
<p>Kotlin:</p>
<blockquote>
<div class="sourceCode" id="cb4"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">fun</span> <span class="fu">main</span>() {</span>
<span id="cb4-2"><a href="#cb4-2"></a>    println(<span class="st">&quot;xyx&quot;</span>.split(<span class="st">&quot;x&quot;</span>));</span>
<span id="cb4-3"><a href="#cb4-3"></a>}</span></code></pre></div>
<p>outputs</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb4-1"><a href="#cb4-1"></a>[, y, ]</span></code></pre></div>
</blockquote>
<p>Go:</p>
<blockquote>
<div class="sourceCode" id="cb5"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">package</span> main</span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="kw">import</span> <span class="st">&quot;fmt&quot;</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="kw">import</span> <span class="st">&quot;strings&quot;</span></span>
<span id="cb5-4"><a href="#cb5-4"></a></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="kw">func</span> main() {</span>
<span id="cb5-6"><a href="#cb5-6"></a>    fmt.Println(strings.Split(<span class="st">&quot;xyx&quot;</span>, <span class="st">&quot;x&quot;</span>));</span>
<span id="cb5-7"><a href="#cb5-7"></a>}</span></code></pre></div>
<p>outputs</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb5-1"><a href="#cb5-1"></a>[ y ]</span></code></pre></div>
</blockquote>
<p>JavaScript:</p>
<blockquote>
<div class="sourceCode" id="cb6"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb6-1"><a href="#cb6-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&#39;xyx&#39;</span><span class="op">.</span><span class="fu">split</span>(<span class="st">&#39;x&#39;</span>))</span></code></pre></div>
<p>outputs</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb6-1"><a href="#cb6-1"></a>[ &#39;&#39;, &#39;y&#39;, &#39;&#39; ]</span></code></pre></div>
</blockquote>
<p>And so on and so forth. What we see across these languages is that printing the result of split is pretty easy. In most cases, whatever the print mechanism is just works and does something meaningful. In other cases, printing gave me something other than what I wanted but some other easy, provided mechanism for doing so.</p>
<p>Now let’s consider C++.</p>
<blockquote>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="pp">#include </span><span class="im">&lt;ranges&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="pp">#include </span><span class="im">&lt;format&gt;</span></span>
<span id="cb7-5"><a href="#cb7-5"></a></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb7-7"><a href="#cb7-7"></a>    <span class="co">// need to predeclare this because we can&#39;t split an rvalue string</span></span>
<span id="cb7-8"><a href="#cb7-8"></a>    std<span class="op">::</span>string s <span class="op">=</span> <span class="st">&quot;xyx&quot;</span>;</span>
<span id="cb7-9"><a href="#cb7-9"></a>    <span class="kw">auto</span> parts <span class="op">=</span> s <span class="op">|</span> std<span class="op">::</span>views<span class="op">::</span>split<span class="op">(</span><span class="ch">&#39;x&#39;</span><span class="op">)</span>;</span>
<span id="cb7-10"><a href="#cb7-10"></a></span>
<span id="cb7-11"><a href="#cb7-11"></a>    <span class="co">// nope</span></span>
<span id="cb7-12"><a href="#cb7-12"></a>    std<span class="op">::</span>cout <span class="op">&lt;&lt;</span> parts;</span>
<span id="cb7-13"><a href="#cb7-13"></a></span>
<span id="cb7-14"><a href="#cb7-14"></a>    <span class="co">// nope (assuming std::print from P2093)</span></span>
<span id="cb7-15"><a href="#cb7-15"></a>    std<span class="op">::</span>print<span class="op">(</span><span class="st">&quot;{}&quot;</span>, parts<span class="op">)</span>;</span>
<span id="cb7-16"><a href="#cb7-16"></a></span>
<span id="cb7-17"><a href="#cb7-17"></a></span>
<span id="cb7-18"><a href="#cb7-18"></a>    std<span class="op">::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;[&quot;</span>;</span>
<span id="cb7-19"><a href="#cb7-19"></a>    <span class="dt">char</span> <span class="kw">const</span><span class="op">*</span> delim <span class="op">=</span> <span class="st">&quot;&quot;</span>;</span>
<span id="cb7-20"><a href="#cb7-20"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> part <span class="op">:</span> parts<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-21"><a href="#cb7-21"></a>        std<span class="op">::</span>cout <span class="op">&lt;&lt;</span> delim;</span>
<span id="cb7-22"><a href="#cb7-22"></a></span>
<span id="cb7-23"><a href="#cb7-23"></a>        <span class="co">// still nope</span></span>
<span id="cb7-24"><a href="#cb7-24"></a>        std<span class="op">::</span>cout <span class="op">&lt;&lt;</span> part;</span>
<span id="cb7-25"><a href="#cb7-25"></a></span>
<span id="cb7-26"><a href="#cb7-26"></a>        <span class="co">// also nope</span></span>
<span id="cb7-27"><a href="#cb7-27"></a>        std<span class="op">::</span>print<span class="op">(</span><span class="st">&quot;{}&quot;</span>, part<span class="op">)</span>;</span>
<span id="cb7-28"><a href="#cb7-28"></a></span>
<span id="cb7-29"><a href="#cb7-29"></a>        <span class="co">// this finally works</span></span>
<span id="cb7-30"><a href="#cb7-30"></a>        std<span class="op">::</span>ranges<span class="op">::</span>copy<span class="op">(</span>part, std<span class="op">::</span>ostream_iterator<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;(</span>std<span class="op">::</span>cout<span class="op">))</span>;</span>
<span id="cb7-31"><a href="#cb7-31"></a></span>
<span id="cb7-32"><a href="#cb7-32"></a>        <span class="co">// as does this</span></span>
<span id="cb7-33"><a href="#cb7-33"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">char</span> c <span class="op">:</span> part<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-34"><a href="#cb7-34"></a>            std<span class="op">::</span>cout <span class="op">&lt;&lt;</span> c;</span>
<span id="cb7-35"><a href="#cb7-35"></a>        <span class="op">}</span></span>
<span id="cb7-36"><a href="#cb7-36"></a>        delim <span class="op">=</span> <span class="st">&quot;, &quot;</span>;</span>
<span id="cb7-37"><a href="#cb7-37"></a>    <span class="op">}</span></span>
<span id="cb7-38"><a href="#cb7-38"></a>    std<span class="op">::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;]</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb7-39"><a href="#cb7-39"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>This took me more time to write than any of the solutions in any of the other languages. Including the Go solution, which contains 100% of all the lines of Go I’ve written in my life.</p>
<p>Printing is a fairly fundamental and universal mechanism to see what’s going on in your program. In the context of ranges, it’s probably the most useful way to see and understand what the various range adapters actually do. But none of these things provides an <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">&lt;&lt;</span></code> (for <code class="sourceCode cpp">std<span class="op">::</span>cout</code>) or a formatter specialization (for <code class="sourceCode cpp">format</code>). And the further problem is that as a user, I can’t even do anything about this. I can’t just provide an <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">&lt;&lt;</span></code> in <code class="sourceCode cpp"><span class="kw">namespace</span> std</code> or a very broad specialization of <code class="sourceCode cpp">formatter</code> - none of these are program-defined types, so it’s just asking for clashes once you start dealing with bigger programs.</p>
<p>The only mechanisms I have at my disposal to print something like this is either</p>
<ol type="1">
<li>nested loops with hand-written delimiter handling (which are tedious and a bad solution), or</li>
<li>at least replace the inner-most loop with a <code class="sourceCode cpp">ranges<span class="op">::</span>copy</code> into an output iterator (which is more differently bad), or</li>
<li>Write my own formatting library that I <em>am</em> allowed to specialize (which is not only bad but also ridiculous)</li>
<li>Use <code class="sourceCode cpp">fmt<span class="op">::</span>format</code>.</li>
</ol>
<h2 data-number="2.1" id="implementation-experience"><span class="header-section-number">2.1</span> Implementation Experience<a href="#implementation-experience" class="self-link"></a></h2>
<p>That’s right, there’s a fourth option for C++ that I haven’t shown yet, and that’s this:</p>
<blockquote>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="pp">#include </span><span class="im">&lt;ranges&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="pp">#include </span><span class="im">&lt;fmt/ranges.h&gt;</span></span>
<span id="cb8-4"><a href="#cb8-4"></a></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb8-6"><a href="#cb8-6"></a>    std<span class="op">::</span>string s <span class="op">=</span> <span class="st">&quot;xyx&quot;</span>;</span>
<span id="cb8-7"><a href="#cb8-7"></a>    <span class="kw">auto</span> parts <span class="op">=</span> s <span class="op">|</span> std<span class="op">::</span>views<span class="op">::</span>split<span class="op">(</span><span class="ch">&#39;x&#39;</span><span class="op">)</span>;</span>
<span id="cb8-8"><a href="#cb8-8"></a></span>
<span id="cb8-9"><a href="#cb8-9"></a>    fmt<span class="op">::</span>print<span class="op">(</span><span class="st">&quot;{}</span><span class="sc">\n</span><span class="st">&quot;</span>, parts<span class="op">)</span>;</span>
<span id="cb8-10"><a href="#cb8-10"></a>    fmt<span class="op">::</span>print<span class="op">(</span><span class="st">&quot;&lt;&lt;{}&gt;&gt;</span><span class="sc">\n</span><span class="st">&quot;</span>, fmt<span class="op">::</span>join<span class="op">(</span>parts, <span class="st">&quot;--&quot;</span><span class="op">))</span>;</span>
<span id="cb8-11"><a href="#cb8-11"></a><span class="op">}</span></span></code></pre></div>
<p>outputting</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb9-1"><a href="#cb9-1"></a>[[], [&#39;y&#39;], []]</span>
<span id="cb9-2"><a href="#cb9-2"></a>&lt;&lt;[]--[&#39;y&#39;]--[]&gt;&gt;</span></code></pre></div>
</blockquote>
<p>And this is great! It’s a single, easy line of code to just print arbitrary ranges (include ranges of ranges).</p>
<p>And, if I want to do something more involved, there’s also <code class="sourceCode cpp">fmt<span class="op">::</span>join</code>, which lets me specify both a format specifier and a delimiter. For instance:</p>
<blockquote>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a>std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">uint8_t</span><span class="op">&gt;</span> mac <span class="op">=</span> <span class="op">{</span><span class="bn">0xaa</span>, <span class="bn">0xbb</span>, <span class="bn">0xcc</span>, <span class="bn">0xdd</span>, <span class="bn">0xee</span>, <span class="bn">0xff</span><span class="op">}</span>;</span>
<span id="cb10-2"><a href="#cb10-2"></a>fmt<span class="op">::</span>print<span class="op">(</span><span class="st">&quot;{:02x}</span><span class="sc">\n</span><span class="st">&quot;</span>, fmt<span class="op">::</span>join<span class="op">(</span>mac, <span class="st">&quot;:&quot;</span><span class="op">))</span>;</span></code></pre></div>
<p>outputs</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb11-1"><a href="#cb11-1"></a>aa:bb:cc:dd:ee:ff</span></code></pre></div>
</blockquote>
<p><code class="sourceCode cpp">fmt<span class="op">::</span>format</code> (and <code class="sourceCode cpp">fmt<span class="op">::</span>print</code>) solves my problem completely. <code class="sourceCode cpp">std<span class="op">::</span>format</code> does not, and it should.</p>
<h1 data-number="3" style="border-bottom:1px solid #cccccc" id="proposal-considerations"><span class="header-section-number">3</span> Proposal Considerations<a href="#proposal-considerations" class="self-link"></a></h1>
<p>The Ranges Plan for C++23 <span class="citation" data-cites="P2214R1">[<a href="#ref-P2214R1" role="doc-biblioref">P2214R1</a>]</span> listed as one of its top priorities for C++23 as the ability to format all views. Let’s go through the issues we need to address in order to get this functionality.</p>
<h2 data-number="3.1" id="what-types-to-print"><span class="header-section-number">3.1</span> What types to print?<a href="#what-types-to-print" class="self-link"></a></h2>
<p>The standard library is the only library that can provide formatting support for standard library types and other broad classes of types like ranges. In addition to ranges (both the conrete containers like <code class="sourceCode cpp">vector<span class="op">&lt;</span>T<span class="op">&gt;</span></code> and the range adaptors like <code class="sourceCode cpp">views<span class="op">::</span>split</code>), there are several very commonly used types that are currently not printable.</p>
<p>The most common and important such types are <code class="sourceCode cpp">pair</code> and <code class="sourceCode cpp">tuple</code> (which ties back into Ranges even more closely once we adopt <code class="sourceCode cpp">views<span class="op">::</span>zip</code> and <code class="sourceCode cpp">views<span class="op">::</span>enumerate</code>). <code class="sourceCode cpp">fmt</code> currently supports printing such types as well:</p>
<blockquote>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a>fmt<span class="op">::</span>print<span class="op">(</span><span class="st">&quot;{}</span><span class="sc">\n</span><span class="st">&quot;</span>, std<span class="op">::</span>pair<span class="op">(</span><span class="dv">1</span>, <span class="dv">2</span><span class="op">))</span>;</span></code></pre></div>
<p>outputs</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb13-1"><a href="#cb13-1"></a>(1, 2)</span></code></pre></div>
</blockquote>
<p>Another common and important set of types are <code class="sourceCode cpp">std<span class="op">::</span>optional<span class="op">&lt;</span>T<span class="op">&gt;</span></code> and <code class="sourceCode cpp">std<span class="op">::</span>variant<span class="op">&lt;</span>Ts<span class="op">...&gt;</span></code>. <code class="sourceCode cpp">fmt</code> does not support printing any of the sum types. There is not an obvious representation for them in C++ as there might be in other languages (e.g. in Rust, an <code class="sourceCode cpp">Option<span class="op">&lt;</span>i32<span class="op">&gt;</span></code> prints as either <code class="sourceCode cpp">Some<span class="op">(</span><span class="dv">42</span><span class="op">)</span></code> or <code class="sourceCode cpp">None</code>, which is also the same syntax used to construct them).</p>
<p>However, the point here isn’t necessarily to produce the best possible representation (users who have very specific formatting needs will need to write custom code anyway), but rather to provide something useful. And it’d be useful to print these types as well. However, given that <code class="sourceCode cpp">optional</code> and <code class="sourceCode cpp">variant</code> are both less closely related to Ranges than <code class="sourceCode cpp">pair</code> and <code class="sourceCode cpp">tuple</code> and also have less obvious representation, they are less important.</p>
<h2 data-number="3.2" id="detecting-whether-a-type-is-formattable"><span class="header-section-number">3.2</span> Detecting whether a type is formattable<a href="#detecting-whether-a-type-is-formattable" class="self-link"></a></h2>
<p>We need to be able to conditionally provide formatters for generic types. <code class="sourceCode cpp">vector<span class="op">&lt;</span>T<span class="op">&gt;</span></code> needs to be formattable when <code class="sourceCode cpp">T</code> is formattable. <code class="sourceCode cpp">pair<span class="op">&lt;</span>T, U<span class="op">&gt;</span></code> needs to be formattable when <code class="sourceCode cpp">T</code> and <code class="sourceCode cpp">U</code> are formattable. In order to do this, we need to provide a proper <code class="sourceCode cpp"><span class="kw">concept</span></code> version of the formatter requirements that we already have.</p>
<p>This paper suggests the following:</p>
<blockquote>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="kw">class</span> charT<span class="op">&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="kw">concept</span> formattable <span class="op">=</span></span>
<span id="cb14-3"><a href="#cb14-3"></a>    semiregular<span class="op">&lt;</span>formatter<span class="op">&lt;</span>remove_cvref_t<span class="op">&lt;</span>T<span class="op">&gt;</span>, charT<span class="op">&gt;&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb14-4"><a href="#cb14-4"></a>    <span class="kw">requires</span> <span class="op">(</span>formatter<span class="op">&lt;</span>remove_cvref_t<span class="op">&lt;</span>T<span class="op">&gt;</span>, charT<span class="op">&gt;</span> f,</span>
<span id="cb14-5"><a href="#cb14-5"></a>              <span class="kw">const</span> formatter<span class="op">&lt;</span>remove_cvref_t<span class="op">&lt;</span>T<span class="op">&gt;</span>, charT<span class="op">&gt;</span> cf,</span>
<span id="cb14-6"><a href="#cb14-6"></a>              T t,</span>
<span id="cb14-7"><a href="#cb14-7"></a>              basic_format_context<span class="op">&lt;</span><em>fmt-iter-for</em><span class="op">&lt;</span>charT<span class="op">&gt;</span>, charT<span class="op">&gt;</span> fc,</span>
<span id="cb14-8"><a href="#cb14-8"></a>              basic_format_parse_context<span class="op">&lt;</span>charT<span class="op">&gt;</span> pc<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-9"><a href="#cb14-9"></a>        <span class="op">{</span> f<span class="op">.</span>parse<span class="op">(</span>pc<span class="op">)</span> <span class="op">}</span> <span class="op">-&gt;</span> same_as<span class="op">&lt;</span>basic_format_parse_context<span class="op">&lt;</span>charT<span class="op">&gt;::</span>iterator<span class="op">&gt;</span>;</span>
<span id="cb14-10"><a href="#cb14-10"></a>        <span class="op">{</span> cf<span class="op">.</span>format<span class="op">(</span>t, fc<span class="op">)</span> <span class="op">}</span> <span class="op">-&gt;</span> same_as<span class="op">&lt;</span><em>fmt-iter-for</em><span class="op">&lt;</span>charT<span class="op">&gt;&gt;</span>;</span>
<span id="cb14-11"><a href="#cb14-11"></a>    <span class="op">}</span>;</span></code></pre></div>
</blockquote>
<p>The broad shape of this concept is just taking the Formatter requirements and turning them into code. There are a few important things to note though:</p>
<ul>
<li>We don’t specify what the iterator type is of <code class="sourceCode cpp">format_context</code> or <code class="sourceCode cpp">wformat_context</code>, the expectation is that formatters accept any iterator. As such, it is unspecified in the concept <em>which</em> iterator will be checked - simply that it is <em>some</em> <code class="sourceCode cpp">output_iterator<span class="op">&lt;</span>charT <span class="kw">const</span><span class="op">&amp;&gt;</span></code>. Implementations could use <code class="sourceCode cpp">format_context<span class="op">::</span>iterator</code> and <code class="sourceCode cpp">wformat_context<span class="op">::</span>iterator</code>, or they could have a bespoke minimal iterator dedicated for concept checking.</li>
<li><code class="sourceCode cpp">cf<span class="op">.</span>format<span class="op">(</span>t, fc<span class="op">)</span></code> is called on a <code class="sourceCode cpp"><span class="kw">const</span></code> <code class="sourceCode cpp">formatter</code> (see <span class="citation" data-cites="LWG3636">[<a href="#ref-LWG3636" role="doc-biblioref">LWG3636</a>]</span>)</li>
<li><code class="sourceCode cpp">cf<span class="op">.</span>format<span class="op">(</span>t, fc<span class="op">)</span></code> is called specifically on <code class="sourceCode cpp">T</code>, not a <code class="sourceCode cpp"><span class="kw">const</span> T</code>. Even if the typical formatter specialization will take its object as <code class="sourceCode cpp"><span class="kw">const</span> T<span class="op">&amp;</span></code>. This is to handle cases like ranges that are not <code class="sourceCode cpp"><span class="kw">const</span></code>-iterable.</li>
<li><code class="sourceCode cpp">formattable<span class="op">&lt;</span>T, <span class="dt">char</span><span class="op">&gt;</span></code> and <code class="sourceCode cpp">formattable<span class="op">&lt;</span>T <span class="kw">const</span>, <span class="dt">char</span><span class="op">&gt;</span></code> could be different, which is important in order to probably know when a range or a <code class="sourceCode cpp">tuple</code> can be <code class="sourceCode cpp">formattable</code>.</li>
</ul>
<h2 data-number="3.3" id="what-representation"><span class="header-section-number">3.3</span> What representation?<a href="#what-representation" class="self-link"></a></h2>
<p>There are several questions to ask about what the representation should be for printing. I’ll go through each kind in turn.</p>
<h3 data-number="3.3.1" id="vector-and-other-ranges"><span class="header-section-number">3.3.1</span> <code class="sourceCode cpp">vector</code> (and other ranges)<a href="#vector-and-other-ranges" class="self-link"></a></h3>
<p>Should <code class="sourceCode cpp">std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;{</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span><span class="op">}</span></code> be printed as <code class="sourceCode cpp"><span class="op">{</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span><span class="op">}</span></code> or <code class="sourceCode cpp"><span class="op">[</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span><span class="op">]</span></code>? At the time of <span class="citation" data-cites="P2286R1">[<a href="#ref-P2286R1" role="doc-biblioref">P2286R1</a>]</span>, <code class="sourceCode cpp">fmt</code> used <code class="sourceCode cpp"><span class="op">{}</span></code>s but changed to use <code class="sourceCode cpp"><span class="op">[]</span></code>s for consistency with Python (<a href="https://github.com/fmtlib/fmt/commit/400b953fbb420ff1e47565303c64223445a51955">400b953f</a>).</p>
<p>Even though in C++ we initialize <code class="sourceCode cpp">vector</code>s (and, generally, other containers as well) with <code class="sourceCode cpp"><span class="op">{}</span></code>s while Python’s uses <code class="sourceCode cpp"><span class="op">[</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span><span class="op">]</span></code> (and likewise Rust has <code class="sourceCode cpp">vec<span class="op">![</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span><span class="op">]</span></code>), <code class="sourceCode cpp"><span class="op">[]</span></code> is typical representationally so seems like the clear best choice here.</p>
<h3 data-number="3.3.2" id="pair-and-tuple"><span class="header-section-number">3.3.2</span> <code class="sourceCode cpp">pair</code> and <code class="sourceCode cpp">tuple</code><a href="#pair-and-tuple" class="self-link"></a></h3>
<p>Should <code class="sourceCode cpp">std<span class="op">::</span>pair<span class="op">&lt;</span><span class="dt">int</span>, <span class="dt">int</span><span class="op">&gt;{</span><span class="dv">4</span>, <span class="dv">5</span><span class="op">}</span></code> be printed as <code class="sourceCode cpp"><span class="op">{</span><span class="dv">4</span>, <span class="dv">5</span><span class="op">}</span></code> or <code class="sourceCode cpp"><span class="op">(</span><span class="dv">4</span>, <span class="dv">5</span><span class="op">)</span></code>? Here, either syntax can claim to be the syntax used to initialize the <code class="sourceCode cpp">pair</code>/<code class="sourceCode cpp">tuple</code>. <code class="sourceCode cpp">fmt</code> has always printed these types with <code class="sourceCode cpp"><span class="op">()</span></code>s, and this is also how Python and Rust print such types. As with using <code class="sourceCode cpp"><span class="op">[]</span></code> for ranges, <code class="sourceCode cpp"><span class="op">()</span></code> seems like the common representation for tuples and so seems like the clear best choice.</p>
<h3 data-number="3.3.3" id="map-and-set-and-other-associative-containers"><span class="header-section-number">3.3.3</span> <code class="sourceCode cpp">map</code> and <code class="sourceCode cpp">set</code> (and other associative containers)<a href="#map-and-set-and-other-associative-containers" class="self-link"></a></h3>
<p>Should <code class="sourceCode cpp">std<span class="op">::</span>map<span class="op">&lt;</span><span class="dt">int</span>, <span class="dt">int</span><span class="op">&gt;{</span>{<span class="dv">1</span>, <span class="dv">2</span><span class="op">}</span>, <span class="op">{</span><span class="dv">3</span>, <span class="dv">4</span><span class="op">}}</span></code> be printed as <code class="sourceCode cpp"><span class="op">[(</span><span class="dv">1</span>, <span class="dv">2</span><span class="op">)</span>, <span class="op">(</span><span class="dv">3</span>, <span class="dv">4</span><span class="op">)]</span></code> (as follows directly from the two previous choices) or as <code class="sourceCode cpp"><span class="op">{</span><span class="dv">1</span><span class="op">:</span> <span class="dv">2</span>, <span class="dv">3</span><span class="op">:</span> <span class="dv">4</span><span class="op">}</span></code> (which makes the <em>association</em> clearer in the printing)? Both Python and Rust print their associating containers this latter way.</p>
<p>The same question holds for sets as well as maps, it’s just a question for whether <code class="sourceCode cpp">std<span class="op">::</span>set<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;{</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span><span class="op">}</span></code> prints as <code class="sourceCode cpp"><span class="op">[</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span><span class="op">]</span></code> (i.e. as any other range of <code class="sourceCode cpp"><span class="dt">int</span></code>) or <code class="sourceCode cpp"><span class="op">{</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span><span class="op">}</span></code>?</p>
<p>If we print <code class="sourceCode cpp">map</code>s as any other range of pairs, there’s nothing left to do. If we print <code class="sourceCode cpp">map</code>s as associations, then we additionally have to answer the question of how user-defined associative containers can get printed in the same way. This paper proposes printing the standard library maps as <code class="sourceCode cpp"><span class="op">{</span><span class="dv">1</span><span class="op">:</span> <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span><span class="op">}</span></code> and the standard library sets as <code class="sourceCode cpp"><span class="op">{</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span><span class="op">}</span></code>.</p>
<h3 data-number="3.3.4" id="char-and-string-and-other-string-like-types-in-ranges-or-tuples"><span class="header-section-number">3.3.4</span> <code class="sourceCode cpp"><span class="dt">char</span></code> and <code class="sourceCode cpp">string</code> (and other string-like types) in ranges or tuples<a href="#char-and-string-and-other-string-like-types-in-ranges-or-tuples" class="self-link"></a></h3>
<p>Should <code class="sourceCode cpp">pair<span class="op">&lt;</span><span class="dt">char</span>, string<span class="op">&gt;(</span><span class="ch">&#39;x&#39;</span>, <span class="st">&quot;hello&quot;</span><span class="op">)</span></code> print as <code class="x">(x, hello)</code> or <code class="x">(&#39;x&#39;, &quot;hello&quot;)</code>? Should <code class="sourceCode cpp">pair<span class="op">&lt;</span><span class="dt">char</span>, string<span class="op">&gt;(</span><span class="ch">&#39;y&#39;</span>, <span class="st">&quot;with</span><span class="sc">\n\&quot;</span><span class="st">quotes</span><span class="sc">\&quot;</span><span class="st">&quot;</span><span class="op">)</span></code> print as:</p>
<blockquote>
<div class="sourceCode" id="cb15"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb15-1"><a href="#cb15-1"></a>(y, with</span>
<span id="cb15-2"><a href="#cb15-2"></a>&quot;quotes&quot;)</span></code></pre></div>
</blockquote>
<p>or</p>
<blockquote>
<div class="sourceCode" id="cb16"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb16-1"><a href="#cb16-1"></a>(&#39;y&#39;, &quot;with\n\&quot;quotes\&quot;&quot;)</span></code></pre></div>
</blockquote>
<p>While <code class="sourceCode cpp"><span class="dt">char</span></code> and <code class="sourceCode cpp">string</code> are typically printed unquoted, it is quite common to print them quoted when contained in tuples and ranges. This makes it obvious what the actual elements of the range and tuple are even when the string/char contains characters like comma or space. Python, Rust, and <code class="sourceCode cpp">fmt</code> all do this. Rust escapes internal strings, so prints as <code class="sourceCode cpp"><span class="op">(</span><span class="ch">&#39;y&#39;</span>, <span class="st">&quot;with</span><span class="sc">\n\&quot;</span><span class="st">quotes</span><span class="sc">\&quot;</span><span class="st">&quot;</span><span class="op">)</span></code> (the Rust implementation of <code class="sourceCode cpp">Debug</code> for <code class="sourceCode cpp">str</code> can be found <a href="https://doc.rust-lang.org/src/core/fmt/mod.rs.html#2129-2151">here</a> which is implemented in terms of <a href="https://doc.rust-lang.org/src/core/char/methods.rs.html#417-432"><code class="sourceCode cpp">escape_debug_ext</code></a>). Following discussion of this paper and this design, Victor Zverovich implemented in this <code class="sourceCode cpp">fmt</code> as well.</p>
<p>Escaping is the most desirable default behavior, and the specific escaping behavior is described <a href="#escaping-behavior">here</a>.</p>
<p>Also, <code class="sourceCode cpp">std<span class="op">::</span>string</code> isn’t the only string-like type: if we decide to print strings quoted, how do users opt in to this behavior for their own string-like types? And <code class="sourceCode cpp"><span class="dt">char</span></code> and <code class="sourceCode cpp">string</code> aren’t the only types that may desire to have some kind of <em>debug</em> format and some kind of regular format, how to differentiate those?</p>
<p>Moreover, it’s all well and good to have the default formatting option for a range or tuple of strings to be printing those strings escaped. But what if users want to print a range of strings <em>unescaped</em>? I’ll get back to this.</p>
<h3 data-number="3.3.5" id="filesystempath"><span class="header-section-number">3.3.5</span> <code class="sourceCode cpp">filesystem<span class="op">::</span>path</code><a href="#filesystempath" class="self-link"></a></h3>
<p>We have a paper, <span class="citation" data-cites="P1636R2">[<a href="#ref-P1636R2" role="doc-biblioref">P1636R2</a>]</span>, that proposes <code class="sourceCode cpp">formatter</code> specializations for a different subset of library types: <code class="sourceCode cpp">basic_streambuf</code>, <code class="sourceCode cpp">bitset</code>, <code class="sourceCode cpp">complex</code>, <code class="sourceCode cpp">error_code</code>, <code class="sourceCode cpp">filesystem<span class="op">::</span>path</code>, <code class="sourceCode cpp">shared_ptr</code>, <code class="sourceCode cpp">sub_match</code>, <code class="sourceCode cpp">thread<span class="op">::</span>id</code>, and <code class="sourceCode cpp">unique_ptr</code>. Most of those are neither ranges nor tuples, so that paper doesn’t overlap with this one.</p>
<p>Except for one: <code class="sourceCode cpp">filesystem<span class="op">::</span>path</code>.</p>
<p>During the <a href="https://github.com/sg16-unicode/sg16-meetings#september-22nd-2021">SG16 discussion of P1636</a>, they took a poll that:</p>
<blockquote>
<p>Poll 1: Recommend removing the filesystem::path formatter from P1636 “Formatters for library types”, and specifically disabling filesystem::path formatting in P2286 “Formatting ranges”, pending a proposal with specific design for how to format paths properly.</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>SF</strong>
</div></th>
<th><div style="text-align:center">
<strong>F</strong>
</div></th>
<th><div style="text-align:center">
<strong>A</strong>
</div></th>
<th><div style="text-align:center">
<strong>N</strong>
</div></th>
<th><div style="text-align:center">
<strong>SA</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>5</td>
<td>5</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
</blockquote>
<p><code class="sourceCode cpp">filesystem<span class="op">::</span>path</code> is kind of an interesting range, since it’s a range of <code class="sourceCode cpp">path</code>. As such, checking to see if it would be formattable as this paper currently does would lead to constraint recursion:</p>
<blockquote>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">template</span> <span class="op">&lt;</span>input_range R<span class="op">&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2"></a>    <span class="kw">requires</span> formattable<span class="op">&lt;</span>range_reference_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;</span></span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="kw">struct</span> formatter<span class="op">&lt;</span>R<span class="op">&gt;</span></span>
<span id="cb17-4"><a href="#cb17-4"></a>    <span class="op">:</span> range_formatter<span class="op">&lt;</span>range_reference_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;</span></span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="op">{</span> <span class="op">}</span>;</span></code></pre></div>
</blockquote>
<p>For <code class="sourceCode cpp">R<span class="op">=</span>filesystem<span class="op">::</span>path</code>, <code class="sourceCode cpp">range_reference_t<span class="op">&lt;</span>R<span class="op">&gt;</span></code> is also <code class="sourceCode cpp">filesystem<span class="op">::</span>path</code>. Which means that our constraint for <code class="sourceCode cpp">formatter<span class="op">&lt;</span>fs<span class="op">::</span>path<span class="op">&gt;</span></code> requires <code class="sourceCode cpp">formattable<span class="op">&lt;</span>fs<span class="op">::</span>path<span class="op">&gt;</span></code> Looking at the <a href="#detecting-whether-a-type-is-formattable">suggested concept</a>, the first check we will do is to verify that <code class="sourceCode cpp">formatter<span class="op">&lt;</span>fs<span class="op">::</span>path<span class="op">&gt;</span></code> is <code class="sourceCode cpp">semiregular</code>. But we’re currently in the process of instantiating <code class="sourceCode cpp">formatter<span class="op">&lt;</span>fs<span class="op">::</span>path<span class="op">&gt;</span></code>, it is still incomplete. Hard error.</p>
<p>In order to handle this case properly, we could do what SG16 suggested:</p>
<blockquote>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">template</span> <span class="op">&lt;&gt;</span></span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="kw">struct</span> formatter<span class="op">&lt;</span>filesystem<span class="op">::</span>path<span class="op">&gt;</span>;</span></code></pre></div>
</blockquote>
<p>But this only handles <code class="sourceCode cpp">std<span class="op">::</span>filesystem<span class="op">::</span>path</code> and would not handle other ranges-of-self (the obvious example here is <code class="sourceCode cpp">boost<span class="op">::</span>filesystem<span class="op">::</span>path</code>). So instead, this paper proposes that we first reject ranges-of-self:</p>
<blockquote>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1"></a><span class="kw">template</span> <span class="op">&lt;</span>input_range R<span class="op">&gt;</span></span>
<span id="cb19-2"><a href="#cb19-2"></a>    <span class="kw">requires</span> <span class="op">(</span><span class="kw">not</span> same_as<span class="op">&lt;</span>remove_cvref_t<span class="op">&lt;</span>range_reference_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;</span>, R<span class="op">&gt;)</span></span>
<span id="cb19-3"><a href="#cb19-3"></a>         <span class="kw">and</span> formattable<span class="op">&lt;</span>range_reference_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;</span></span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="kw">struct</span> formatter<span class="op">&lt;</span>R<span class="op">&gt;</span></span>
<span id="cb19-5"><a href="#cb19-5"></a>    <span class="op">:</span> range_formatter<span class="op">&lt;</span>range_reference_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;</span></span>
<span id="cb19-6"><a href="#cb19-6"></a><span class="op">{</span> <span class="op">}</span>;</span></code></pre></div>
</blockquote>
<h3 data-number="3.3.6" id="format-specifiers"><span class="header-section-number">3.3.6</span> Format Specifiers<a href="#format-specifiers" class="self-link"></a></h3>
<p>One of (but hardly the only) the great selling points of <code class="sourceCode cpp">format</code> over iostreams is the ability to use specifiers. For instance, from the <code class="sourceCode cpp">fmt</code> documentation:</p>
<blockquote>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1"></a>fmt<span class="op">::</span>format<span class="op">(</span><span class="st">&quot;{:&lt;30}&quot;</span>, <span class="st">&quot;left aligned&quot;</span><span class="op">)</span>;</span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="co">// Result: &quot;left aligned                  &quot;</span></span>
<span id="cb20-3"><a href="#cb20-3"></a>fmt<span class="op">::</span>format<span class="op">(</span><span class="st">&quot;{:&gt;30}&quot;</span>, <span class="st">&quot;right aligned&quot;</span><span class="op">)</span>;</span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="co">// Result: &quot;                 right aligned&quot;</span></span>
<span id="cb20-5"><a href="#cb20-5"></a>fmt<span class="op">::</span>format<span class="op">(</span><span class="st">&quot;{:^30}&quot;</span>, <span class="st">&quot;centered&quot;</span><span class="op">)</span>;</span>
<span id="cb20-6"><a href="#cb20-6"></a><span class="co">// Result: &quot;           centered           &quot;</span></span>
<span id="cb20-7"><a href="#cb20-7"></a>fmt<span class="op">::</span>format<span class="op">(</span><span class="st">&quot;{:*^30}&quot;</span>, <span class="st">&quot;centered&quot;</span><span class="op">)</span>;  <span class="co">// use &#39;*&#39; as a fill char</span></span>
<span id="cb20-8"><a href="#cb20-8"></a><span class="co">// Result: &quot;***********centered***********&quot;</span></span></code></pre></div>
</blockquote>
<p>Earlier revisions of this paper suggested that formatting ranges and tuples would accept no format specifiers, but there indeed are quite a few things we may want to do here (as by Tomasz Kamiński and Peter Dimov):</p>
<ul>
<li>Formatting a range of pairs as a map (the <code class="sourceCode cpp">key<span class="op">:</span> value</code> syntax rather than the <code class="sourceCode cpp"><span class="op">(</span>key, value<span class="op">)</span></code> one)</li>
<li>Formatting a range of chars as a string (i.e. to print <code class="x">hello</code> or <code class="x">&quot;hello&quot;</code> rather than <code class="x">[&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]</code>)</li>
</ul>
<p>But these are just providing a specifier for how we format the range itself. How about how we format the elements of the range? Can I conveniently format a range of integers, printing their values as hex? Or as characters? Or print a range of chrono time points in whatever format I want? That’s fairly powerful.</p>
<p>The problem is how do we actually <em>do that</em>. After a lengthy discussion with Peter Dimov, Tim Song, and Victor Zverovich, this is what we came up with. I’ll start with a table of examples and follow up with a more detailed explanation.</p>
<p>Instead of writing a bunch of examples like <code class="sourceCode cpp">print<span class="op">(</span><span class="st">&quot;{:?}</span><span class="sc">\n</span><span class="st">&quot;</span>, v<span class="op">)</span></code>, I’m just displaying the format string in one column (the <code class="sourceCode cpp"><span class="st">&quot;{:?}&quot;</span></code> here) and the argument in another (the <code class="sourceCode cpp">v</code>):</p>
<table>
<colgroup>
<col style="width: 14%"></col>
<col style="width: 42%"></col>
<col style="width: 42%"></col>
</colgroup>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Format String</strong>
</div></th>
<th><div style="text-align:center">
<strong>Contents</strong>
</div></th>
<th><div style="text-align:center">
<strong>Formatted Output</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="x">{:}</code></td>
<td><code class="sourceCode cpp"><span class="dv">42</span></code></td>
<td><code class="x">42</code></td>
</tr>
<tr class="even">
<td><code class="x">{:#x}</code></td>
<td><code class="sourceCode cpp"><span class="dv">42</span></code></td>
<td><code class="x">0x2a</code></td>
</tr>
<tr class="odd">
<td><code class="x">{}</code></td>
<td><code class="sourceCode cpp"><span class="st">&quot;h</span><span class="sc">\t</span><span class="st">llo&quot;</span><span class="bu">s</span></code></td>
<td><code class="x">h    llo</code></td>
</tr>
<tr class="even">
<td><code class="x">{:?}</code></td>
<td><code class="sourceCode cpp"><span class="st">&quot;h</span><span class="sc">\t</span><span class="st">llo&quot;</span><span class="bu">s</span></code></td>
<td><code class="x">&quot;h\tllo&quot;</code></td>
</tr>
<tr class="odd">
<td><code class="x">{}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">{</span><span class="st">&quot;h</span><span class="sc">\t</span><span class="st">llo&quot;</span><span class="bu">s</span>, <span class="st">&quot;world&quot;</span><span class="bu">s</span><span class="op">}</span></code></td>
<td><code class="x">[&quot;h\tllo&quot;, &quot;world&quot;]</code></td>
</tr>
<tr class="even">
<td><code class="x">{:}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">{</span><span class="st">&quot;h</span><span class="sc">\t</span><span class="st">llo&quot;</span><span class="bu">s</span>, <span class="st">&quot;world&quot;</span><span class="bu">s</span><span class="op">}</span></code></td>
<td><code class="x">[&quot;h\tllo&quot;, &quot;world&quot;]</code></td>
</tr>
<tr class="odd">
<td><code class="x">{::}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">{</span><span class="st">&quot;h</span><span class="sc">\t</span><span class="st">llo&quot;</span><span class="bu">s</span>, <span class="st">&quot;world&quot;</span><span class="bu">s</span><span class="op">}</span></code></td>
<td><code class="x">[h    llo, world]</code></td>
</tr>
<tr class="even">
<td><code class="x">{:*^14}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">{</span><span class="st">&quot;he&quot;</span><span class="bu">s</span>, <span class="st">&quot;wo&quot;</span><span class="bu">s</span><span class="op">}</span></code></td>
<td><code class="x">*[&quot;he&quot;, &quot;wo&quot;]*</code></td>
</tr>
<tr class="odd">
<td><code class="x">{::*^14}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">{</span><span class="st">&quot;he&quot;</span><span class="bu">s</span>, <span class="st">&quot;wo&quot;</span><span class="bu">s</span><span class="op">}</span></code></td>
<td><code class="x">[******he******, ******wo******]</code></td>
</tr>
<tr class="even">
<td><code class="x">{}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;{</span><span class="ch">&#39;H&#39;</span>, <span class="ch">&#39;</span><span class="sc">\t</span><span class="ch">&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;o&#39;</span><span class="op">}</span></code></td>
<td><code class="x">[&#39;H&#39;, &#39;\t&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]</code></td>
</tr>
<tr class="odd">
<td><code class="x">{::}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;{</span><span class="ch">&#39;H&#39;</span>, <span class="ch">&#39;</span><span class="sc">\t</span><span class="ch">&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;o&#39;</span><span class="op">}</span></code></td>
<td><code class="x">[H,     , l, l, o]</code></td>
</tr>
<tr class="even">
<td><code class="x">{::c}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;{</span><span class="ch">&#39;H&#39;</span>, <span class="ch">&#39;</span><span class="sc">\t</span><span class="ch">&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;o&#39;</span><span class="op">}</span></code></td>
<td><code class="x">[H,     , l, l, o]</code></td>
</tr>
<tr class="odd">
<td><code class="x">{::?}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;{</span><span class="ch">&#39;H&#39;</span>, <span class="ch">&#39;</span><span class="sc">\t</span><span class="ch">&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;o&#39;</span><span class="op">}</span></code></td>
<td><code class="x">[&#39;H&#39;, &#39;\t&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]</code></td>
</tr>
<tr class="even">
<td><code class="x">{::d}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;{</span><span class="ch">&#39;H&#39;</span>, <span class="ch">&#39;</span><span class="sc">\t</span><span class="ch">&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;o&#39;</span><span class="op">}</span></code></td>
<td><code class="x">[72, 9, 108, 108, 111]</code></td>
</tr>
<tr class="odd">
<td><code class="x">{::#x}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;{</span><span class="ch">&#39;H&#39;</span>, <span class="ch">&#39;</span><span class="sc">\t</span><span class="ch">&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;o&#39;</span><span class="op">}</span></code></td>
<td><code class="x">[0x48, 0x9, 0x6c, 0x6c, 0x6f]</code></td>
</tr>
<tr class="even">
<td><code class="x">{:s}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;{</span><span class="ch">&#39;H&#39;</span>, <span class="ch">&#39;</span><span class="sc">\t</span><span class="ch">&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;o&#39;</span><span class="op">}</span></code></td>
<td><code class="x">H    llo</code></td>
</tr>
<tr class="odd">
<td><code class="x">{:?s}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;{</span><span class="ch">&#39;H&#39;</span>, <span class="ch">&#39;</span><span class="sc">\t</span><span class="ch">&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;o&#39;</span><span class="op">}</span></code></td>
<td><code class="x">&quot;H\tllo&quot;</code></td>
</tr>
<tr class="even">
<td><code class="x">{}</code></td>
<td><code class="sourceCode cpp">pair<span class="op">{</span><span class="dv">42</span>, <span class="st">&quot;h</span><span class="sc">\t</span><span class="st">llo&quot;</span><span class="bu">s</span><span class="op">}</span></code></td>
<td><code class="x">(42, &quot;h\tllo&quot;)</code></td>
</tr>
<tr class="odd">
<td><code class="x">{}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">{</span>pair<span class="op">{</span><span class="dv">42</span>, <span class="st">&quot;h</span><span class="sc">\t</span><span class="st">llo&quot;</span><span class="bu">s</span><span class="op">}}</span></code></td>
<td><code class="x">[(42, &quot;h\tllo&quot;)]</code></td>
</tr>
<tr class="even">
<td><code class="x">{:m}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">{</span>pair<span class="op">{</span><span class="dv">42</span>, <span class="st">&quot;h</span><span class="sc">\t</span><span class="st">llo&quot;</span><span class="bu">s</span><span class="op">}}</span></code></td>
<td><code class="x">{42: &quot;h\tllo&quot;}</code></td>
</tr>
<tr class="odd">
<td><code class="x">{:m:}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">{</span>pair<span class="op">{</span><span class="dv">42</span>, <span class="st">&quot;h</span><span class="sc">\t</span><span class="st">llo&quot;</span><span class="bu">s</span><span class="op">}}</span></code></td>
<td><code class="x">{42: h    llo}</code></td>
</tr>
<tr class="even">
<td><code class="x">{}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">{</span>vector<span class="op">{</span><span class="ch">&#39;a&#39;</span><span class="op">}</span>, vector<span class="op">{</span><span class="ch">&#39;b&#39;</span>, <span class="ch">&#39;c&#39;</span><span class="op">}}</span></code></td>
<td><code class="x">[[&#39;a&#39;], [&#39;b&#39;, &#39;c&#39;]]</code></td>
</tr>
<tr class="odd">
<td><code class="x">{::?s}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">{</span>vector<span class="op">{</span><span class="ch">&#39;a&#39;</span><span class="op">}</span>, vector<span class="op">{</span><span class="ch">&#39;b&#39;</span>, <span class="ch">&#39;c&#39;</span><span class="op">}}</span></code></td>
<td><code class="x">[&quot;a&quot;, &quot;bc&quot;]</code></td>
</tr>
<tr class="even">
<td><code class="x">{:::d}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">{</span>vector<span class="op">{</span><span class="ch">&#39;a&#39;</span><span class="op">}</span>, vector<span class="op">{</span><span class="ch">&#39;b&#39;</span>, <span class="ch">&#39;c&#39;</span><span class="op">}}</span></code></td>
<td><code class="x">[[97], [98, 99]]</code></td>
</tr>
</tbody>
</table>
<h3 data-number="3.3.7" id="explanation-of-added-specifiers"><span class="header-section-number">3.3.7</span> Explanation of Added Specifiers<a href="#explanation-of-added-specifiers" class="self-link"></a></h3>
<h4 data-number="3.3.7.1" id="the-debug-specifier"><span class="header-section-number">3.3.7.1</span> The debug specifier <code class="sourceCode cpp"><span class="op">?</span></code><a href="#the-debug-specifier" class="self-link"></a></h4>
<p><code class="sourceCode cpp"><span class="dt">char</span></code> and <code class="sourceCode cpp">string</code> and <code class="sourceCode cpp">string_view</code> will start to support the <code class="sourceCode cpp"><span class="op">?</span></code> specifier. This will cause the character/string to be printed as quoted (characters with <code class="sourceCode cpp"><span class="ch">&#39;</span></code> and strings with <code class="sourceCode cpp"><span class="st">&quot;</span></code>) and all characters to be escaped, as <a href="char-and-string-and-other-string-like-types-in-ranges-or-tuples">described earlier</a>.</p>
<p>This facility will be generated by the formatters for these types providing an addition member function (on top of <code class="sourceCode cpp">parse</code> and <code class="sourceCode cpp">format</code>):</p>
<blockquote>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">constexpr</span> <span class="dt">void</span> set_debug_format<span class="op">()</span>;</span></code></pre></div>
</blockquote>
<p>Which other formatting types may conditionally invoke when they parse a <code class="sourceCode cpp"><span class="op">?</span></code>. For instance, since the intent is that range formatters print escaped by default, the logic for a simple range formatter that accepts no specifiers might look like this (note that this paper is proposing something more complicated than this, this is just an example):</p>
<blockquote>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> V<span class="op">&gt;</span></span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="kw">struct</span> range_formatter <span class="op">{</span></span>
<span id="cb22-3"><a href="#cb22-3"></a>    std<span class="op">::</span>formatter<span class="op">&lt;</span>V<span class="op">&gt;</span> underlying;</span>
<span id="cb22-4"><a href="#cb22-4"></a></span>
<span id="cb22-5"><a href="#cb22-5"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> ParseContext<span class="op">&gt;</span></span>
<span id="cb22-6"><a href="#cb22-6"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> parse<span class="op">(</span>ParseContext<span class="op">&amp;</span> ctx<span class="op">)</span> <span class="op">{</span></span>
<span id="cb22-7"><a href="#cb22-7"></a>        <span class="co">// ensure that the format specifier is empty</span></span>
<span id="cb22-8"><a href="#cb22-8"></a>        <span class="cf">if</span> <span class="op">(</span>ctx<span class="op">.</span>begin<span class="op">()</span> <span class="op">!=</span> ctx<span class="op">.</span>end<span class="op">()</span> <span class="op">&amp;&amp;</span> <span class="op">*</span>ctx<span class="op">.</span>begin<span class="op">()</span> <span class="op">!=</span> <span class="ch">&#39;}&#39;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb22-9"><a href="#cb22-9"></a>            <span class="cf">throw</span> std<span class="op">::</span>format_error<span class="op">(</span><span class="st">&quot;invalid format&quot;</span><span class="op">)</span>;</span>
<span id="cb22-10"><a href="#cb22-10"></a>        <span class="op">}</span></span>
<span id="cb22-11"><a href="#cb22-11"></a></span>
<span id="cb22-12"><a href="#cb22-12"></a>        <span class="co">// ensure that the underlying type can parse an empty specifier</span></span>
<span id="cb22-13"><a href="#cb22-13"></a>        <span class="kw">auto</span> out <span class="op">=</span> underlying<span class="op">.</span>parse<span class="op">(</span>ctx<span class="op">)</span>;</span>
<span id="cb22-14"><a href="#cb22-14"></a></span>
<span id="cb22-15"><a href="#cb22-15"></a>        <span class="co">// conditionally format as debug, if the type supports it</span></span>
<span id="cb22-16"><a href="#cb22-16"></a>        <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span><span class="kw">requires</span> <span class="op">{</span> underlying<span class="op">.</span>set_debug_format<span class="op">()</span>; <span class="op">})</span> <span class="op">{</span></span>
<span id="cb22-17"><a href="#cb22-17"></a>            underlying<span class="op">.</span>set_debug_format<span class="op">()</span>;</span>
<span id="cb22-18"><a href="#cb22-18"></a>        <span class="op">}</span></span>
<span id="cb22-19"><a href="#cb22-19"></a>        <span class="cf">return</span> out;</span>
<span id="cb22-20"><a href="#cb22-20"></a>    <span class="op">}</span></span>
<span id="cb22-21"><a href="#cb22-21"></a></span>
<span id="cb22-22"><a href="#cb22-22"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> R, <span class="kw">typename</span> FormatContext<span class="op">&gt;</span></span>
<span id="cb22-23"><a href="#cb22-23"></a>        <span class="kw">requires</span> std<span class="op">::</span>same_as<span class="op">&lt;</span>std<span class="op">::</span>remove_cvref_t<span class="op">&lt;</span>std<span class="op">::</span>ranges<span class="op">::</span>range_reference_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;</span>, V<span class="op">&gt;</span></span>
<span id="cb22-24"><a href="#cb22-24"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> format<span class="op">(</span>R<span class="op">&amp;&amp;</span> r, FormatContext<span class="op">&amp;</span> ctx<span class="op">)</span> <span class="kw">const</span> <span class="op">{</span></span>
<span id="cb22-25"><a href="#cb22-25"></a>        <span class="kw">auto</span> out <span class="op">=</span> ctx<span class="op">.</span>out<span class="op">()</span>;</span>
<span id="cb22-26"><a href="#cb22-26"></a>        <span class="op">*</span>out<span class="op">++</span> <span class="op">=</span> <span class="ch">&#39;[&#39;</span>;</span>
<span id="cb22-27"><a href="#cb22-27"></a>        <span class="kw">auto</span> first <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>begin<span class="op">(</span>r<span class="op">)</span>;</span>
<span id="cb22-28"><a href="#cb22-28"></a>        <span class="kw">auto</span> last <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>end<span class="op">(</span>r<span class="op">)</span>;</span>
<span id="cb22-29"><a href="#cb22-29"></a>        <span class="cf">if</span> <span class="op">(</span>first <span class="op">!=</span> last<span class="op">)</span> <span class="op">{</span></span>
<span id="cb22-30"><a href="#cb22-30"></a>            <span class="co">// have to format every element via the underlying formatter</span></span>
<span id="cb22-31"><a href="#cb22-31"></a>            ctx<span class="op">.</span>advance_to<span class="op">(</span>std<span class="op">::</span>move<span class="op">(</span>out<span class="op">))</span>;</span>
<span id="cb22-32"><a href="#cb22-32"></a>            out <span class="op">=</span> underlying<span class="op">.</span>format<span class="op">(*</span>first, ctx<span class="op">)</span>;</span>
<span id="cb22-33"><a href="#cb22-33"></a>            <span class="cf">for</span> <span class="op">(++</span>first; first <span class="op">!=</span> last; <span class="op">++</span>first<span class="op">)</span> <span class="op">{</span></span>
<span id="cb22-34"><a href="#cb22-34"></a>                <span class="op">*</span>out<span class="op">++</span> <span class="op">=</span> <span class="ch">&#39;,&#39;</span>;</span>
<span id="cb22-35"><a href="#cb22-35"></a>                <span class="op">*</span>out<span class="op">++</span> <span class="op">=</span> <span class="ch">&#39; &#39;</span>;</span>
<span id="cb22-36"><a href="#cb22-36"></a>                ctx<span class="op">.</span>advance_to<span class="op">(</span>std<span class="op">::</span>move<span class="op">(</span>out<span class="op">))</span>;</span>
<span id="cb22-37"><a href="#cb22-37"></a>                out <span class="op">=</span> underlying<span class="op">.</span>format<span class="op">(*</span>first, ctx<span class="op">)</span>;</span>
<span id="cb22-38"><a href="#cb22-38"></a>            <span class="op">}</span></span>
<span id="cb22-39"><a href="#cb22-39"></a>        <span class="op">}</span></span>
<span id="cb22-40"><a href="#cb22-40"></a>        <span class="op">*</span>out<span class="op">++</span> <span class="op">=</span> <span class="ch">&#39;]&#39;</span>;</span>
<span id="cb22-41"><a href="#cb22-41"></a>        <span class="cf">return</span> out;</span>
<span id="cb22-42"><a href="#cb22-42"></a>    <span class="op">}</span></span>
<span id="cb22-43"><a href="#cb22-43"></a><span class="op">}</span>;</span></code></pre></div>
</blockquote>
<h4 data-number="3.3.7.2" id="range-specifiers"><span class="header-section-number">3.3.7.2</span> Range specifiers<a href="#range-specifiers" class="self-link"></a></h4>
<p>Range format specifiers come in two kinds: specifiers for the range itself and specifiers for the underlying elements of the range. They must be provided in order: the range specifiers (optionally), then if desired, a colon and then the underlying specifier (optionally).</p>
<p>Some examples:</p>
<table>
<colgroup>
<col style="width: 20%"></col>
<col style="width: 80%"></col>
</colgroup>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>specifier</strong>
</div></th>
<th><div style="text-align:center">
<strong>meaning</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="x">{}</code></td>
<td>No specifiers</td>
</tr>
<tr class="even">
<td><code class="x">{:}</code></td>
<td>No specifiers</td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="op">{:&lt;</span><span class="dv">10</span><span class="op">}</span></code></td>
<td>The whole range formatting is left-aligned, with a width of 10</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp"><span class="op">{:*^</span><span class="dv">20</span><span class="op">}</span></code></td>
<td>The whole range formatting is center-aligned, with a width of 20, padded with <code class="sourceCode cpp"><span class="op">*</span></code>s</td>
</tr>
<tr class="odd">
<td><code class="x">{:m}</code></td>
<td>Apply the <code class="sourceCode cpp">m</code> specifier to the range (which must be a range of pair or 2-tuple)</td>
</tr>
<tr class="even">
<td><code class="x">{::d}</code></td>
<td>Apply the <code class="sourceCode cpp">d</code> specifier to each element of the range</td>
</tr>
<tr class="odd">
<td><code class="x">{:?s}</code></td>
<td>Apply the <code class="sourceCode cpp"><span class="op">?</span>s</code> specifier to the range (which must be a range of char)</td>
</tr>
</tbody>
</table>
<p>There are only a few top-level range-specific specifiers proposed:</p>
<ul>
<li><code class="sourceCode cpp">s</code>: for ranges of char, only: formats the range as a string.</li>
<li><code class="sourceCode cpp"><span class="op">?</span>s</code> for ranges of char, only: same as <code class="sourceCode cpp">s</code> except will additionally quote and escape the string.</li>
<li><code class="sourceCode cpp">m</code>: for ranges of <code class="sourceCode cpp">pair</code>s (or <code class="sourceCode cpp">tuple</code>s of size 2) will format as <code class="sourceCode cpp"><span class="op">{</span>k1<span class="op">:</span> v1, k2<span class="op">:</span> v2<span class="op">}</span></code> instead of <code class="sourceCode cpp"><span class="op">[(</span>k1, v1<span class="op">)</span>, <span class="op">(</span>k2, v2<span class="op">)]</span></code> (i.e. as a <code class="sourceCode cpp">map</code>).</li>
<li><code class="sourceCode cpp">n</code>: will format without the brackets. This will let you, for instance, format a range as <code class="sourceCode cpp">a, b, c</code> or <code class="sourceCode cpp"><span class="op">{</span>a, b, c<span class="op">}</span></code> or <code class="sourceCode cpp"><span class="op">(</span>a, b, c<span class="op">)</span></code> or however else you want, simply by providing the desired format string. If printing a normal range, the brackets removed are <code class="sourceCode cpp"><span class="op">[]</span></code>. If printing as a map, the brackets removed are <code class="sourceCode cpp"><span class="op">{}</span></code>. If printing as a quoted string, the brackets removed are the <code class="sourceCode cpp"><span class="st">&quot;&quot;</span></code>s (but escaping will still happen).</li>
</ul>
<p>Additionally, ranges will support the same fill/align/width specifiers as in <em>std-format-spec</em>, for convenience and consistency.</p>
<p>If no element-specific formatter is provided (i.e. there is no inner colon - an empty element-specific formatter is still an element-specific formatter), the range will be formatted as debug. Otherwise, the element-specific formatter will be parsed and used.</p>
<p>To revisit a few rows from the earlier table:</p>
<table>
<colgroup>
<col style="width: 11%"></col>
<col style="width: 44%"></col>
<col style="width: 44%"></col>
</colgroup>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Format String</strong>
</div></th>
<th><div style="text-align:center">
<strong>Contents</strong>
</div></th>
<th><div style="text-align:center">
<strong>Formatted Output</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="x">{}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;{</span><span class="ch">&#39;H&#39;</span>, <span class="ch">&#39;</span><span class="sc">\t</span><span class="ch">&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;o&#39;</span><span class="op">}</span></code></td>
<td><code class="x">[&#39;H&#39;, &#39;\t&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]</code></td>
</tr>
<tr class="even">
<td><code class="x">{::}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;{</span><span class="ch">&#39;H&#39;</span>, <span class="ch">&#39;</span><span class="sc">\t</span><span class="ch">&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;o&#39;</span><span class="op">}</span></code></td>
<td><code class="x">[H,     , l, l, o]</code></td>
</tr>
<tr class="odd">
<td><code class="x">{::?c}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;{</span><span class="ch">&#39;H&#39;</span>, <span class="ch">&#39;</span><span class="sc">\t</span><span class="ch">&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;o&#39;</span><span class="op">}</span></code></td>
<td><code class="x">[&#39;H&#39;, &#39;\t&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]</code></td>
</tr>
<tr class="even">
<td><code class="x">{::d}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;{</span><span class="ch">&#39;H&#39;</span>, <span class="ch">&#39;</span><span class="sc">\t</span><span class="ch">&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;o&#39;</span><span class="op">}</span></code></td>
<td><code class="x">[72, 9, 108, 108, 111]</code></td>
</tr>
<tr class="odd">
<td><code class="x">{::#x}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;{</span><span class="ch">&#39;H&#39;</span>, <span class="ch">&#39;</span><span class="sc">\t</span><span class="ch">&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;o&#39;</span><span class="op">}</span></code></td>
<td><code class="x">[0x48, 0x9, 0x6c, 0x6c, 0x6f]</code></td>
</tr>
<tr class="even">
<td><code class="x">{:s}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;{</span><span class="ch">&#39;H&#39;</span>, <span class="ch">&#39;</span><span class="sc">\t</span><span class="ch">&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;o&#39;</span><span class="op">}</span></code></td>
<td><code class="x">H    llo</code></td>
</tr>
<tr class="odd">
<td><code class="x">{:?s}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;{</span><span class="ch">&#39;H&#39;</span>, <span class="ch">&#39;</span><span class="sc">\t</span><span class="ch">&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;o&#39;</span><span class="op">}</span></code></td>
<td><code class="x">&quot;H\tllo&quot;</code></td>
</tr>
<tr class="even">
<td><code class="x">{}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">{</span>vector<span class="op">{</span><span class="ch">&#39;a&#39;</span><span class="op">}</span>, vector<span class="op">{</span><span class="ch">&#39;b&#39;</span>, <span class="ch">&#39;c&#39;</span><span class="op">}}</span></code></td>
<td><code class="x">[[&#39;a&#39;], [&#39;b&#39;, &#39;c&#39;]]</code></td>
</tr>
<tr class="odd">
<td><code class="x">{::?s}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">{</span>vector<span class="op">{</span><span class="ch">&#39;a&#39;</span><span class="op">}</span>, vector<span class="op">{</span><span class="ch">&#39;b&#39;</span>, <span class="ch">&#39;c&#39;</span><span class="op">}}</span></code></td>
<td><code class="x">[&quot;a&quot;, &quot;bc&quot;]</code></td>
</tr>
<tr class="even">
<td><code class="x">{:::d}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">{</span>vector<span class="op">{</span><span class="ch">&#39;a&#39;</span><span class="op">}</span>, vector<span class="op">{</span><span class="ch">&#39;b&#39;</span>, <span class="ch">&#39;c&#39;</span><span class="op">}}</span></code></td>
<td><code class="x">[[97], [98, 99]]</code></td>
</tr>
</tbody>
</table>
<p>The second row is not printed quoted, because an empty element specifier is provided. We assume that if the user explicitly provides a format specifier (even if it’s empty), that they want control over what they’re doing. The third row is printed quoted again because it was explicitly asked for using the <code class="sourceCode cpp"><span class="op">?</span>c</code> specifier, applied to each character.</p>
<p>The last row, <code class="sourceCode cpp"><span class="op">:::</span>d</code>, is parsed as:</p>
<table>
<thead>
<tr class="header">
<th></th>
<th><div style="text-align:center">
<strong>top level outer vector</strong>
</div></th>
<th></th>
<th><div style="text-align:center">
<strong>top level inner vector</strong>
</div></th>
<th></th>
<th><div style="text-align:center">
<strong>inner vector each element</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="op">:</span></code></td>
<td>(none)</td>
<td><code class="sourceCode cpp"><span class="op">:</span></code></td>
<td>(none)</td>
<td><code class="sourceCode cpp"><span class="op">:</span></code></td>
<td><code class="sourceCode cpp">d</code></td>
</tr>
</tbody>
</table>
<p>That is, the <code class="sourceCode cpp">d</code> format specifier is applied to each underlying <code class="sourceCode cpp"><span class="dt">char</span></code>, which causes them to be printed as integers instead of characters.</p>
<p>Note that you can provide both a fill/align/width specifier to the range itself as well as to each element:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Format String</strong>
</div></th>
<th><div style="text-align:center">
<strong>Contents</strong>
</div></th>
<th><div style="text-align:center">
<strong>Formatted Output</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="x">{}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;{</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span><span class="op">}</span></code></td>
<td><code class="x">[1, 2, 3]</code></td>
</tr>
<tr class="even">
<td><code class="x">{::*^5}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;{</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span><span class="op">}</span></code></td>
<td><code class="x">[**1**, **2**, **3**]</code></td>
</tr>
<tr class="odd">
<td><code class="x">{:o^17}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;{</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span><span class="op">}</span></code></td>
<td><code class="x">oooo[1, 2, 3]oooo</code></td>
</tr>
<tr class="even">
<td><code class="x">{:o^29:*^5}</code></td>
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;{</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span><span class="op">}</span></code></td>
<td><code class="x">oooo[**1**, **2**, **3**]oooo</code></td>
</tr>
</tbody>
</table>
<h4 data-number="3.3.7.3" id="pair-and-tuple-specifiers"><span class="header-section-number">3.3.7.3</span> Pair and Tuple Specifiers<a href="#pair-and-tuple-specifiers" class="self-link"></a></h4>
<p>This is the hard part.</p>
<p>To start with, we for consistency will support the same fill/align/width specifiers as usual.</p>
<p>And likewise an <code class="sourceCode cpp">n</code> specifier to omit the parentheses and an <code class="sourceCode cpp">m</code> speciifer to format <code class="sourceCode cpp">pair</code>s and 2-<code class="sourceCode cpp">tuple</code>s as <code class="sourceCode cpp">k<span class="op">:</span> v</code> rather than <code class="sourceCode cpp"><span class="op">(</span>k, v<span class="op">)</span></code>.</p>
<p>For ranges, we can have the underlying element’s <code class="sourceCode cpp">formatter</code> simply parse the whole format specifier string from the character past the <code class="sourceCode cpp"><span class="op">:</span></code> to the <code class="sourceCode cpp"><span class="op">}</span></code>. The range doesn’t care anymore at that point, and what we’re left with is a specifier that the underlying element should understand (or not).</p>
<p>But for <code class="sourceCode cpp">pair</code>, it’s not so easy, because format strings can contain <em>anything</em>. Absolutely anything. So when trying to parse a format specifier for a <code class="sourceCode cpp">pair<span class="op">&lt;</span>X, Y<span class="op">&gt;</span></code>, how do you know where <code class="sourceCode cpp">X</code>’s format specifier ends and <code class="sourceCode cpp">Y</code>’s format specifier begins? This is, in general, impossible.</p>
<p>In <span class="citation" data-cites="P2286R3">[<a href="#ref-P2286R3" role="doc-biblioref">P2286R3</a>]</span>, this paper used Tim’s insight to take a page out of <code class="sourceCode cpp">sed</code>’s book and rely on the user providing the specifier string to actually know what they’re doing, and thus provide their own delimiter. <code class="sourceCode cpp">pair</code> will recognize the first character that is not one of its formatters as the delimiter, and then delimit based on that. This previous revision had proposed the following:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Format String</strong>
</div></th>
<th><div style="text-align:center">
<strong>Contents</strong>
</div></th>
<th><div style="text-align:center">
<strong>Formatted Output</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="x">{}</code></td>
<td><code class="sourceCode cpp">pair<span class="op">(</span><span class="dv">10</span>, <span class="dv">1729</span><span class="op">)</span></code></td>
<td><code class="x">(10, 1729)</code></td>
</tr>
<tr class="even">
<td><code class="x">{:}</code></td>
<td><code class="sourceCode cpp">pair<span class="op">(</span><span class="dv">10</span>, <span class="dv">1729</span><span class="op">)</span></code></td>
<td><code class="x">(10, 1729)</code></td>
</tr>
<tr class="odd">
<td><code class="x">{::#x:04X}</code></td>
<td><code class="sourceCode cpp">pair<span class="op">(</span><span class="dv">10</span>, <span class="dv">1729</span><span class="op">)</span></code></td>
<td><code class="x">(0xa, 06C1)</code></td>
</tr>
<tr class="even">
<td><code class="x">{:|#x|04X}</code></td>
<td><code class="sourceCode cpp">pair<span class="op">(</span><span class="dv">10</span>, <span class="dv">1729</span><span class="op">)</span></code></td>
<td><code class="x">(0xa, 06C1)</code></td>
</tr>
<tr class="odd">
<td><code class="x">{:Y#xY04X}</code></td>
<td><code class="sourceCode cpp">pair<span class="op">(</span><span class="dv">10</span>, <span class="dv">1729</span><span class="op">)</span></code></td>
<td><code class="x">(0xa, 06C1)</code></td>
</tr>
</tbody>
</table>
<p>The last three rows are equivalent, the difference is which character is used to delimit the specifiers: <code class="sourceCode cpp"><span class="op">:</span></code> or <code class="sourceCode cpp"><span class="op">|</span></code> or <code class="sourceCode cpp">Y</code>.</p>
<p>This approach, while technically functional, still leaves something to be desired. For one thing, these examples are already difficult to read and I haven’t even shown any additional nesting. We’re using to nested parentheses, brackets, or braces, but there’s nothing visually nested here. And it’s not even clear how to do something like that anyway. Several people expressed a desire to have a delimiter language that at least has some concept of nesting built-in - such as naturally-nesting punctuation like<code class="sourceCode cpp"><span class="op">()</span></code>s, <code class="sourceCode cpp"><span class="op">[]</span></code>s, or <code class="sourceCode cpp"><span class="op">{}</span>s</code> (Unicode has plenty of other pairs of open/close characters. I could revisit my Russian roots with <code class="sourceCode cpp">«</code> and <code class="sourceCode cpp">»</code>, or use something prettier like <code class="sourceCode cpp">⦕</code> and <code class="sourceCode cpp">⦖</code>).</p>
<p>The point, ultimately, is that it is difficult to come up with a format specifier syntax that works <em>at all</em> in the presence of types that can use arbitrary characters in their specifiers. Like formatting <code class="sourceCode cpp">std<span class="op">::</span>chrono<span class="op">::</span>system_clock<span class="op">::</span>now<span class="op">()</span></code>:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Format String</strong>
</div></th>
<th><div style="text-align:center">
<strong>Formatted Output</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="op">{}</span></code></td>
<td><code class="x">2021-10-24 20:33:37</code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp"><span class="op">{:%</span>Y<span class="op">-%</span>m<span class="op">-%</span>d<span class="op">}</span></code></td>
<td><code class="x">2021-10-24</code></td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="op">{:%</span>H<span class="op">:%</span>M<span class="op">:%</span>S<span class="op">}</span></code></td>
<td><code class="x">20:33:37</code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp"><span class="op">{:%</span>H hours, <span class="op">%</span>M minutes, <span class="op">%</span>S seconds<span class="op">}</span></code></td>
<td><code class="x">20 hours, 33 minutes, 37 seconds</code></td>
</tr>
</tbody>
</table>
<p>Because there is reasonable concern about the complexity of the initially proposed solution, and because there doesn’t seem to be a lot of demand for actually being able to do this, in contrast to the very clear and present demand of being able to format pairs and tuples simply by default - this revision of this paper is withdrawing this part of the proposal in an effort to get the rest of the paper in for C++23.</p>
<p>To summarize: <code class="sourceCode cpp">std<span class="op">::</span>pair</code> and <code class="sourceCode cpp">std<span class="op">::</span>tuple</code> will only support:</p>
<ul>
<li>the fill/align/width specifiers from <em>std-format-spec</em></li>
<li>the <code class="sourceCode cpp"><span class="op">?</span></code> specifier, to format as debug (which is a no-op, since it will always format as debug, since there is no opt-out provided)</li>
<li>the <code class="sourceCode cpp">n</code> specifier, to omit the parentheses</li>
<li>the <code class="sourceCode cpp">m</code> specifier, only valid for <code class="sourceCode cpp">pair</code> or 2-tuple, to format as <code class="sourceCode cpp">k<span class="op">:</span> v</code> instead of <code class="sourceCode cpp"><span class="op">(</span>k, v<span class="op">)</span></code></li>
</ul>
<p>For <code class="sourceCode cpp">tuple</code> of size other than 2, this will throw an exception (since you cannot format those as a map). To clarify the map specifier:</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Format String</strong>
</div></th>
<th><div style="text-align:center">
<strong>Contents</strong>
</div></th>
<th><div style="text-align:center">
<strong>Formatted Output</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="op">{}</span></code></td>
<td><code class="sourceCode cpp">pair<span class="op">(</span><span class="dv">1</span>, <span class="dv">2</span><span class="op">)</span></code></td>
<td><code class="sourceCode cpp"><span class="op">(</span><span class="dv">1</span>, <span class="dv">2</span><span class="op">)</span></code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp"><span class="op">{:</span>m<span class="op">}</span></code></td>
<td><code class="sourceCode cpp">pair<span class="op">(</span><span class="dv">1</span>, <span class="dv">2</span><span class="op">)</span></code></td>
<td><code class="sourceCode cpp"><span class="dv">1</span><span class="op">:</span> <span class="dv">2</span></code></td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="op">{:</span>m<span class="op">}</span></code></td>
<td><code class="sourceCode cpp">tuple<span class="op">(</span><span class="dv">1</span>, <span class="dv">2</span><span class="op">)</span></code></td>
<td><code class="sourceCode cpp"><span class="dv">1</span><span class="op">:</span> <span class="dv">2</span></code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp"><span class="op">{}</span></code></td>
<td><code class="sourceCode cpp">tuple<span class="op">(</span><span class="dv">1</span><span class="op">)</span></code></td>
<td><code class="sourceCode cpp"><span class="op">(</span><span class="dv">1</span><span class="op">)</span></code></td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="op">{:</span>m<span class="op">}</span></code></td>
<td><code class="sourceCode cpp">tuple<span class="op">(</span><span class="dv">1</span><span class="op">)</span></code></td>
<td>exception or compile error</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp"><span class="op">{}</span></code></td>
<td><code class="sourceCode cpp">tuple<span class="op">(</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="st">&quot;3&quot;</span><span class="bu">s</span><span class="op">)</span></code></td>
<td><code class="sourceCode cpp"><span class="op">(</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="st">&quot;3&quot;</span><span class="op">)</span></code></td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="op">{:</span>m<span class="op">}</span></code></td>
<td><code class="sourceCode cpp">tuple<span class="op">(</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="st">&quot;3&quot;</span><span class="bu">s</span><span class="op">)</span></code></td>
<td>exception or compile error</td>
</tr>
</tbody>
</table>
<h3 data-number="3.3.8" id="escaping-behavior"><span class="header-section-number">3.3.8</span> Escaping Behavior<a href="#escaping-behavior" class="self-link"></a></h3>
<p>There is some established practice for how to escape strings, for instance in Python and Rust, which seems like a really good idea to follow.</p>
<h4 data-number="3.3.8.1" id="python"><span class="header-section-number">3.3.8.1</span> Python<a href="#python" class="self-link"></a></h4>
<p>In Python, the choice of characters to escape and the new algorithm for <code class="sourceCode cpp">repr</code> is described in <span class="citation" data-cites="PEP-3138">[<a href="#ref-PEP-3138" role="doc-biblioref">PEP-3138</a>]</span>:</p>
<div class="quote">
<p>Characters that should be escaped are defined in the Unicode character database as:</p>
<ul>
<li>Cc (Other, Control)</li>
<li>Cf (Other, Format)</li>
<li>Cs (Other, Surrogate)</li>
<li>Co (Other, Private Use)</li>
<li>Cn (Other, Not Assigned)</li>
<li>Zl (Separator, Line), refers to LINE SEPARATOR (<code class="x">&#39;\u2028&#39;</code>).</li>
<li>Zp (Separator, Paragraph), refers to PARAGRAPH SEPARATOR (<code class="x">&#39;\u2029&#39;</code>).</li>
<li>Zs (Separator, Space) other than ASCII space (<code class="x">&#39;\x20&#39;</code>). Characters in this category should be escaped to avoid ambiguity.</li>
</ul>
<p>The algorithm to build <code class="sourceCode cpp">repr<span class="op">()</span></code> strings should be changed to:</p>
<ul>
<li>Convert CR, LF, TAB and <code class="sourceCode cpp"><span class="ch">&#39;</span><span class="sc">\&#39;</span></code> to <code class="sourceCode cpp"><span class="ch">&#39;</span><span class="sc">\r</span><span class="ch">&#39;</span></code>, <code class="sourceCode cpp"><span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span></code>, <code class="sourceCode cpp"><span class="ch">&#39;</span><span class="sc">\t</span><span class="ch">&#39;</span></code>, <code class="sourceCode cpp"><span class="ch">&#39;</span><span class="sc">\\</span><span class="ch">&#39;</span></code>.</li>
<li>Convert non-printable ASCII characters (0x00-0x1f, 0x7f) to <code class="x">&#39;\xXX&#39;</code>.</li>
<li>Convert leading surrogate pair characters without trailing character (0xd800-0xdbff, but not followed by 0xdc00-0xdfff) to <code class="x">&#39;\uXXXX&#39;</code>.</li>
<li>Convert non-printable characters ([… see above …]) to <code class="x">&#39;xXX&#39;</code>, <code class="x">&#39;\uXXXX&#39;</code> or <code class="x">&#39;\U00xxxxxx&#39;</code>.</li>
<li>Backslash-escape quote characters (apostrophe, 0x27) and add a quote character at the beginning and the end.</li>
</ul>
</div>
<h4 data-number="3.3.8.2" id="rust"><span class="header-section-number">3.3.8.2</span> Rust<a href="#rust" class="self-link"></a></h4>
<p>Rust doesn’t have (to my knowledge) such a formal description of which characters need to be escaped, I’m not sure if there’s a Rust-equivalent of a PEP that I could link to. Rust’s implementation gives a standard library function <code class="sourceCode cpp">is_printable</code> which is actually generated from a <a href="https://github.com/rust-lang/rust/blob/256721ee519f6ff15dc5c1cfaf3ebf9af75efa4a/library/core/src/unicode/printable.py">Python file</a> which contains the following relevant logic:</p>
<blockquote>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">def</span> get_escaped(codepoints):</span>
<span id="cb7-2"><a href="#cb7-2"></a>    <span class="cf">for</span> c <span class="kw">in</span> codepoints:</span>
<span id="cb7-3"><a href="#cb7-3"></a>        <span class="cf">if</span> (c.class_ <span class="kw">or</span> <span class="st">&quot;Cn&quot;</span>) <span class="kw">in</span> <span class="st">&quot;Cc Cf Cs Co Cn Zl Zp Zs&quot;</span>.split() <span class="kw">and</span> c.value <span class="op">!=</span> <span class="bu">ord</span>(<span class="st">&#39; &#39;</span>):</span>
<span id="cb7-4"><a href="#cb7-4"></a>            <span class="cf">yield</span> c.value</span></code></pre></div>
</blockquote>
<p>Which is the exact same logic as Python: those eight classes, with the exception of ASCII space, are escaped. Looking at the actual Rust <a href="https://doc.rust-lang.org/src/core/unicode/printable.rs.html">implementation code</a> is a little bit more involved, but that’s only because it’s optimized for values and no longer based on actual structural elements from Unicode. Rust’s actual algorithm for using this <code class="sourceCode cpp">is_printable</code> function can be found in the <code class="sourceCode cpp">impl Debug <span class="cf">for</span> str</code> found <a href="https://doc.rust-lang.org/src/core/fmt/mod.rs.html#2129-2151">here</a> which is implemented in terms of <a href="https://doc.rust-lang.org/src/core/char/methods.rs.html#417-432"><code class="sourceCode cpp">escape_debug_ext</code></a> (for clarity, in the context of printing a debug string, <code class="sourceCode cpp">args<span class="op">.</span>escape_grapheme_extended</code> is <code class="sourceCode cpp"><span class="kw">true</span></code>, <code class="sourceCode cpp">args<span class="op">.</span>escape_single_quote</code> is <code class="sourceCode cpp"><span class="kw">false</span></code>, and <code class="sourceCode cpp">args<span class="op">.</span>escape_double_quote</code> is <code class="sourceCode cpp"><span class="kw">true</span></code>. For a debug character, the latter two are flipped):</p>
<blockquote>
<div class="sourceCode" id="cb8"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> escape_debug_ext(<span class="kw">self</span><span class="op">,</span> args<span class="op">:</span> EscapeDebugExtArgs) <span class="op">-&gt;</span> EscapeDebug <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>    <span class="kw">let</span> init_state <span class="op">=</span> <span class="kw">match</span> <span class="kw">self</span> <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>        <span class="ch">&#39;</span><span class="sc">\t</span><span class="ch">&#39;</span> <span class="op">=&gt;</span> <span class="pp">EscapeDefaultState::</span>Backslash(<span class="ch">&#39;t&#39;</span>)<span class="op">,</span></span>
<span id="cb8-4"><a href="#cb8-4"></a>        <span class="ch">&#39;</span><span class="sc">\r</span><span class="ch">&#39;</span> <span class="op">=&gt;</span> <span class="pp">EscapeDefaultState::</span>Backslash(<span class="ch">&#39;r&#39;</span>)<span class="op">,</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>        <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span> <span class="op">=&gt;</span> <span class="pp">EscapeDefaultState::</span>Backslash(<span class="ch">&#39;n&#39;</span>)<span class="op">,</span></span>
<span id="cb8-6"><a href="#cb8-6"></a>        <span class="ch">&#39;</span><span class="sc">\\</span><span class="ch">&#39;</span> <span class="op">=&gt;</span> <span class="pp">EscapeDefaultState::</span>Backslash(<span class="kw">self</span>)<span class="op">,</span></span>
<span id="cb8-7"><a href="#cb8-7"></a>        <span class="ch">&#39;&quot;&#39;</span> <span class="kw">if</span> args<span class="op">.</span>escape_double_quote <span class="op">=&gt;</span> <span class="pp">EscapeDefaultState::</span>Backslash(<span class="kw">self</span>)<span class="op">,</span></span>
<span id="cb8-8"><a href="#cb8-8"></a>        <span class="ch">&#39;</span><span class="sc">\&#39;</span><span class="ch">&#39;</span> <span class="kw">if</span> args<span class="op">.</span>escape_single_quote <span class="op">=&gt;</span> <span class="pp">EscapeDefaultState::</span>Backslash(<span class="kw">self</span>)<span class="op">,</span></span>
<span id="cb8-9"><a href="#cb8-9"></a>        _ <span class="kw">if</span> args<span class="op">.</span>escape_grapheme_extended <span class="op">&amp;&amp;</span> <span class="kw">self</span><span class="op">.</span>is_grapheme_extended() <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb8-10"><a href="#cb8-10"></a>            <span class="pp">EscapeDefaultState::</span>Unicode(<span class="kw">self</span><span class="op">.</span>escape_unicode())</span>
<span id="cb8-11"><a href="#cb8-11"></a>        <span class="op">}</span></span>
<span id="cb8-12"><a href="#cb8-12"></a>        _ <span class="kw">if</span> is_printable(<span class="kw">self</span>) <span class="op">=&gt;</span> <span class="pp">EscapeDefaultState::</span>Char(<span class="kw">self</span>)<span class="op">,</span></span>
<span id="cb8-13"><a href="#cb8-13"></a>        _ <span class="op">=&gt;</span> <span class="pp">EscapeDefaultState::</span>Unicode(<span class="kw">self</span><span class="op">.</span>escape_unicode())<span class="op">,</span></span>
<span id="cb8-14"><a href="#cb8-14"></a>    <span class="op">};</span></span>
<span id="cb8-15"><a href="#cb8-15"></a>    EscapeDebug(EscapeDefault <span class="op">{</span> state<span class="op">:</span> init_state <span class="op">}</span>)</span>
<span id="cb8-16"><a href="#cb8-16"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>The grapheme-extended logic exists in Rust but not in Python, the rest is the same. <a href="https://doc.rust-lang.org/std/primitive.char.html#method.escape_unicode"><code class="sourceCode cpp"><span class="dt">char</span><span class="op">::</span>escape_unicode</code></a> will:</p>
<div class="quote">
<p>This will escape characters with the Rust syntax of the form <code class="sourceCode cpp">\u<span class="op">{</span>NNNNNN<span class="op">}</span></code> where <code class="sourceCode cpp">NNNNNN</code> is a hexadecimal representation.</p>
</div>
<p>which, for example:</p>
<blockquote>
<div class="sourceCode" id="cb9"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">for</span> c <span class="kw">in</span> <span class="ch">&#39;❤&#39;</span><span class="op">.</span>escape_unicode() <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>    <span class="pp">print!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> c)<span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="op">}</span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="pp">println!</span>()<span class="op">;</span></span></code></pre></div>
</blockquote>
<p>will print <code class="x">&quot;\u{2764}&quot;</code>. Though note that <code class="sourceCode rust"><span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> <span class="st">&quot;❤&quot;</span>)<span class="op">;</span></code> will just print that heart (quoted) because that heart is printable.</p>
<h4 data-number="3.3.8.3" id="golang"><span class="header-section-number">3.3.8.3</span> Golang<a href="#golang" class="self-link"></a></h4>
<p><code class="sourceCode cpp">golang</code>’s unicode package provides an <code class="sourceCode cpp">isPrint</code> function defined <a href="https://pkg.go.dev/unicode#IsPrint">as follows</a>:</p>
<blockquote>
<div class="sourceCode" id="cb10"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">func</span> IsPrint(r <span class="dt">rune</span>) <span class="dt">bool</span></span></code></pre></div>
<p><code class="sourceCode cpp">IsPrint</code> reports whether the rune is defined as printable by Go. Such characters include letters, marks, numbers, punctuation, symbols, and the ASCII space character, from categories L, M, N, P, S and the ASCII space character. This categorization is the same as IsGraphic except that the only spacing character is ASCII space, <code class="x">U+0020</code>.</p>
</blockquote>
<p>In this case, Go is adding categories L, M, N, P, S, and ASCII space… whereas Rust and Python are removing categories Z and C but keeping ASCII space. These two sets are equivalent: the full set of Unicode category classes is L, M, N, P, S, Z, C. Hence, Go’s logic is also the same as Rust and Python.</p>
<h4 data-number="3.3.8.4" id="proposed-for-c"><span class="header-section-number">3.3.8.4</span> Proposed for C++<a href="#proposed-for-c" class="self-link"></a></h4>
<p>Escaping of a string in a Unicode encoding is done by translating each UCS scalar value, or a code unit if it is not a part of a valid UCS scalar value, in sequence (Note that all the backslashes are escaped here as well):</p>
<ul>
<li>If a UCS scalar value is one of <code class="sourceCode cpp"><span class="ch">&#39;</span><span class="sc">\t</span><span class="ch">&#39;</span></code>, <code class="sourceCode cpp"><span class="ch">&#39;</span><span class="sc">\r</span><span class="ch">&#39;</span></code>, <code class="sourceCode cpp"><span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span></code>, <code class="sourceCode cpp"><span class="ch">&#39;</span><span class="sc">\\</span><span class="ch">&#39;</span></code> or <code class="sourceCode cpp"><span class="ch">&#39;&quot;&#39;</span></code>, it is replaced with <code class="sourceCode cpp"><span class="st">&quot;</span><span class="sc">\\</span><span class="st">t&quot;</span></code>, <code class="sourceCode cpp"><span class="st">&quot;</span><span class="sc">\\</span><span class="st">r&quot;</span></code>, <code class="sourceCode cpp"><span class="st">&quot;</span><span class="sc">\\</span><span class="st">n&quot;</span></code>, <code class="sourceCode cpp"><span class="st">&quot;</span><span class="sc">\\\\</span><span class="st">&quot;</span></code> and <code class="sourceCode cpp"><span class="st">&quot;</span><span class="sc">\\\&quot;</span><span class="st">&quot;</span></code> respectively.</li>
<li>Otherwise, if a UCS scalar value has a Unicode property Separator (Z) or Other (C) other than space, it is replaced with its universal character name escape sequence in the form <code class="sourceCode cpp"><span class="st">&quot;</span><span class="sc">\\</span><span class="st">u{<em>simple-hexadecimal-digit-sequence</em>}&quot;</span></code> as proposed by <span class="citation" data-cites="P2290R2">[<a href="#ref-P2290R2" role="doc-biblioref">P2290R2</a>]</span>, where <em>simple-hexadecimal-digit-sequence</em> is a hexadecimal representation of the UCS scalar value without leading zeros.</li>
<li>Otherwise, if a UCS scalar value has a Unicode property Grapheme_Extend and there are no UCS scalar values preceding it in the string without this property, it is replaced with its universal character name escape sequence as above.</li>
<li>Otherwise, a code unit that is not a part of a valid UCS scalar value is replaced with a hexadecimal escape sequence in the form <code class="sourceCode cpp"><span class="st">&quot;</span><span class="sc">\\</span><span class="st">x{<em>simple-hexadecimal-digit-sequence</em>}&quot;</span></code> as proposed by <span class="citation" data-cites="P2290R2">[<a href="#ref-P2290R2" role="doc-biblioref">P2290R2</a>]</span>, where <em>simple-hexadecimal-digit-sequence</em> is a hexadecimal representation of the code unit without leading zeros.</li>
<li>Otherwise, a UCS scalar value is copied as is.</li>
</ul>
<p>The same applies to wide strings with <code class="x">&#39;...&#39;</code> and <code class="x">&quot;...&quot;</code> replaced with <code class="sourceCode cpp"><span class="ch">L&#39;.</span><span class="er">..</span><span class="ch">&#39;</span></code> and <code class="sourceCode cpp"><span class="st">L&quot;...&quot;</span></code> respectively.</p>
<p>For non-Unicode encodings an implementation-defined equivalent of Unicode properties is used.</p>
<p>Escape rules for characters are similar except that <code class="sourceCode cpp"><span class="ch">&#39;</span><span class="sc">\&#39;</span><span class="ch">&#39;</span></code> is escaped instead of <code class="sourceCode cpp"><span class="ch">&#39;&quot;&#39;</span></code> and <code class="sourceCode cpp"><span class="ch">&#39;&quot;&#39;</span></code> is not escaped.</p>
<p>Examples:</p>
<blockquote>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1"></a>std<span class="op">::</span>cout <span class="op">&lt;&lt;</span> std<span class="op">::</span>format<span class="op">(</span><span class="st">&quot;{:?}&quot;</span>, std<span class="op">::</span>string<span class="op">(</span><span class="st">&quot;h</span><span class="sc">\t</span><span class="st">llo&quot;</span><span class="op">))</span>;</span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="co">// Output: &quot;h\tllo&quot;</span></span>
<span id="cb23-3"><a href="#cb23-3"></a></span>
<span id="cb23-4"><a href="#cb23-4"></a>std<span class="op">::</span>cout <span class="op">&lt;&lt;</span> std<span class="op">::</span>format<span class="op">(</span><span class="st">&quot;{:?}&quot;</span>, std<span class="op">::</span>string<span class="op">(</span><span class="st">&quot;</span><span class="sc">\0</span><span class="st"> </span><span class="sc">\n</span><span class="st"> </span><span class="sc">\t</span><span class="st"> </span><span class="sc">\x02</span><span class="st"> </span><span class="sc">\x1b</span><span class="st">&quot;</span>, <span class="dv">9</span><span class="op">))</span>;</span>
<span id="cb23-5"><a href="#cb23-5"></a><span class="co">// Output: &quot;\u{0} \n \t \u{2} \u{1b}&quot;</span></span>
<span id="cb23-6"><a href="#cb23-6"></a></span>
<span id="cb23-7"><a href="#cb23-7"></a>std<span class="op">::</span>cout <span class="op">&lt;&lt;</span> std<span class="op">::</span>format<span class="op">(</span><span class="st">&quot;{:?}, {:?}, {:?}&quot;</span>, <span class="st">&quot; </span><span class="sc">\&quot;</span><span class="st"> &#39; &quot;</span>, <span class="ch">&#39;&quot;&#39;</span>, <span class="ch">&#39;</span><span class="sc">\&#39;</span><span class="ch">&#39;</span><span class="op">)</span>;</span>
<span id="cb23-8"><a href="#cb23-8"></a><span class="co">// Output: &quot; \&quot; &#39; &quot;, &#39;&quot;&#39;, &#39;\&#39;&#39;</span></span>
<span id="cb23-9"><a href="#cb23-9"></a></span>
<span id="cb23-10"><a href="#cb23-10"></a>std<span class="op">::</span>cout <span class="op">&lt;&lt;</span> std<span class="op">::</span>format<span class="op">(</span><span class="st">&quot;{:?}&quot;</span>, <span class="st">&quot;</span><span class="sc">\xc3\x28</span><span class="st">&quot;</span><span class="op">)</span>; <span class="co">// invalid UTF-8</span></span>
<span id="cb23-11"><a href="#cb23-11"></a><span class="co">// Output: &quot;\x{c3}\x{28}&quot;</span></span>
<span id="cb23-12"><a href="#cb23-12"></a></span>
<span id="cb23-13"><a href="#cb23-13"></a>std<span class="op">::</span>cout <span class="op">&lt;&lt;</span> std<span class="op">::</span>format<span class="op">(</span><span class="st">&quot;{:?}&quot;</span>, <span class="st">&quot;</span><span class="sc">\u0300</span><span class="st">&quot;</span><span class="op">)</span>; <span class="co">// assuming a Unicode encoding</span></span>
<span id="cb23-14"><a href="#cb23-14"></a><span class="co">// Output: &quot;\u{300}&quot;</span></span>
<span id="cb23-15"><a href="#cb23-15"></a><span class="co">// (as opposed to &quot;̀&quot; with an accent on the first &quot;)</span></span>
<span id="cb23-16"><a href="#cb23-16"></a></span>
<span id="cb23-17"><a href="#cb23-17"></a><span class="kw">auto</span> s <span class="op">=</span> std<span class="op">::</span>format<span class="op">(</span><span class="st">&quot;{:?}&quot;</span>, <span class="st">&quot;Привет, 🕴️!&quot;</span><span class="op">)</span>; <span class="co">// assuming a Unicode encoding</span></span>
<span id="cb23-18"><a href="#cb23-18"></a><span class="co">// s == &quot;\&quot;Привет, 🕴️!\&quot;&quot;</span></span></code></pre></div>
</blockquote>
<h2 data-number="3.4" id="implementation-challenges"><span class="header-section-number">3.4</span> Implementation Challenges<a href="#implementation-challenges" class="self-link"></a></h2>
<p>The previous revision of this paper (<span class="citation" data-cites="P2286R4">[<a href="#ref-P2286R4" role="doc-biblioref">P2286R4</a>]</span>) had a long section about the implementation challenges of this section, which existed to motivate the addition of two additional APIs to the standard: <code class="sourceCode cpp">retargeted_format_context</code> and <code class="sourceCode cpp">end_sentry</code>. However, since those APIs have been removed from the proposal (possibly to be included in a future, different paper), it doesn’t make sense to have a long section about it in this particular paper.</p>
<p>For those curious, the previous text can be found <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2286r4.html#implementation-challenges">here</a>.</p>
<h2 data-number="3.5" id="how-to-support-those-views-which-are-not-const-iterable"><span class="header-section-number">3.5</span> How to support those views which are not <code class="sourceCode cpp"><span class="kw">const</span></code>-iterable?<a href="#how-to-support-those-views-which-are-not-const-iterable" class="self-link"></a></h2>
<p>In a previous revision of this paper, this was a real problem since at the time <code class="sourceCode cpp">std<span class="op">::</span>format</code> accepted its arguments by <code class="sourceCode cpp"><span class="kw">const</span> Args<span class="op">&amp;...</span></code></p>
<p>However, <span class="citation" data-cites="P2418R2">[<a href="#ref-P2418R2" role="doc-biblioref">P2418R2</a>]</span> was speedily adopted specifically to address this issue, and now <code class="sourceCode cpp">std<span class="op">::</span>format</code> accepts its arguments by <code class="sourceCode cpp">Args<span class="op">&amp;&amp;...</span></code> This allows those views which are not <code class="sourceCode cpp"><span class="kw">const</span></code>-iterable to be mutably passed into <code class="sourceCode cpp">format<span class="op">()</span></code> and <code class="sourceCode cpp">print<span class="op">()</span></code> and then mutably into its formatter. To support both <code class="sourceCode cpp"><span class="kw">const</span></code> and non-<code class="sourceCode cpp"><span class="kw">const</span></code> formatting of ranges without too much boilerplate, we can do it this way:</p>
<blockquote>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1"></a><span class="kw">template</span> <span class="op">&lt;</span>formattable V<span class="op">&gt;</span></span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="kw">struct</span> range_formatter <span class="op">{</span></span>
<span id="cb24-3"><a href="#cb24-3"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> ParseContext<span class="op">&gt;</span></span>
<span id="cb24-4"><a href="#cb24-4"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> parse<span class="op">(</span>ParseContext<span class="op">&amp;)</span>;</span>
<span id="cb24-5"><a href="#cb24-5"></a></span>
<span id="cb24-6"><a href="#cb24-6"></a>    <span class="kw">template</span> <span class="op">&lt;</span>input_range R, <span class="kw">typename</span> FormatContext<span class="op">&gt;</span></span>
<span id="cb24-7"><a href="#cb24-7"></a>        <span class="kw">requires</span> same_as<span class="op">&lt;</span>remove_cvref_t<span class="op">&lt;</span>range_reference_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;</span>, V<span class="op">&gt;</span></span>
<span id="cb24-8"><a href="#cb24-8"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> format<span class="op">(</span>R<span class="op">&amp;&amp;</span>, FormatContext<span class="op">&amp;)</span> <span class="kw">const</span>;</span>
<span id="cb24-9"><a href="#cb24-9"></a><span class="op">}</span>;</span>
<span id="cb24-10"><a href="#cb24-10"></a></span>
<span id="cb24-11"><a href="#cb24-11"></a><span class="kw">template</span> <span class="op">&lt;</span>input_range R<span class="op">&gt;</span> <span class="kw">requires</span> formattable<span class="op">&lt;</span>range_reference_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;</span></span>
<span id="cb24-12"><a href="#cb24-12"></a><span class="kw">struct</span> formatter<span class="op">&lt;</span>R<span class="op">&gt;</span> <span class="op">:</span> range_formatter<span class="op">&lt;</span>remove_cvref_t<span class="op">&lt;</span>range_reference_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;&gt;</span></span>
<span id="cb24-13"><a href="#cb24-13"></a><span class="op">{</span> <span class="op">}</span>;</span></code></pre></div>
</blockquote>
<p><code class="sourceCode cpp">range_formatter</code> allows reducing unnecessary template instantiations. Any range of <code class="sourceCode cpp"><span class="dt">int</span></code> is going to <code class="sourceCode cpp">parse</code> its specifiers the same way, there’s no need to re-instantiate that code n times. Such a type will also help users to write their own formatters, since they can have a member <code class="sourceCode cpp">range_formatter<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span></code> to handle any range of <code class="sourceCode cpp"><span class="dt">int</span></code> (or <code class="sourceCode cpp"><span class="dt">int</span><span class="op">&amp;</span></code> or <code class="sourceCode cpp"><span class="dt">int</span> <span class="kw">const</span><span class="op">&amp;</span></code>) rather than having to have a specific <code class="sourceCode cpp">formatter<span class="op">&lt;</span>my_special_range<span class="op">&gt;</span></code>.</p>
<h2 data-number="3.6" id="interface-of-the-proposed-solution"><span class="header-section-number">3.6</span> Interface of the proposed solution<a href="#interface-of-the-proposed-solution" class="self-link"></a></h2>
<p>The proposed API for range formatting is:</p>
<blockquote>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1"></a><span class="kw">template</span> <span class="op">&lt;</span>input_range R, <span class="kw">class</span> charT<span class="op">&gt;</span></span>
<span id="cb25-2"><a href="#cb25-2"></a>    <span class="kw">requires</span> <span class="op">(</span><span class="kw">not</span> same_as<span class="op">&lt;</span>remove_cvref_t<span class="op">&lt;</span>range_reference_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;</span>, R<span class="op">&gt;)</span></span>
<span id="cb25-3"><a href="#cb25-3"></a>         <span class="kw">and</span> formattable<span class="op">&lt;</span>range_reference_t<span class="op">&lt;</span>R<span class="op">&gt;</span>, charT<span class="op">&gt;</span></span>
<span id="cb25-4"><a href="#cb25-4"></a><span class="kw">struct</span> formatter<span class="op">&lt;</span>R, charT<span class="op">&gt;</span></span>
<span id="cb25-5"><a href="#cb25-5"></a>    <span class="op">:</span> range_formatter<span class="op">&lt;</span>remove_cvref_t<span class="op">&lt;</span>range_reference_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;</span>, charT<span class="op">&gt;</span></span>
<span id="cb25-6"><a href="#cb25-6"></a><span class="op">{</span> <span class="op">}</span>;</span></code></pre></div>
</blockquote>
<p>Where the public-facing API of <code class="sourceCode cpp">range_formatter</code> is:</p>
<blockquote>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> T, <span class="kw">class</span> charT <span class="op">=</span> <span class="dt">char</span><span class="op">&gt;</span></span>
<span id="cb26-2"><a href="#cb26-2"></a>    <span class="kw">requires</span> formattable<span class="op">&lt;</span>T, charT<span class="op">&gt;</span></span>
<span id="cb26-3"><a href="#cb26-3"></a><span class="kw">struct</span> range_formatter <span class="op">{</span></span>
<span id="cb26-4"><a href="#cb26-4"></a>    <span class="dt">void</span> set_separator<span class="op">(</span>basic_string_view<span class="op">&lt;</span>charT<span class="op">&gt;)</span>;</span>
<span id="cb26-5"><a href="#cb26-5"></a>    <span class="dt">void</span> set_brackets<span class="op">(</span>basic_string_view<span class="op">&lt;</span>charT<span class="op">&gt;</span>, basic_string_view<span class="op">&lt;</span>charT<span class="op">&gt;)</span>;</span>
<span id="cb26-6"><a href="#cb26-6"></a>    <span class="kw">auto</span> underlying<span class="op">()</span> <span class="op">-&gt;</span> formatter<span class="op">&lt;</span>T, charT<span class="op">&gt;&amp;</span>;</span>
<span id="cb26-7"><a href="#cb26-7"></a></span>
<span id="cb26-8"><a href="#cb26-8"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> ParseContext<span class="op">&gt;</span></span>
<span id="cb26-9"><a href="#cb26-9"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> parse<span class="op">(</span>ParseContext<span class="op">&amp;)</span> <span class="op">-&gt;</span> ParseContext<span class="op">::</span>iterator;</span>
<span id="cb26-10"><a href="#cb26-10"></a></span>
<span id="cb26-11"><a href="#cb26-11"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> R, <span class="kw">typename</span> FormatContext<span class="op">&gt;</span></span>
<span id="cb26-12"><a href="#cb26-12"></a>        <span class="kw">requires</span> same_as<span class="op">&lt;</span>T, remove_cvref_t<span class="op">&lt;</span>range_reference_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;&gt;</span></span>
<span id="cb26-13"><a href="#cb26-13"></a>    <span class="kw">auto</span> format<span class="op">(</span>R<span class="op">&amp;&amp;</span>, FormatContext<span class="op">&amp;)</span> <span class="kw">const</span> <span class="op">-&gt;</span> FormatContext<span class="op">::</span>iterator;</span>
<span id="cb26-14"><a href="#cb26-14"></a><span class="op">}</span>;</span></code></pre></div>
</blockquote>
<p>The reason for this shape, rather than putting all the implementation directly into the particular specialization of <code class="sourceCode cpp">formatter<span class="op">&lt;</span>R, charT<span class="op">&gt;</span></code>, is that it makes it much easier to implement custom formatting for other ranges. You can see an example in the implementation of <code class="sourceCode cpp">format_join</code> in the next section. Or, even simpler, implementing formatting for <code class="sourceCode cpp">std<span class="op">::</span>map</code> and <code class="sourceCode cpp">std<span class="op">::</span>set</code>:</p>
<blockquote>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1"></a><span class="kw">template</span> <span class="op">&lt;</span>formattable Key, formattable T, <span class="kw">class</span> Compare, <span class="kw">class</span> Allocator<span class="op">&gt;</span></span>
<span id="cb27-2"><a href="#cb27-2"></a><span class="kw">struct</span> formatter<span class="op">&lt;</span>map<span class="op">&lt;</span>Key, T, Compare, Allocator<span class="op">&gt;&gt;</span></span>
<span id="cb27-3"><a href="#cb27-3"></a>    <span class="op">:</span> range_formatter<span class="op">&lt;</span>pair<span class="op">&lt;</span>Key <span class="kw">const</span>, T<span class="op">&gt;&gt;</span></span>
<span id="cb27-4"><a href="#cb27-4"></a><span class="op">{</span></span>
<span id="cb27-5"><a href="#cb27-5"></a>    formatter<span class="op">()</span> <span class="op">{</span></span>
<span id="cb27-6"><a href="#cb27-6"></a>        <span class="kw">this</span><span class="op">-&gt;</span>set_brackets<span class="op">(</span><span class="st">&quot;{&quot;</span>, <span class="st">&quot;}&quot;</span><span class="op">)</span>;</span>
<span id="cb27-7"><a href="#cb27-7"></a>        <span class="kw">this</span><span class="op">-&gt;</span>underlying<span class="op">().</span>set_brackets<span class="op">({}</span>, <span class="op">{})</span>;</span>
<span id="cb27-8"><a href="#cb27-8"></a>        <span class="kw">this</span><span class="op">-&gt;</span>underlying<span class="op">().</span>set_separator<span class="op">(</span><span class="st">&quot;: &quot;</span><span class="op">)</span>;</span>
<span id="cb27-9"><a href="#cb27-9"></a>    <span class="op">}</span></span>
<span id="cb27-10"><a href="#cb27-10"></a><span class="op">}</span>;</span>
<span id="cb27-11"><a href="#cb27-11"></a></span>
<span id="cb27-12"><a href="#cb27-12"></a><span class="kw">template</span> <span class="op">&lt;</span>formattable Key, <span class="kw">class</span> Compare, <span class="kw">class</span> Allocator<span class="op">&gt;</span></span>
<span id="cb27-13"><a href="#cb27-13"></a><span class="kw">struct</span> formatter<span class="op">&lt;</span>set<span class="op">&lt;</span>Key, Compare, Allocator<span class="op">&gt;&gt;</span></span>
<span id="cb27-14"><a href="#cb27-14"></a>    <span class="op">:</span> range_formatter<span class="op">&lt;</span>Key<span class="op">&gt;</span></span>
<span id="cb27-15"><a href="#cb27-15"></a><span class="op">{</span></span>
<span id="cb27-16"><a href="#cb27-16"></a>    formatter<span class="op">()</span> <span class="op">{</span></span>
<span id="cb27-17"><a href="#cb27-17"></a>        <span class="kw">this</span><span class="op">-&gt;</span>set_brackets<span class="op">(</span><span class="st">&quot;{&quot;</span>, <span class="st">&quot;}&quot;</span><span class="op">)</span>;</span>
<span id="cb27-18"><a href="#cb27-18"></a>    <span class="op">}</span></span>
<span id="cb27-19"><a href="#cb27-19"></a><span class="op">}</span>;</span></code></pre></div>
</blockquote>
<p>However, this is only the case for ranges (where the user might actually need to implement formatting for their own range) and is not the case for pair and tuple. This is because the <code class="sourceCode cpp">pair</code> and <code class="sourceCode cpp">tuple</code> formatters aren’t constrained on <code class="sourceCode cpp">tuple_like</code>. We don’t even have such a concept. Those formatters are specific to <code class="sourceCode cpp">pair</code> and <code class="sourceCode cpp">tuple</code>. If we ever do add a <code class="sourceCode cpp">tuple_like</code> concept, at that point we can add a <code class="sourceCode cpp">tuple_formatter</code>.</p>
<p>The proposed API for pair and tuple formatting is (substituting <code class="sourceCode cpp">pair</code> and <code class="sourceCode cpp">tuple</code> in for <code class="sourceCode cpp"><em>TEMPLATE</em></code>):</p>
<blockquote>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> charT, formattable<span class="op">&lt;</span>charT<span class="op">&gt;...</span> Ts<span class="op">&gt;</span></span>
<span id="cb28-2"><a href="#cb28-2"></a><span class="kw">struct</span> formatter<span class="op">&lt;</span><em>TEMPLATE</em><span class="op">&lt;</span>Ts<span class="op">...&gt;</span>, charT<span class="op">&gt;</span></span>
<span id="cb28-3"><a href="#cb28-3"></a><span class="op">{</span></span>
<span id="cb28-4"><a href="#cb28-4"></a>    <span class="dt">void</span> set_separator<span class="op">(</span>basic_string_view<span class="op">&lt;</span>charT<span class="op">&gt;)</span>;</span>
<span id="cb28-5"><a href="#cb28-5"></a>    <span class="dt">void</span> set_brackets<span class="op">(</span>basic_string_view<span class="op">&lt;</span>charT<span class="op">&gt;</span>, basic_string_view<span class="op">&lt;</span>charT<span class="op">&gt;)</span>;</span>
<span id="cb28-6"><a href="#cb28-6"></a></span>
<span id="cb28-7"><a href="#cb28-7"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> ParseContext<span class="op">&gt;</span></span>
<span id="cb28-8"><a href="#cb28-8"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> parse<span class="op">(</span>ParseContext<span class="op">&amp;)</span> <span class="op">-&gt;</span> ParseContext<span class="op">::</span>iterator;</span>
<span id="cb28-9"><a href="#cb28-9"></a></span>
<span id="cb28-10"><a href="#cb28-10"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> FormatContext<span class="op">&gt;</span></span>
<span id="cb28-11"><a href="#cb28-11"></a>    <span class="kw">auto</span> format<span class="op">(</span><em>POSSIBLY-CONST</em><span class="op">&amp;</span> elems, FormatContext<span class="op">&amp;)</span> <span class="kw">const</span> <span class="op">-&gt;</span> FormatContext<span class="op">::</span>iterator;</span>
<span id="cb28-12"><a href="#cb28-12"></a><span class="op">}</span>;</span></code></pre></div>
</blockquote>
<p>The type <code class="sourceCode cpp"><em>POSSIBLY-CONST</em></code> is <code class="sourceCode cpp"><em>TEMPLATE</em><span class="op">&lt;</span>Ts<span class="op">...&gt;</span> <span class="kw">const</span></code> when that type is formattable (i.e. all of <code class="sourceCode cpp">Ts <span class="kw">const</span><span class="op">...</span></code> are formattable) and <code class="sourceCode cpp"><em>TEMPLATE</em><span class="op">&lt;</span>Ts<span class="op">...&gt;</span></code> otherwise, in an effort to reduce unnecessary template instantiations.</p>
<p>Otherwise, it’s a similar structure to <code class="sourceCode cpp">range_formatter</code> for similar reasons (except no <code class="sourceCode cpp">underlying<span class="op">()</span></code> since I’m not sure you need it).</p>
<h2 data-number="3.7" id="what-additional-functionality"><span class="header-section-number">3.7</span> What additional functionality?<a href="#what-additional-functionality" class="self-link"></a></h2>
<p>There’s three layers of potential functionality:</p>
<ol type="1">
<li><p>Top-level printing of ranges: this is <code class="sourceCode cpp">fmt<span class="op">::</span>print<span class="op">(</span><span class="st">&quot;{}&quot;</span>, r<span class="op">)</span></code>;</p></li>
<li><p>A format-joiner which allows providing a a custom delimiter: this is provided in <code class="sourceCode cpp"><span class="op">{</span>fmt<span class="op">}</span></code> under the spelling <code class="sourceCode cpp">fmt<span class="op">::</span>print<span class="op">(</span><span class="st">&quot;{:02x}&quot;</span>, fmt<span class="op">::</span>join<span class="op">(</span>r, <span class="st">&quot;:&quot;</span><span class="op">))</span></code>. Previous revisions of the paper either sought to simply standardize this under the name <code class="sourceCode cpp">std<span class="op">::</span>format_join</code> (<span class="citation" data-cites="P2286R3">[<a href="#ref-P2286R3" role="doc-biblioref">P2286R3</a>]</span>), or to add the ability to specify a custom delimiter under the <code class="sourceCode cpp">d</code> specifier (<span class="citation" data-cites="P2286R4">[<a href="#ref-P2286R4" role="doc-biblioref">P2286R4</a>]</span>), but this paper does not actually provide such a facility directly.</p></li>
<li><p>A more involved version of a format-joiner which takes a delimiter and a callback that gets invoked on each element. fmt does not provide such a mechanism, though the Rust itertools library does:</p></li>
</ol>
<blockquote>
<div class="sourceCode" id="cb11"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">let</span> matrix <span class="op">=</span> [[<span class="dv">1</span><span class="op">.,</span> <span class="dv">2</span><span class="op">.,</span> <span class="dv">3</span><span class="op">.</span>]<span class="op">,</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>              [<span class="dv">4</span><span class="op">.,</span> <span class="dv">5</span><span class="op">.,</span> <span class="dv">6</span><span class="op">.</span>]]<span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="kw">let</span> matrix_formatter <span class="op">=</span> matrix<span class="op">.</span>iter()<span class="op">.</span>format_with(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">|</span>row<span class="op">,</span> f<span class="op">|</span> <span class="op">{</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>                                f(<span class="op">&amp;</span>row<span class="op">.</span>iter()<span class="op">.</span>format_with(<span class="st">&quot;, &quot;</span><span class="op">,</span> <span class="op">|</span>elt<span class="op">,</span> g<span class="op">|</span> g(<span class="op">&amp;</span>elt)))</span>
<span id="cb11-5"><a href="#cb11-5"></a>                              <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="pp">assert_eq!</span>(<span class="pp">format!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> matrix_formatter)<span class="op">,</span></span>
<span id="cb11-7"><a href="#cb11-7"></a>           <span class="st">&quot;1, 2, 3</span><span class="sc">\n</span><span class="st">4, 5, 6&quot;</span>)<span class="op">;</span></span></code></pre></div>
</blockquote>
<p>The paper provides the tools to implement to implement (2) and (3), but does not directly propose either.</p>
<p>For example, here is an implementation of <code class="sourceCode cpp">format_join<span class="op">(</span>r, delim<span class="op">)</span></code>:</p>
<blockquote>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1"></a><span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>ranges<span class="op">::</span>input_range V<span class="op">&gt;</span></span>
<span id="cb29-2"><a href="#cb29-2"></a>    <span class="kw">requires</span> std<span class="op">::</span>ranges<span class="op">::</span>view<span class="op">&lt;</span>V<span class="op">&gt;</span></span>
<span id="cb29-3"><a href="#cb29-3"></a>          <span class="op">&amp;&amp;</span> std<span class="op">::</span>formattable<span class="op">&lt;</span>std<span class="op">::</span>ranges<span class="op">::</span>range_reference_t<span class="op">&lt;</span>V<span class="op">&gt;&gt;</span></span>
<span id="cb29-4"><a href="#cb29-4"></a><span class="kw">struct</span> format_join_view <span class="op">{</span></span>
<span id="cb29-5"><a href="#cb29-5"></a>    V v;</span>
<span id="cb29-6"><a href="#cb29-6"></a>    std<span class="op">::</span>string_view delim;</span>
<span id="cb29-7"><a href="#cb29-7"></a><span class="op">}</span>;</span>
<span id="cb29-8"><a href="#cb29-8"></a></span>
<span id="cb29-9"><a href="#cb29-9"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> V<span class="op">&gt;</span></span>
<span id="cb29-10"><a href="#cb29-10"></a><span class="kw">struct</span> std<span class="op">::</span>formatter<span class="op">&lt;</span>format_join_view<span class="op">&lt;</span>V<span class="op">&gt;&gt;</span></span>
<span id="cb29-11"><a href="#cb29-11"></a><span class="op">{</span></span>
<span id="cb29-12"><a href="#cb29-12"></a>    std<span class="op">::</span>range_formatter<span class="op">&lt;</span>std<span class="op">::</span>remove_cvref_t<span class="op">&lt;</span>std<span class="op">::</span>ranges<span class="op">::</span>range_reference_t<span class="op">&lt;</span>V<span class="op">&gt;&gt;&gt;</span> underlying;</span>
<span id="cb29-13"><a href="#cb29-13"></a></span>
<span id="cb29-14"><a href="#cb29-14"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> ParseContext<span class="op">&gt;</span></span>
<span id="cb29-15"><a href="#cb29-15"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> parse<span class="op">(</span>ParseContext<span class="op">&amp;</span> ctx<span class="op">)</span> <span class="op">{</span></span>
<span id="cb29-16"><a href="#cb29-16"></a>        <span class="cf">return</span> underlying<span class="op">.</span>parse<span class="op">(</span>ctx<span class="op">)</span>;</span>
<span id="cb29-17"><a href="#cb29-17"></a>    <span class="op">}</span></span>
<span id="cb29-18"><a href="#cb29-18"></a></span>
<span id="cb29-19"><a href="#cb29-19"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> R, <span class="kw">typename</span> FormatContext<span class="op">&gt;</span></span>
<span id="cb29-20"><a href="#cb29-20"></a>    <span class="kw">auto</span> format<span class="op">(</span>R<span class="op">&amp;&amp;</span> r, FormatContext<span class="op">&amp;</span> ctx<span class="op">)</span> <span class="kw">const</span> <span class="op">{</span></span>
<span id="cb29-21"><a href="#cb29-21"></a>        underlying<span class="op">.</span>set_separator<span class="op">(</span>r<span class="op">.</span>delim<span class="op">)</span>;</span>
<span id="cb29-22"><a href="#cb29-22"></a>        <span class="cf">return</span> underlying<span class="op">.</span>format<span class="op">(</span>r, ctx<span class="op">)</span>;</span>
<span id="cb29-23"><a href="#cb29-23"></a>    <span class="op">}</span></span>
<span id="cb29-24"><a href="#cb29-24"></a><span class="op">}</span>;</span>
<span id="cb29-25"><a href="#cb29-25"></a></span>
<span id="cb29-26"><a href="#cb29-26"></a><span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>ranges<span class="op">::</span>viewable_range R<span class="op">&gt;</span></span>
<span id="cb29-27"><a href="#cb29-27"></a>    <span class="kw">requires</span> std<span class="op">::</span>formattable<span class="op">&lt;</span>std<span class="op">::</span>ranges<span class="op">::</span>range_reference_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;</span></span>
<span id="cb29-28"><a href="#cb29-28"></a><span class="kw">auto</span> format_join<span class="op">(</span>R<span class="op">&amp;&amp;</span> r, std<span class="op">::</span>string_view delim<span class="op">)</span> <span class="op">{</span></span>
<span id="cb29-29"><a href="#cb29-29"></a>    <span class="cf">return</span> format_join_view<span class="op">{</span>std<span class="op">::</span>views<span class="op">::</span>all<span class="op">(</span>std<span class="op">::</span>forward<span class="op">&lt;</span>R<span class="op">&gt;(</span>r<span class="op">))</span>, delim<span class="op">}</span>;</span>
<span id="cb29-30"><a href="#cb29-30"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<h2 data-number="3.8" id="format-or-stdcout"><span class="header-section-number">3.8</span> <code class="sourceCode cpp">format</code> or <code class="sourceCode cpp">std<span class="op">::</span>cout</code>?<a href="#format-or-stdcout" class="self-link"></a></h2>
<p>Just <code class="sourceCode cpp">format</code> is sufficient.</p>
<h2 data-number="3.9" id="what-about-vectorbool"><span class="header-section-number">3.9</span> What about <code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;</span></code>?<a href="#what-about-vectorbool" class="self-link"></a></h2>
<p>Nobody expected this section.</p>
<p>The <code class="sourceCode cpp">value_type</code> of this range is <code class="sourceCode cpp"><span class="dt">bool</span></code>, which is formattable. But the <code class="sourceCode cpp">reference</code> type of this range is <code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;::</span>reference</code>, which is not. In order to make the whole type formattable, we can either make <code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;::</span>reference</code> formattable (and thus, in general, a range is formattable if its <code class="sourceCode cpp">reference</code> types is formattable) or allow formatting to fall back to constructing a <code class="sourceCode cpp">value_type</code> for each <code class="sourceCode cpp">reference</code> (and thus, in general, a range is formattable if either its <code class="sourceCode cpp">reference</code> type or its <code class="sourceCode cpp">value_type</code> is formattable).</p>
<p>For most ranges, the <code class="sourceCode cpp">value_type</code> is <code class="sourceCode cpp">remove_cvref_t<span class="op">&lt;</span>reference<span class="op">&gt;</span></code>, so there’s no distinction here between the two options. And even for <code class="sourceCode cpp">zip</code> <span class="citation" data-cites="P2321R2">[<a href="#ref-P2321R2" role="doc-biblioref">P2321R2</a>]</span>, there’s still not much distinction since it just wraps this question in tuple since again for most ranges the types will be something like <code class="sourceCode cpp">tuple<span class="op">&lt;</span>T, U<span class="op">&gt;</span></code> vs <code class="sourceCode cpp">tuple<span class="op">&lt;</span>T<span class="op">&amp;</span>, U <span class="kw">const</span><span class="op">&amp;&gt;</span></code>, so again there isn’t much distinction.</p>
<p><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;</span></code> is one of the very few ranges in which the two types are truly quite different. So it doesn’t offer much in the way of a good example here, since <code class="sourceCode cpp"><span class="dt">bool</span></code> is cheaply constructible from <code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;::</span>reference</code>. Though it’s also very cheap to provide a formatter specialization for <code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;::</span>reference</code>.</p>
<p>Rather than having the library provide a default fallback that lifts all the <code class="sourceCode cpp">reference</code> types to <code class="sourceCode cpp">value_type</code>s, which may be arbitrarily expensive for unknown ranges, this paper proposes a format specialization for <code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;::</span>reference</code>. This type is actually defined as <code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">bool</span>, Alloc<span class="op">&gt;::</span>reference</code>, so the wording for this aspect will be a little awkward (we’ll need to provide a type trait <code class="sourceCode cpp"><em>is-vector-bool-reference</em><span class="op">&lt;</span>R<span class="op">&gt;</span></code>, etc., but this is a problem for the wording and the implementation to deal with).</p>
<h2 data-number="3.10" id="what-about-container-adaptors"><span class="header-section-number">3.10</span> What about container adaptors?<a href="#what-about-container-adaptors" class="self-link"></a></h2>
<p>The standard library has three container adaptors: <code class="sourceCode cpp">queue</code>, <code class="sourceCode cpp">priority_queue</code>, and <code class="sourceCode cpp">stack</code>. None of these are actually ranges, none of them defines a <code class="sourceCode cpp">begin<span class="op">()</span></code> or an <code class="sourceCode cpp">end<span class="op">()</span></code> or any kind of iterator. But they do all adapt a range, which is a specified protected member. It is still useful, especially for debugging purposes, to be able to simply print what’s in your <code class="sourceCode cpp">stack</code>.</p>
<p>Note that we don’t have to <em>specifically</em> add support for this, as users can always work around it themselves:</p>
<blockquote>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1"></a><span class="kw">struct</span> hack <span class="op">:</span> std<span class="op">::</span>stack<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb30-2"><a href="#cb30-2"></a>    <span class="kw">using</span> std<span class="op">::</span>stack<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>c;</span>
<span id="cb30-3"><a href="#cb30-3"></a><span class="op">}</span>;</span>
<span id="cb30-4"><a href="#cb30-4"></a></span>
<span id="cb30-5"><a href="#cb30-5"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb30-6"><a href="#cb30-6"></a>    std<span class="op">::</span>stack<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> s;</span>
<span id="cb30-7"><a href="#cb30-7"></a>    s<span class="op">.</span>push<span class="op">(</span><span class="dv">1</span><span class="op">)</span>;</span>
<span id="cb30-8"><a href="#cb30-8"></a>    s<span class="op">.</span>push<span class="op">(</span><span class="dv">2</span><span class="op">)</span>;</span>
<span id="cb30-9"><a href="#cb30-9"></a>    std<span class="op">::</span>print<span class="op">(</span><span class="st">&quot;{}</span><span class="sc">\n</span><span class="st">&quot;</span>, s<span class="op">.*&amp;</span>hack<span class="op">::</span>c<span class="op">)</span>;</span>
<span id="cb30-10"><a href="#cb30-10"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>That’s valid, probably the best way to solve this problem, yet also not the kind of thing we want to encourage people to do. This paper thus proposes that <code class="sourceCode cpp">queue</code>, <code class="sourceCode cpp">priority_queue</code>, and <code class="sourceCode cpp">stack</code> are formattable as their underlying container type.</p>
<p>This does lead to one quirk, which is <code class="sourceCode cpp">priority_queue</code>. If we simply defer to the underlying container’s formatting, then we get behavior like this:</p>
<blockquote>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb31-2"><a href="#cb31-2"></a>    std<span class="op">::</span>priority_queue<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> s;</span>
<span id="cb31-3"><a href="#cb31-3"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span>; i <span class="op">&lt;</span> <span class="dv">10</span>; <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb31-4"><a href="#cb31-4"></a>        s<span class="op">.</span>push<span class="op">(</span>i<span class="op">)</span>;</span>
<span id="cb31-5"><a href="#cb31-5"></a>    <span class="op">}</span></span>
<span id="cb31-6"><a href="#cb31-6"></a>    std<span class="op">::</span>print<span class="op">(</span><span class="st">&quot;{}</span><span class="sc">\n</span><span class="st">&quot;</span>, s<span class="op">)</span>; <span class="co">// prints [9, 8, 5, 6, 7, 1, 4, 0, 3, 2]</span></span>
<span id="cb31-7"><a href="#cb31-7"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>That is not the order of elements in the <code class="sourceCode cpp">s</code>, at least not the way we typically think of things. <code class="sourceCode cpp">s<span class="op">.</span>top<span class="op">()</span></code> is <code class="sourceCode cpp"><span class="dv">9</span></code>, but the rest of the elements are not in this order. But also… that’s fine. This is still a useful representation for formatting (this is exactly the underlying representation), they are free to either access <code class="sourceCode cpp">s<span class="op">.&amp;</span>hack<span class="op">::</span>c</code> and figure out how to print it in “the right order” or write their own <code class="sourceCode cpp">priority_queue</code> with its own custom formatting.</p>
<h2 data-number="3.11" id="examples-with-user-defined-types"><span class="header-section-number">3.11</span> Examples with user-defined types<a href="#examples-with-user-defined-types" class="self-link"></a></h2>
<p>Let’s say a user has a type like:</p>
<blockquote>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1"></a><span class="kw">struct</span> Foo <span class="op">{</span></span>
<span id="cb32-2"><a href="#cb32-2"></a>    <span class="dt">int</span> bar;</span>
<span id="cb32-3"><a href="#cb32-3"></a>    std<span class="op">::</span>string baz;</span>
<span id="cb32-4"><a href="#cb32-4"></a><span class="op">}</span>;</span></code></pre></div>
</blockquote>
<p>And want to format <code class="sourceCode cpp">Foo<span class="op">{.</span>bar<span class="op">=</span><span class="dv">10</span>, <span class="op">.</span>baz<span class="op">=</span><span class="st">&quot;Hello World&quot;</span><span class="op">}</span></code> as the string <code class="sourceCode cpp">Foo<span class="op">(</span>bar<span class="op">=</span><span class="dv">10</span>, baz<span class="op">=</span><span class="st">&quot;Hello World&quot;</span><span class="op">)</span></code>. They can do so this way:</p>
<blockquote>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1"></a><span class="kw">template</span> <span class="op">&lt;&gt;</span></span>
<span id="cb33-2"><a href="#cb33-2"></a><span class="kw">struct</span> formatter<span class="op">&lt;</span>Foo, <span class="dt">char</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb33-3"><a href="#cb33-3"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> FormatContext<span class="op">&gt;</span></span>
<span id="cb33-4"><a href="#cb33-4"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> format<span class="op">(</span>Foo <span class="kw">const</span><span class="op">&amp;</span> f, FormatContext<span class="op">&amp;</span> ctx<span class="op">)</span> <span class="kw">const</span> <span class="op">{</span></span>
<span id="cb33-5"><a href="#cb33-5"></a>        <span class="cf">return</span> format_to<span class="op">(</span>ctx<span class="op">.</span>out<span class="op">()</span>, <span class="st">&quot;Foo(bar={}, baz={:?})&quot;</span>, f<span class="op">.</span>bar, f<span class="op">.</span>baz<span class="op">)</span>;</span>
<span id="cb33-6"><a href="#cb33-6"></a>    <span class="op">}</span></span>
<span id="cb33-7"><a href="#cb33-7"></a><span class="op">}</span>;</span></code></pre></div>
</blockquote>
<p>How about wrappers?</p>
<p>Let’s say you have your own implementation of <code class="sourceCode cpp">Optional</code>, that you want to format the same way that Rust does: so that a disengaged one formats as <code class="sourceCode cpp">None</code> and an engaged one formats as <code class="sourceCode cpp">Some<span class="op">(??)</span></code>. We can start by:</p>
<blockquote>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1"></a><span class="kw">template</span> <span class="op">&lt;</span>formattable<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;</span> T<span class="op">&gt;</span></span>
<span id="cb34-2"><a href="#cb34-2"></a><span class="kw">struct</span> formatter<span class="op">&lt;</span>Optional<span class="op">&lt;</span>T<span class="op">&gt;</span>, <span class="dt">char</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb34-3"><a href="#cb34-3"></a>    <span class="co">// we&#39;ll skip parse for now</span></span>
<span id="cb34-4"><a href="#cb34-4"></a></span>
<span id="cb34-5"><a href="#cb34-5"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> FormatContext<span class="op">&gt;</span></span>
<span id="cb34-6"><a href="#cb34-6"></a>    <span class="kw">auto</span> format<span class="op">(</span>Optional<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> opt, FormatContext<span class="op">&amp;</span> ctx<span class="op">)</span> <span class="op">{</span></span>
<span id="cb34-7"><a href="#cb34-7"></a>        <span class="cf">if</span> <span class="op">(</span><span class="kw">not</span> opt<span class="op">)</span> <span class="op">{</span></span>
<span id="cb34-8"><a href="#cb34-8"></a>            <span class="cf">return</span> format_to<span class="op">(</span>ctx<span class="op">.</span>out<span class="op">()</span>, <span class="st">&quot;None&quot;</span><span class="op">)</span>;</span>
<span id="cb34-9"><a href="#cb34-9"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb34-10"><a href="#cb34-10"></a>            <span class="cf">return</span> format_to<span class="op">(</span>ctx<span class="op">.</span>out<span class="op">()</span>, <span class="st">&quot;Some({})&quot;</span>, <span class="op">*</span>opt<span class="op">)</span>;</span>
<span id="cb34-11"><a href="#cb34-11"></a>        <span class="op">}</span></span>
<span id="cb34-12"><a href="#cb34-12"></a>    <span class="op">}</span></span>
<span id="cb34-13"><a href="#cb34-13"></a><span class="op">}</span>;</span></code></pre></div>
</blockquote>
<p>If we had an <code class="sourceCode cpp">Optional<span class="op">&lt;</span>string<span class="op">&gt;(</span><span class="st">&quot;hello&quot;</span><span class="op">)</span></code>, this would format as <code class="sourceCode cpp">Some<span class="op">(</span>hello<span class="op">)</span></code>. Which may be fine. But what if we wanted to format it as <code class="sourceCode cpp">Some<span class="op">(</span><span class="st">&quot;hello&quot;</span><span class="op">)</span></code> instead? That is, take advantage of the quoting rules described earlier. What do you write instead of <code class="sourceCode cpp"><span class="op">*</span>opt</code> to format <code class="sourceCode cpp">string</code>s (or <code class="sourceCode cpp"><span class="dt">char</span></code>s or user-defined string-like types) as quoted in this context?</p>
<p>We can both add support for quoting/escaping and also arbitrary specifiers at the same time:</p>
<blockquote>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1"></a><span class="kw">template</span> <span class="op">&lt;</span>formattable<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;</span> T<span class="op">&gt;</span></span>
<span id="cb35-2"><a href="#cb35-2"></a><span class="kw">struct</span> formatter<span class="op">&lt;</span>Optional<span class="op">&lt;</span>T<span class="op">&gt;</span>, <span class="dt">char</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb35-3"><a href="#cb35-3"></a>    formatter<span class="op">&lt;</span>T, <span class="dt">char</span><span class="op">&gt;</span> underlying;</span>
<span id="cb35-4"><a href="#cb35-4"></a></span>
<span id="cb35-5"><a href="#cb35-5"></a>    formatter<span class="op">()</span> <span class="op">{</span></span>
<span id="cb35-6"><a href="#cb35-6"></a>        <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span><span class="kw">requires</span> <span class="op">{</span> underlying<span class="op">.</span>set_debug_format<span class="op">()</span>; <span class="op">})</span> <span class="op">{</span></span>
<span id="cb35-7"><a href="#cb35-7"></a>            underlying<span class="op">.</span>set_debug_format<span class="op">()</span>;</span>
<span id="cb35-8"><a href="#cb35-8"></a>        <span class="op">}</span></span>
<span id="cb35-9"><a href="#cb35-9"></a>    <span class="op">}</span></span>
<span id="cb35-10"><a href="#cb35-10"></a></span>
<span id="cb35-11"><a href="#cb35-11"></a>    <span class="kw">template</span> <span class="op">&lt;</span>typenaem ParseContext<span class="op">&gt;</span></span>
<span id="cb35-12"><a href="#cb35-12"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> parse<span class="op">(</span>ParseContext<span class="op">&amp;</span> ctx<span class="op">)</span> <span class="op">{</span></span>
<span id="cb35-13"><a href="#cb35-13"></a>        <span class="cf">return</span> underlying<span class="op">.</span>parse<span class="op">(</span>ctx<span class="op">)</span>;</span>
<span id="cb35-14"><a href="#cb35-14"></a>    <span class="op">}</span></span>
<span id="cb35-15"><a href="#cb35-15"></a></span>
<span id="cb35-16"><a href="#cb35-16"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> FormatContext<span class="op">&gt;</span></span>
<span id="cb35-17"><a href="#cb35-17"></a>    <span class="kw">auto</span> format<span class="op">(</span>Optional<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> opt, FormatContext<span class="op">&amp;</span> ctx<span class="op">)</span> <span class="op">{</span></span>
<span id="cb35-18"><a href="#cb35-18"></a>        <span class="cf">if</span> <span class="op">(</span><span class="kw">not</span> opt<span class="op">)</span> <span class="op">{</span></span>
<span id="cb35-19"><a href="#cb35-19"></a>            <span class="cf">return</span> format_to<span class="op">(</span>ctx<span class="op">.</span>out<span class="op">()</span>, <span class="st">&quot;None&quot;</span><span class="op">)</span>;</span>
<span id="cb35-20"><a href="#cb35-20"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb35-21"><a href="#cb35-21"></a>            ctx<span class="op">.</span>advance_to<span class="op">(</span>format_to<span class="op">(</span>ctx<span class="op">.</span>out<span class="op">()</span>, <span class="st">&quot;Some(&quot;</span><span class="op">))</span>;</span>
<span id="cb35-22"><a href="#cb35-22"></a>            <span class="kw">auto</span> out <span class="op">=</span> underlying<span class="op">.</span>format<span class="op">(*</span>opt, ctx<span class="op">)</span>;</span>
<span id="cb35-23"><a href="#cb35-23"></a>            <span class="op">*</span>out<span class="op">++</span> <span class="op">=</span> <span class="ch">&#39;)&#39;</span>;</span>
<span id="cb35-24"><a href="#cb35-24"></a>            <span class="cf">return</span> out;</span>
<span id="cb35-25"><a href="#cb35-25"></a>        <span class="op">}</span></span>
<span id="cb35-26"><a href="#cb35-26"></a>    <span class="op">}</span></span>
<span id="cb35-27"><a href="#cb35-27"></a><span class="op">}</span>;</span></code></pre></div>
</blockquote>
<p>This lets me format <code class="sourceCode cpp">Optional<span class="op">&lt;</span>string<span class="op">&gt;(</span><span class="st">&quot;hello&quot;</span><span class="op">)</span></code> as <code class="x">Some(&quot;hello&quot;)</code> by default, or format <code class="sourceCode cpp">Optional<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="dv">42</span><span class="op">)</span></code> as <code class="x">Some(0x2a)</code> if I provide the specifier string <code class="sourceCode cpp"><span class="st">&quot;{:#x}&quot;</span></code>.</p>
<h1 data-number="4" style="border-bottom:1px solid #cccccc" id="proposal"><span class="header-section-number">4</span> Proposal<a href="#proposal" class="self-link"></a></h1>
<p>The standard library will provide the following utilities:</p>
<ul>
<li><p>A <code class="sourceCode cpp">formattable</code> concept.</p></li>
<li><p>A <code class="sourceCode cpp">range_formatter<span class="op">&lt;</span>V<span class="op">&gt;</span></code> that uses a <code class="sourceCode cpp">formatter<span class="op">&lt;</span>V<span class="op">&gt;</span></code> to <code class="sourceCode cpp">parse</code> and <code class="sourceCode cpp">format</code> a range whose <code class="sourceCode cpp">reference</code> is similar to <code class="sourceCode cpp">V</code>. This can accept a specifier on the range (align/pad/width as well as string/map/debug/empty) and on the underlying element (which will be applied to every element in the range). This will additionally have a few public member functions to facilitate users build custom range formatters, as detailed <a href="#interface-of-the-proposed-solution">here</a>:</p>
<ul>
<li><code class="sourceCode cpp">set_separator<span class="op">(</span>string_view<span class="op">)</span></code></li>
<li><code class="sourceCode cpp">set_brackets<span class="op">(</span>string_view, string_view<span class="op">)</span></code></li>
<li><code class="sourceCode cpp">underlying<span class="op">()</span></code></li>
</ul></li>
</ul>
<p>The standard library should add specializations of <code class="sourceCode cpp">formatter</code> for:</p>
<ul>
<li>any type <code class="sourceCode cpp">R</code> that is an <code class="sourceCode cpp">input_range</code> whose <code class="sourceCode cpp">reference</code> is <code class="sourceCode cpp">formattable</code>, which is specified using <code class="sourceCode cpp">range_formatter<span class="op">&lt;</span>remove_cvref_t<span class="op">&lt;</span>ranges<span class="op">::</span>range_reference_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;&gt;</span></code></li>
<li><code class="sourceCode cpp">pair<span class="op">&lt;</span>T, U<span class="op">&gt;</span></code> if <code class="sourceCode cpp">T</code> and <code class="sourceCode cpp">U</code> are <code class="sourceCode cpp">formattable</code> (additionally with <code class="sourceCode cpp">set_separator</code> and <code class="sourceCode cpp">set_brackets</code>)</li>
<li><code class="sourceCode cpp">tuple<span class="op">&lt;</span>Ts<span class="op">...&gt;</span></code> if all of <code class="sourceCode cpp">Ts<span class="op">...</span></code> are <code class="sourceCode cpp">formattable</code> (additionally with <code class="sourceCode cpp">set_separator</code> and <code class="sourceCode cpp">set_brackets</code>)</li>
</ul>
<p>Additionally, the standard library should provide the following more specific specializations of <code class="sourceCode cpp">formatter</code>:</p>
<ul>
<li><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">bool</span>, Alloc<span class="op">&gt;::</span>reference</code> (which formats as a <code class="sourceCode cpp"><span class="dt">bool</span></code>)</li>
<li>all the associative maps (<code class="sourceCode cpp">map</code>, <code class="sourceCode cpp">multimap</code>, <code class="sourceCode cpp">unordered_map</code>, <code class="sourceCode cpp">unordered_multimap</code>) if their respective key/value types are <code class="sourceCode cpp">formattable</code>. This accepts the same set of specifiers as any other range, except by <em>default</em> it will format as <code class="sourceCode cpp"><span class="op">{</span>k<span class="op">:</span> v, k<span class="op">:</span> v<span class="op">}</span></code> instead of <code class="sourceCode cpp"><span class="op">[(</span>k, v<span class="op">)</span>, <span class="op">(</span>k, v<span class="op">)]</span></code></li>
<li>all the associative sets (<code class="sourceCode cpp">sets</code>, <code class="sourceCode cpp">multiset</code>, <code class="sourceCode cpp">unordered_set</code>, <code class="sourceCode cpp">unordered_multiset</code>) if their respective key/value types are <code class="sourceCode cpp">formattable</code>. This accepts the same set of specifiers as any other range, except by <em>default</em> it will format as <code class="sourceCode cpp"><span class="op">{</span>v1, v2<span class="op">}</span></code> instead of <code class="sourceCode cpp"><span class="op">[</span>v1, v2<span class="op">]</span></code></li>
<li><code class="sourceCode cpp">queue</code>, <code class="sourceCode cpp">stack</code>, and <code class="sourceCode cpp">priority_queue</code>, which defer to their underlying representations.</li>
</ul>
<p>Formatting for <code class="sourceCode cpp">string</code>, <code class="sourceCode cpp">string_view</code>, <code class="sourceCode cpp"><span class="kw">const</span> <span class="dt">char</span><span class="op">*</span></code>, and <code class="sourceCode cpp"><span class="dt">char</span></code> (and all the <code class="sourceCode cpp"><span class="dt">wchar_t</span></code> equivalents) will gain a <code class="sourceCode cpp"><span class="op">?</span></code> specifier as well as a <code class="sourceCode cpp">set_debug_format<span class="op">()</span></code> member function, which causes these types to be printed as <a href="#escaping-behavior">escaped and quoted</a> if provided. Ranges and tuples will, by default, print their elements as escaped and quoted, unless the user provides a specifier for the element.</p>
<h1 data-number="5" style="border-bottom:1px solid #cccccc" id="wording"><span class="header-section-number">5</span> Wording<a href="#wording" class="self-link"></a></h1>
<p>The wording here is grouped by functionality added rather than linearly going through the standard text.</p>
<h2 data-number="5.1" id="concept-formattable"><span class="header-section-number">5.1</span> Concept <code class="sourceCode cpp">formattable</code><a href="#concept-formattable" class="self-link"></a></h2>
<p>First, we need to define a user-facing concept. We need this because we need to constrain <code class="sourceCode cpp">formatter</code> specializations on whether the underlying elements of the <code class="sourceCode cpp">pair</code>/<code class="sourceCode cpp">tuple</code>/range are formattable, and users would need to do the same kind of thing for their types. This is tricky since formatting involves so many different types, so this concept will never be perfect, so instead we’re trying to be good enough.</p>
<p>Change <span>22.14.1 <a href="https://wg21.link/format.syn">[format.syn]</a></span>:</p>
<blockquote>
<div>
<div class="sourceCode" id="cb36"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb36-1"><a href="#cb36-1"></a>namespace std {</span>
<span id="cb36-2"><a href="#cb36-2"></a>  // ...</span>
<span id="cb36-3"><a href="#cb36-3"></a>  // [format.formatter], formatter</span>
<span id="cb36-4"><a href="#cb36-4"></a>  template&lt;class T, class charT = char&gt; struct formatter;</span>
<span id="cb36-5"><a href="#cb36-5"></a></span>
<span id="cb36-6"><a href="#cb36-6"></a>  // [format.parse.ctx], class template basic_format_parse_context</span>
<span id="cb36-7"><a href="#cb36-7"></a>  template&lt;class charT&gt; class basic_format_parse_context;</span>
<span id="cb36-8"><a href="#cb36-8"></a>  using format_parse_context = basic_format_parse_context&lt;char&gt;;</span>
<span id="cb36-9"><a href="#cb36-9"></a>  using wformat_parse_context = basic_format_parse_context&lt;wchar_t&gt;;</span>
<span id="cb36-10"><a href="#cb36-10"></a></span>
<span id="cb36-11"><a href="#cb36-11"></a><span class="va">+ // [format.formattable], formattable</span></span>
<span id="cb36-12"><a href="#cb36-12"></a><span class="va">+ template&lt;class T, class charT&gt;</span></span>
<span id="cb36-13"><a href="#cb36-13"></a><span class="va">+   concept formattable = <em>see below</em>;</span></span>
<span id="cb36-14"><a href="#cb36-14"></a><span class="va">+</span></span>
<span id="cb36-15"><a href="#cb36-15"></a><span class="va">+ template&lt;class T, class charT&gt;</span></span>
<span id="cb36-16"><a href="#cb36-16"></a><span class="va">+   using <em>fmt-maybe-const</em> = conditional_t&lt;formattable&lt;const T, charT&gt;, const T, T&gt;; // exposition only</span></span>
<span id="cb36-17"><a href="#cb36-17"></a>  // ...</span>
<span id="cb36-18"><a href="#cb36-18"></a>}</span></code></pre></div>
</div>
</blockquote>
<p>Add a clause [format.formattable] under <span>22.14.6 <a href="https://wg21.link/format.formatter">[format.formatter]</a></span> and likely after <span>22.14.6.1 <a href="https://wg21.link/formatter.requirements">[formatter.requirements]</a></span>:</p>
<blockquote>
<div class="addu">
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_1" id="pnum_1">1</a></span> Let <code class="sourceCode cpp"><em>fmt-iter-for</em><span class="op">&lt;</span>charT<span class="op">&gt;</span></code> be an unspecified type that models <code class="sourceCode cpp">output_iterator<span class="op">&lt;</span><span class="kw">const</span> charT<span class="op">&amp;&gt;</span></code> ([iterator.concept.output]).</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb37-1"><a href="#cb37-1"></a>template&lt;class T, class charT&gt;</span>
<span id="cb37-2"><a href="#cb37-2"></a>concept formattable =</span>
<span id="cb37-3"><a href="#cb37-3"></a>    semiregular&lt;formatter&lt;remove_cvref_t&lt;T&gt;, charT&gt;&gt; &amp;&amp;</span>
<span id="cb37-4"><a href="#cb37-4"></a>    requires (formatter&lt;remove_cvref_t&lt;T&gt;, charT&gt; f,</span>
<span id="cb37-5"><a href="#cb37-5"></a>              const formatter&lt;remove_cvref_t&lt;T&gt;, charT&gt; cf,</span>
<span id="cb37-6"><a href="#cb37-6"></a>              T t,</span>
<span id="cb37-7"><a href="#cb37-7"></a>              basic_format_context&lt;<em>fmt-iter-for</em>&lt;charT&gt;, charT&gt; fc,</span>
<span id="cb37-8"><a href="#cb37-8"></a>              basic_format_parse_context&lt;charT&gt; pc) {</span>
<span id="cb37-9"><a href="#cb37-9"></a>        { f.parse(pc) } -&gt; same_as&lt;basic_format_parse_context&lt;charT&gt;::iterator&gt;;</span>
<span id="cb37-10"><a href="#cb37-10"></a>        { cf.format(t, fc) } -&gt; same_as&lt;<em>fmt-iter-for</em>&lt;charT&gt;&gt;;</span>
<span id="cb37-11"><a href="#cb37-11"></a>    };</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_2" id="pnum_2">2</a></span> A type <code class="sourceCode cpp">T</code> and a character type <code class="sourceCode cpp">charT</code> model <code class="sourceCode cpp">formattable</code> if <code class="sourceCode cpp">formatter<span class="op">&lt;</span>remove_cvref_t<span class="op">&lt;</span>T<span class="op">&gt;</span>, charT<span class="op">&gt;</span></code> meets the <em>BasicFormatter</em> requirements ([formatter.requirements]) and, if <code class="sourceCode cpp">remove_reference_t<span class="op">&lt;</span>T<span class="op">&gt;</span></code> is <code class="sourceCode cpp"><span class="kw">const</span></code>-qualified, the <em>Formatter</em> requirements.</p>
</div>
</blockquote>
<h2 data-number="5.2" id="additional-formatting-support-for-characters-and-strings"><span class="header-section-number">5.2</span> Additional formatting support for characters and strings<a href="#additional-formatting-support-for-characters-and-strings" class="self-link"></a></h2>
<p>Change <span>22.14.2.2 <a href="https://wg21.link/format.string.std">[format.string.std]</a></span> to add <code class="sourceCode cpp"><span class="op">?</span></code> as a valid type:</p>
<blockquote>
<p>The syntax of format specifications is as follows:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb38-1"><a href="#cb38-1"></a><em>type</em>: one of</span>
<span id="cb38-2"><a href="#cb38-2"></a>  a A b B c d e E f F g G o p s x X <span class="addu">?</span></span></code></pre></div>
</blockquote>
<p>Add <code class="sourceCode cpp"><span class="op">?</span></code> to the strings table in <span>22.14.2.2 <a href="https://wg21.link/format.string.std">[format.string.std]</a></span>/17 (Table 64):</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_3" id="pnum_3">17</a></span> The available string presentation types are specified in Table 64.</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Type</strong>
</div></th>
<th><div style="text-align:center">
<strong>Meaning</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>none, <code class="sourceCode cpp">s</code></td>
<td>Copies the string to the output.</td>
</tr>
<tr class="even">
<td><span class="addu">?</span></td>
<td><span class="addu">Copies the escaped string ([format.string.escaped]) to the output.</span></td>
</tr>
</tbody>
</table>
</blockquote>
<p>Add <code class="sourceCode cpp"><span class="op">?</span></code> to the <code class="sourceCode cpp">charT</code> table in <span>22.14.2.2 <a href="https://wg21.link/format.string.std">[format.string.std]</a></span>/20 (Table 66):</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_4" id="pnum_4">20</a></span> The available <code class="sourceCode cpp">charT</code> presentation types are specified in Table 66.</p>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Type</strong>
</div></th>
<th><div style="text-align:center">
<strong>Meaning</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>none, <code class="sourceCode cpp">c</code></td>
<td>Copies the character to the output.</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">b</code>,<code class="sourceCode cpp">B</code>,<code class="sourceCode cpp">d</code>,<code class="sourceCode cpp">o</code>,<code class="sourceCode cpp">x</code>,<code class="sourceCode cpp">X</code></td>
<td>As specified in Table 65.</td>
</tr>
<tr class="odd">
<td><span class="addu">?</span></td>
<td><span class="addu">Copies the escaped character ([format.string.escaped]) to the output.</span></td>
</tr>
</tbody>
</table>
</blockquote>
<p>Add <code class="sourceCode cpp">set_debug_format<span class="op">()</span></code> to the character and string specializations in <span>22.14.6.2 <a href="https://wg21.link/format.formatter.spec">[format.formatter.spec]</a></span>:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_5" id="pnum_5">1</a></span> The functions defined in [format.functions] use specializations of the class template <code class="sourceCode cpp">formatter</code> to format individual arguments.</p>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_6" id="pnum_6">2</a></span> Let <code class="sourceCode cpp">charT</code> be either <code class="sourceCode cpp"><span class="dt">char</span></code> or <code class="sourceCode cpp"><span class="dt">wchar_t</span></code>. Each specialization of <code class="sourceCode cpp">formatter</code> is either enabled or disabled, as described below. <span class="addu">A <em>debug-enabled</em> specialization of <code class="sourceCode cpp">formatter</code> additionally provides a public, constexpr, non-static member function <code class="sourceCode cpp">set_debug_format<span class="op">()</span></code> which modifies the state of the <code class="sourceCode cpp">formatter</code> to be as if the type of the <code class="sourceCode cpp"><em>std-format-spec</em></code> parsed by the last call to <code class="sourceCode cpp">parse</code> were <code class="sourceCode cpp"><span class="op">?</span></code>.</span> Each header that declares the template <code class="sourceCode cpp">formatter</code> provides the following enabled specializations:</p>
<ul>
<li><p><span class="marginalizedparent"><a class="marginalized" href="#pnum_7" id="pnum_7">(2.1)</a></span> The <span class="addu">debug-enabled</span> specializations</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1"></a><span class="kw">template</span><span class="op">&lt;&gt;</span> <span class="kw">struct</span> formatter<span class="op">&lt;</span><span class="dt">char</span>, <span class="dt">char</span><span class="op">&gt;</span>;</span>
<span id="cb39-2"><a href="#cb39-2"></a><span class="kw">template</span><span class="op">&lt;&gt;</span> <span class="kw">struct</span> formatter<span class="op">&lt;</span><span class="dt">char</span>, <span class="dt">wchar_t</span><span class="op">&gt;</span>;</span>
<span id="cb39-3"><a href="#cb39-3"></a><span class="kw">template</span><span class="op">&lt;&gt;</span> <span class="kw">struct</span> formatter<span class="op">&lt;</span><span class="dt">wchar_t</span>, <span class="dt">wchar_t</span><span class="op">&gt;</span>;</span></code></pre></div></li>
<li><p><span class="marginalizedparent"><a class="marginalized" href="#pnum_8" id="pnum_8">(2.2)</a></span> For each <code class="sourceCode cpp">charT</code>, the <span class="addu">debug-enabled</span> string type specializations</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1"></a><span class="kw">template</span><span class="op">&lt;&gt;</span> <span class="kw">struct</span> formatter<span class="op">&lt;</span>charT<span class="op">*</span>, charT<span class="op">&gt;</span>;</span>
<span id="cb40-2"><a href="#cb40-2"></a><span class="kw">template</span><span class="op">&lt;&gt;</span> <span class="kw">struct</span> formatter<span class="op">&lt;</span><span class="kw">const</span> charT<span class="op">*</span>, charT<span class="op">&gt;</span>;</span>
<span id="cb40-3"><a href="#cb40-3"></a><span class="kw">template</span><span class="op">&lt;</span><span class="dt">size_t</span> N<span class="op">&gt;</span> <span class="kw">struct</span> formatter<span class="op">&lt;</span><span class="kw">const</span> charT<span class="op">[</span>N<span class="op">]</span>, charT<span class="op">&gt;</span>;</span>
<span id="cb40-4"><a href="#cb40-4"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> traits, <span class="kw">class</span> Allocator<span class="op">&gt;</span></span>
<span id="cb40-5"><a href="#cb40-5"></a>  <span class="kw">struct</span> formatter<span class="op">&lt;</span>basic_string<span class="op">&lt;</span>charT, traits, Allocator<span class="op">&gt;</span>, charT<span class="op">&gt;</span>;</span>
<span id="cb40-6"><a href="#cb40-6"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> traits<span class="op">&gt;</span></span>
<span id="cb40-7"><a href="#cb40-7"></a>  <span class="kw">struct</span> formatter<span class="op">&lt;</span>basic_string_view<span class="op">&lt;</span>charT, traits<span class="op">&gt;</span>, charT<span class="op">&gt;</span>;</span></code></pre></div></li>
<li><p><span class="marginalizedparent"><a class="marginalized" href="#pnum_9" id="pnum_9">(2.3)</a></span> For each <code class="sourceCode cpp">charT</code>, for each <em>cv</em>-unqualified arithmetic type <code class="sourceCode cpp">ArithmeticT</code> other than <code class="sourceCode cpp"><span class="dt">char</span></code>, <code class="sourceCode cpp"><span class="dt">wchar_t</span></code>, <code class="sourceCode cpp"><span class="dt">char8_t</span></code>, <code class="sourceCode cpp"><span class="dt">char16_t</span></code>, or <code class="sourceCode cpp"><span class="dt">char32_t</span></code>, a specialization</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1"></a><span class="kw">template</span><span class="op">&lt;&gt;</span> <span class="kw">struct</span> formatter<span class="op">&lt;</span>ArithmeticT, charT<span class="op">&gt;</span>;</span></code></pre></div></li>
<li><p><span class="marginalizedparent"><a class="marginalized" href="#pnum_10" id="pnum_10">(2.4)</a></span> For each <code class="sourceCode cpp">charT</code>, the pointer type specializations</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1"></a><span class="kw">template</span><span class="op">&lt;&gt;</span> <span class="kw">struct</span> formatter<span class="op">&lt;</span>nullptr_t, charT<span class="op">&gt;</span>;</span>
<span id="cb42-2"><a href="#cb42-2"></a><span class="kw">template</span><span class="op">&lt;&gt;</span> <span class="kw">struct</span> formatter<span class="op">&lt;</span><span class="dt">void</span><span class="op">*</span>, charT<span class="op">&gt;</span>;</span>
<span id="cb42-3"><a href="#cb42-3"></a><span class="kw">template</span><span class="op">&lt;&gt;</span> <span class="kw">struct</span> formatter<span class="op">&lt;</span><span class="kw">const</span> <span class="dt">void</span><span class="op">*</span>, charT<span class="op">&gt;</span>;</span></code></pre></div></li>
</ul>
</blockquote>
<p>Add a new clause [format.string.escaped] “Formatting escaped characters and strings” which will discuss what it means to do escaping.</p>
<blockquote>
<div class="addu">
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_11" id="pnum_11">1</a></span> A character or string can be formatted as <em>escaped</em> to make it more suitable for debugging or for logging.</p>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_12" id="pnum_12">2</a></span> The escaped string representation of a string <code class="sourceCode cpp"><em>S</em></code> in a Unicode encoding consists of the following sequence of scalar values:</p>
<ul>
<li><p><span class="marginalizedparent"><a class="marginalized" href="#pnum_13" id="pnum_13">(2.1)</a></span> A U+0022 QUOTATION MARK (<code class="sourceCode cpp"><span class="st">&quot;</span></code>) character</p></li>
<li><p><span class="marginalizedparent"><a class="marginalized" href="#pnum_14" id="pnum_14">(2.2)</a></span> For each UCS scalar value in <code class="sourceCode cpp"><em>S</em></code>, or a code unit that is not a part of a valid UCS scalar value:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_15" id="pnum_15">(2.3)</a></span> If the UCS scalar value is in the table below, then its corresponding two-character escape sequence:</li>
</ul>
<table>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>UCS scalar value</strong>
</div></th>
<th><div style="text-align:center">
<strong>escape sequence</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>U+0009 CHARACTER TABULATION</td>
<td><code class="sourceCode cpp">\t</code></td>
</tr>
<tr class="even">
<td>U+000A LINE FEED</td>
<td><code class="sourceCode cpp">\n</code></td>
</tr>
<tr class="odd">
<td>U+000D CARRIAGE RETURN</td>
<td><code class="sourceCode cpp">\r</code></td>
</tr>
<tr class="even">
<td>U+0022 QUOTATION MARK</td>
<td><code class="sourceCode cpp">\<span class="st">&quot;</span></code></td>
</tr>
<tr class="odd">
<td>U+005C REVERSE SOLIDUS</td>
<td><code class="sourceCode cpp">\\</code></td>
</tr>
</tbody>
</table>
<ul>
<li><p><span class="marginalizedparent"><a class="marginalized" href="#pnum_16" id="pnum_16">(2.4)</a></span> Otherwise, if the UCS scalar value</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_17" id="pnum_17">(2.4.1)</a></span> is not U+0020 SPACE and has the Unicode property <code class="sourceCode cpp">General_Category<span class="op">=</span>Separator</code> (<code class="sourceCode cpp">Z</code>) or <code class="sourceCode cpp">General_Category<span class="op">=</span>Other</code> (<code class="sourceCode cpp">C</code>) as described by UAX #44, or</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_18" id="pnum_18">(2.4.2)</a></span> has the Unicode property <code class="sourceCode cpp">Grapheme_Extend<span class="op">=</span>Yes</code> as described by UAX #44</li>
</ul>
<p>then the sequence <code class="sourceCode cpp">\u<span class="op">{</span><em>simple-hexadecimal-digit-sequence</em><span class="op">}</span></code>, where <code class="sourceCode cpp"><em>simple-hexadecimal-digit-sequence</em></code> is the shortest hexadecimal representation of the UCS scalar value using lower-case <code class="sourceCode cpp"><em>hexadecimal-digit</em></code>s.</p></li>
<li><p><span class="marginalizedparent"><a class="marginalized" href="#pnum_19" id="pnum_19">(2.5)</a></span> Otherwise, if it is a code unit that is not a part of a valid UCS scalar value, then the sequence <code class="sourceCode cpp">\x<span class="op">{</span><em>simple-hexadecimal-digit-sequence</em><span class="op">}</span></code>, where <code class="sourceCode cpp"><em>simple-hexadecimal-digit-sequence</em></code> is the shortest hexadecimal representation of the code unit using lower-case <code class="sourceCode cpp"><em>hexadecimal-digit</em></code>s.</p></li>
<li><p><span class="marginalizedparent"><a class="marginalized" href="#pnum_20" id="pnum_20">(2.6)</a></span> Otherwise, the UCS scalar value as-is.</p></li>
</ul></li>
<li><p><span class="marginalizedparent"><a class="marginalized" href="#pnum_21" id="pnum_21">(2.7)</a></span> Finally, another U+0022 QUOTATION MARK (<code class="sourceCode cpp"><span class="st">&quot;</span></code>) character.</p></li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_22" id="pnum_22">3</a></span> The escaped character representation of a character <code class="sourceCode cpp"><em>C</em></code> in a Unicode encoding is equivalent to the escaped string representation of a string of <code class="sourceCode cpp"><em>C</em></code>, except that:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_23" id="pnum_23">(3.1)</a></span> the result starts and ends with U+0027 APOSTROPHE (<code class="sourceCode cpp"><span class="ch">&#39;</span></code>) instead of U+0022 QUOTATION MARK (<code class="sourceCode cpp"><span class="st">&quot;</span></code>), and</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_24" id="pnum_24">(3.2)</a></span> U+0027 APOSTROPHE is escaped as <code class="sourceCode cpp">\<span class="ch">&#39;</span></code> while U+0022 QUOTATION MARK is left unchanged.</li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_25" id="pnum_25">4</a></span> The escaped character and escaped string representations of a character or string in a non-Unicode encoding is unspecified.</p>
<p>[<em>Example</em>:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb43-1"><a href="#cb43-1"></a>string s0 = format(&quot;[{}]&quot;, &quot;h\tllo&quot;);                  // s0 has value: [h    llo]</span>
<span id="cb43-2"><a href="#cb43-2"></a>string s1 = format(&quot;[{:?}]&quot;, &quot;h\tllo&quot;);                // s1 has value: [&quot;h\tllo&quot;]</span>
<span id="cb43-3"><a href="#cb43-3"></a>string s2 = format(&quot;[{:?}]&quot;, &quot;Спасибо, Виктор ♥!&quot;);    // s2 has value: [&quot;Спасибо, Виктор ♥!&quot;]</span>
<span id="cb43-4"><a href="#cb43-4"></a>string s3 = format(&quot;[{:?}] [{:?}]&quot;, &#39;\&#39;&#39;, &#39;&quot;&#39;);        // s3 has value: [&#39;\&#39;&#39;, &#39;&quot;&#39;]</span>
<span id="cb43-5"><a href="#cb43-5"></a>string s4 = format(&quot;[{:?}]&quot;, string(&quot;\0 \n \t \x02 \x1b&quot;, 9));</span>
<span id="cb43-6"><a href="#cb43-6"></a>                                                       // s4 has value [\u{0} \n \t \u{2} \u{1b}]</span>
<span id="cb43-7"><a href="#cb43-7"></a>string s5 = format(&quot;[{:?}]&quot;, &quot;\xc3\x28&quot;);              // invalid UTF-8</span>
<span id="cb43-8"><a href="#cb43-8"></a>                                                       // s5 has value: [&quot;\x{c3}\x{28}&quot;]</span>
<span id="cb43-9"><a href="#cb43-9"></a>string s6 = format(&quot;[{:?}]&quot;, &quot;🤷🏻‍♂️&quot;);                    // s6 has value: [&quot;🤷🏻\u{200d}♂\u{fe0f}&quot;]</span></code></pre></div>
<p><em>-end example</em>]</p>
</div>
</blockquote>
<h2 data-number="5.3" id="formatting-for-ranges"><span class="header-section-number">5.3</span> Formatting for ranges<a href="#formatting-for-ranges" class="self-link"></a></h2>
<p>Add to <span>22.14.1 <a href="https://wg21.link/format.syn">[format.syn]</a></span>:</p>
<blockquote>
<div>
<div class="sourceCode" id="cb44"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb44-1"><a href="#cb44-1"></a>namespace std {</span>
<span id="cb44-2"><a href="#cb44-2"></a>  // ...</span>
<span id="cb44-3"><a href="#cb44-3"></a></span>
<span id="cb44-4"><a href="#cb44-4"></a>  // [format.formatter], formatter</span>
<span id="cb44-5"><a href="#cb44-5"></a>  template&lt;class T, class charT = char&gt; struct formatter;</span>
<span id="cb44-6"><a href="#cb44-6"></a></span>
<span id="cb44-7"><a href="#cb44-7"></a><span class="va">+ // [format.range.formatter], class template range_formatter</span></span>
<span id="cb44-8"><a href="#cb44-8"></a><span class="va">+ template&lt;class T, class charT = char&gt;</span></span>
<span id="cb44-9"><a href="#cb44-9"></a><span class="va">+     requires same_as&lt;remove_cvref_t&lt;T&gt;, T&gt; &amp;&amp; formattable&lt;T, charT&gt;</span></span>
<span id="cb44-10"><a href="#cb44-10"></a><span class="va">+   class range_formatter;</span></span>
<span id="cb44-11"><a href="#cb44-11"></a><span class="va">+</span></span>
<span id="cb44-12"><a href="#cb44-12"></a><span class="va">+ template&lt;ranges::input_range R, class charT&gt;</span></span>
<span id="cb44-13"><a href="#cb44-13"></a><span class="va">+         requires (!same_as&lt;remove_cvref_t&lt;ranges::range_reference_t&lt;R&gt;&gt;, R&gt;)</span></span>
<span id="cb44-14"><a href="#cb44-14"></a><span class="va">+           &amp;&amp; formattable&lt;ranges::range_reference_t&lt;R&gt;, charT&gt;</span></span>
<span id="cb44-15"><a href="#cb44-15"></a><span class="va">+   struct formatter&lt;R, charT&gt;;</span></span>
<span id="cb44-16"><a href="#cb44-16"></a></span>
<span id="cb44-17"><a href="#cb44-17"></a>  // ...</span>
<span id="cb44-18"><a href="#cb44-18"></a>}</span></code></pre></div>
</div>
</blockquote>
<p>And a new clause [format.range]:</p>
<blockquote>
<div class="addu">
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_26" id="pnum_26">1</a></span> The class template <code class="sourceCode cpp">range_formatter</code> is a convenient utility for implementing <code class="sourceCode cpp">formatter</code> specializations for range types.</p>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_27" id="pnum_27">2</a></span> <code class="sourceCode cpp">range_formatter</code> interprets <code class="sourceCode cpp"><em>format-spec</em></code> as a <code class="sourceCode cpp"><em>range-format-spec</em></code>. The syntax of format specifications is as follows:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb45-1"><a href="#cb45-1"></a><em>range-format-spec</em>:</span>
<span id="cb45-2"><a href="#cb45-2"></a>    <em>range-fill-and-align</em><sub>opt</sub> <em>width</em><sub>opt</sub> n<sub>opt</sub> <em>range-type</em><sub>opt</sub> <em>range-underlying-spec</em><sub>opt</sub></span>
<span id="cb45-3"><a href="#cb45-3"></a></span>
<span id="cb45-4"><a href="#cb45-4"></a><em>range-fill-and-align</em>:</span>
<span id="cb45-5"><a href="#cb45-5"></a>    <em>range-fill</em><sub>opt</sub> <em>align</em></span>
<span id="cb45-6"><a href="#cb45-6"></a></span>
<span id="cb45-7"><a href="#cb45-7"></a><em>range-fill</em>:</span>
<span id="cb45-8"><a href="#cb45-8"></a>    any character other than { or } or :</span>
<span id="cb45-9"><a href="#cb45-9"></a></span>
<span id="cb45-10"><a href="#cb45-10"></a><em>range-type</em>:</span>
<span id="cb45-11"><a href="#cb45-11"></a>    m</span>
<span id="cb45-12"><a href="#cb45-12"></a>    s</span>
<span id="cb45-13"><a href="#cb45-13"></a>    ?s</span>
<span id="cb45-14"><a href="#cb45-14"></a></span>
<span id="cb45-15"><a href="#cb45-15"></a><em>range-underlying-spec</em>:</span>
<span id="cb45-16"><a href="#cb45-16"></a>    : <em>format-spec</em></span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_28" id="pnum_28">3</a></span> For <code class="sourceCode cpp">range_formatter<span class="op">&lt;</span>T, charT<span class="op">&gt;</span></code>, the <code class="sourceCode cpp"><em>format-spec</em></code> in a <code class="sourceCode cpp"><em>range-underlying-spec</em></code>, if any, is interpreted by <code class="sourceCode cpp">formatter<span class="op">&lt;</span>T, charT<span class="op">&gt;</span></code>.</p>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_29" id="pnum_29">4</a></span> The <code class="sourceCode cpp"><em>range-fill-and-align</em></code> is interpreted the same way as a <code class="sourceCode cpp"><em>fill-and-align</em></code> ([format.string.std]). The productions <code class="sourceCode cpp"><em>align</em></code> and <code class="sourceCode cpp"><em>width</em></code> are described in [format.string].</p>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_30" id="pnum_30">5</a></span> The <code class="sourceCode cpp">n</code> option causes the range to be formatted without the opening and closing brackets. [<em>Note</em>: this is equivalent to invoking <code class="sourceCode cpp">set_brackets<span class="op">({}</span>, <span class="op">{})</span></code> <em>- end note</em> ]</p>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_31" id="pnum_31">6</a></span> The <code class="sourceCode cpp"><em>range-type</em></code> specifier changes the way a range is formatted, with certain options only valid with certain argument types. The meaning of the various type options is as specified in Table X.</p>
<table>
<colgroup>
<col style="width: 33%"></col>
<col style="width: 33%"></col>
<col style="width: 33%"></col>
</colgroup>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Option</strong>
</div></th>
<th><div style="text-align:center">
<strong>Requirements</strong>
</div></th>
<th><div style="text-align:center">
<strong>Meaning</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="sourceCode cpp">m</code></td>
<td><code class="sourceCode cpp">T</code> shall be either a specialization of <code class="sourceCode cpp">pair</code> or a specialization of <code class="sourceCode cpp">tuple</code> such that <code class="sourceCode cpp">tuple_size_v<span class="op">&lt;</span>T<span class="op">&gt;</span></code> is <code class="sourceCode cpp"><span class="dv">2</span></code></td>
<td>Indicates that the opening bracket should be <code class="sourceCode cpp"><span class="st">&quot;{&quot;</span></code>, the closing bracket should be <code class="sourceCode cpp"><span class="st">&quot;}&quot;</span></code>, the separator should be <code class="sourceCode cpp"><span class="st">&quot;, &quot;</span></code>, and each range element should be formatted as if <code class="sourceCode cpp">m</code> were specified for its <code class="sourceCode cpp"><em>tuple-type</em></code>. [<em>Note</em>: if the <code class="sourceCode cpp">n</code> option is also provided, both the opening and closing brackets are still empty. <em>-end note</em>]</td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">s</code></td>
<td><code class="sourceCode cpp">T</code> shall be <code class="sourceCode cpp">charT</code></td>
<td>Indicates that the range should be formatted as a <code class="sourceCode cpp">string</code>.</td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp"><span class="op">?</span>s</code></td>
<td><code class="sourceCode cpp">T</code> shall be <code class="sourceCode cpp">charT</code></td>
<td>Indicates that the range should be formatted as an escaped <code class="sourceCode cpp">string</code> ([format.string.escaped]).</td>
</tr>
</tbody>
</table>
<p>If the <code class="sourceCode cpp"><em>range-type</em></code> is <code class="sourceCode cpp">s</code> or <code class="sourceCode cpp"><span class="op">?</span>s</code>, then there shall be no <code class="sourceCode cpp">n</code> option and no <code class="sourceCode cpp"><em>range-underlying-spec</em></code>.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb46-1"><a href="#cb46-1"></a>namespace std {</span>
<span id="cb46-2"><a href="#cb46-2"></a>  template&lt;class T, class charT = char&gt;</span>
<span id="cb46-3"><a href="#cb46-3"></a>    requires same_as&lt;remove_cvref_t&lt;T&gt;, T&gt; &amp;&amp; formattable&lt;T, charT&gt;</span>
<span id="cb46-4"><a href="#cb46-4"></a>  class range_formatter {</span>
<span id="cb46-5"><a href="#cb46-5"></a>    formatter&lt;T, charT&gt; <em>underlying_</em>;                                          // exposition only</span>
<span id="cb46-6"><a href="#cb46-6"></a>    basic_string_view&lt;charT&gt; <em>separator_</em> = <em>STATICALLY-WIDEN</em>&lt;charT&gt;(&quot;, &quot;);      // exposition only</span>
<span id="cb46-7"><a href="#cb46-7"></a>    basic_string_view&lt;charT&gt; <em>opening-bracket_</em> = <em>STATICALLY-WIDEN</em>&lt;charT&gt;(&quot;[&quot;); // exposition only</span>
<span id="cb46-8"><a href="#cb46-8"></a>    basic_string_view&lt;charT&gt; <em>closing-bracket_</em> = <em>STATICALLY-WIDEN</em>&lt;charT&gt;(&quot;]&quot;); // exposition only</span>
<span id="cb46-9"><a href="#cb46-9"></a></span>
<span id="cb46-10"><a href="#cb46-10"></a>  public:</span>
<span id="cb46-11"><a href="#cb46-11"></a>    constexpr void set_separator(basic_string_view&lt;charT&gt; sep);</span>
<span id="cb46-12"><a href="#cb46-12"></a>    constexpr void set_brackets(basic_string_view&lt;charT&gt; opening, basic_string_view&lt;charT&gt; closing);</span>
<span id="cb46-13"><a href="#cb46-13"></a>    constexpr formatter&lt;T, charT&gt;&amp; underlying() { return <em>underlying_</em>; }</span>
<span id="cb46-14"><a href="#cb46-14"></a></span>
<span id="cb46-15"><a href="#cb46-15"></a>    template &lt;class ParseContext&gt;</span>
<span id="cb46-16"><a href="#cb46-16"></a>      constexpr typename ParseContext::iterator</span>
<span id="cb46-17"><a href="#cb46-17"></a>        parse(ParseContext&amp; ctx);</span>
<span id="cb46-18"><a href="#cb46-18"></a></span>
<span id="cb46-19"><a href="#cb46-19"></a>    template &lt;ranges::input_range R, class FormatContext&gt;</span>
<span id="cb46-20"><a href="#cb46-20"></a>        requires formattable&lt;ranges::range_reference_t&lt;R&gt;, charT&gt;</span>
<span id="cb46-21"><a href="#cb46-21"></a>              &amp;&amp; same_as&lt;remove_cvref_t&lt;ranges::range_reference_t&lt;R&gt;&gt;, T&gt;</span>
<span id="cb46-22"><a href="#cb46-22"></a>      typename FormatContext::iterator</span>
<span id="cb46-23"><a href="#cb46-23"></a>        format(R&amp;&amp; r, FormatContext&amp; ctx) const;</span>
<span id="cb46-24"><a href="#cb46-24"></a>  };</span>
<span id="cb46-25"><a href="#cb46-25"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb47"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb47-1"><a href="#cb47-1"></a>constexpr void set_separator(basic_string_view&lt;charT&gt; sep);</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_32" id="pnum_32">7</a></span> <em>Effects</em>: Equivalent to <code class="sourceCode cpp"><em>separator_</em> <span class="op">=</span> sep</code>;</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb48-1"><a href="#cb48-1"></a>constexpr void set_brackets(basic_string_view&lt;charT&gt; opening, basic_string_view&lt;charT&gt; closing);</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_33" id="pnum_33">8</a></span> <em>Effects</em>: Equivalent to</p>
<blockquote>
<div class="sourceCode" id="cb49"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb49-1"><a href="#cb49-1"></a><em>opening-bracket_</em> = opening;</span>
<span id="cb49-2"><a href="#cb49-2"></a><em>closing-bracket_</em> = closing;</span></code></pre></div>
</blockquote>
<div class="sourceCode" id="cb50"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb50-1"><a href="#cb50-1"></a>template &lt;class ParseContext&gt;</span>
<span id="cb50-2"><a href="#cb50-2"></a>  constexpr typename ParseContext::iterator</span>
<span id="cb50-3"><a href="#cb50-3"></a>    parse(ParseContext&amp; ctx);</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_34" id="pnum_34">9</a></span> <em>Effects</em>: Parses the format specifier as a <code class="sourceCode cpp"><em>range-format-spec</em></code> and stores the parsed specifiers in <code class="sourceCode cpp"><span class="op">*</span><span class="kw">this</span></code>. The values of <code class="sourceCode cpp"><em>opening-bracket_</em></code>, <code class="sourceCode cpp"><em>closing-bracket_</em></code>, and <code class="sourceCode cpp"><em>separator_</em></code> are modified if and only if required by the <code class="sourceCode cpp"><em>range-type</em></code>. If:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_35" id="pnum_35">(9.1)</a></span> the <code class="sourceCode cpp"><em>range-type</em></code> is neither <code class="sourceCode cpp">s</code> nor <code class="sourceCode cpp"><span class="op">?</span>s</code>,</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_36" id="pnum_36">(9.2)</a></span> <code class="sourceCode cpp"><em>underlying_</em><span class="op">.</span>set_debug_format<span class="op">()</span></code> is a valid expression, and</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_37" id="pnum_37">(9.3)</a></span> there is no <code class="sourceCode cpp"><em>range-underlying-spec</em></code>,</li>
</ul>
<p>then calls <code class="sourceCode cpp"><em>underlying_</em><span class="op">.</span>set_debug_format<span class="op">()</span></code>.</p>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_38" id="pnum_38">10</a></span> <em>Returns</em>: An iterator past the end of the <code class="sourceCode cpp"><em>range-format-spec</em></code>.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb51-1"><a href="#cb51-1"></a>template &lt;ranges::input_range R, class FormatContext&gt;</span>
<span id="cb51-2"><a href="#cb51-2"></a>    requires formattable&lt;ranges::range_reference_t&lt;R&gt;, charT&gt;</span>
<span id="cb51-3"><a href="#cb51-3"></a>          &amp;&amp; same_as&lt;remove_cvref_t&lt;ranges::range_reference_t&lt;R&gt;&gt;, T&gt;</span>
<span id="cb51-4"><a href="#cb51-4"></a>  typename FormatContext::iterator</span>
<span id="cb51-5"><a href="#cb51-5"></a>    format(R&amp;&amp; r, FormatContext&amp; ctx) const;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_39" id="pnum_39">11</a></span> <em>Effects</em>: Writes the following into <code class="sourceCode cpp">ctx<span class="op">.</span>out<span class="op">()</span></code>, adjusted according to the <code class="sourceCode cpp"><em>range-format-spec</em></code>:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_40" id="pnum_40">(11.1)</a></span> If the <code class="sourceCode cpp"><em>range-type</em></code> was <code class="sourceCode cpp">s</code>, then as if by formatting <code class="sourceCode cpp">basic_string<span class="op">&lt;</span>charT<span class="op">&gt;(</span>from_range, r<span class="op">)</span></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_41" id="pnum_41">(11.2)</a></span> Otherwise, if the <code class="sourceCode cpp"><em>range-type</em></code> was <code class="sourceCode cpp"><span class="op">?</span>s</code>, then as if by formatting <code class="sourceCode cpp">basic_string<span class="op">&lt;</span>charT<span class="op">&gt;(</span>from_range, r<span class="op">)</span></code> as an escaped string ([format.string.escaped]).</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_42" id="pnum_42">(11.3)</a></span> Otherwise,
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_43" id="pnum_43">(11.3.1)</a></span> <code class="sourceCode cpp"><em>opening-bracket_</em></code></li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_44" id="pnum_44">(11.3.2)</a></span> for each element <code class="sourceCode cpp">e</code> of the range <code class="sourceCode cpp">r</code>:
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_45" id="pnum_45">(11.3.2.1)</a></span> the result of writing <code class="sourceCode cpp">e</code> via <code class="sourceCode cpp"><em>underlying_</em></code></li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_46" id="pnum_46">(11.3.2.2)</a></span> <code class="sourceCode cpp"><em>separator_</em></code>, unless <code class="sourceCode cpp">e</code> is the last element of <code class="sourceCode cpp">r</code></li>
</ul></li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_47" id="pnum_47">(11.3.3)</a></span> <code class="sourceCode cpp"><em>closing-bracket_</em></code></li>
</ul></li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_48" id="pnum_48">12</a></span> <em>Returns</em>: an iterator past the end of the output range.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb52-1"><a href="#cb52-1"></a>namespace std {</span>
<span id="cb52-2"><a href="#cb52-2"></a>  template&lt;ranges::input_range R, class charT&gt;</span>
<span id="cb52-3"><a href="#cb52-3"></a>        requires (!same_as&lt;remove_cvref_t&lt;ranges::range_reference_t&lt;R&gt;&gt;, R&gt;)</span>
<span id="cb52-4"><a href="#cb52-4"></a>               &amp;&amp; formattable&lt;ranges::range_reference_t&lt;R&gt;, charT&gt;</span>
<span id="cb52-5"><a href="#cb52-5"></a>  struct formatter&lt;R, charT&gt; {</span>
<span id="cb52-6"><a href="#cb52-6"></a>  private:</span>
<span id="cb52-7"><a href="#cb52-7"></a>    using <em>maybe-const-r</em> = <em>fmt-maybe-const</em>&lt;R, charT&gt;;</span>
<span id="cb52-8"><a href="#cb52-8"></a>    range_formatter&lt;remove_cvref_t&lt;ranges::range_reference_t&lt;<em>maybe-const-r</em>&gt;&gt;, charT&gt; <em>underlying_</em>; // exposition only</span>
<span id="cb52-9"><a href="#cb52-9"></a></span>
<span id="cb52-10"><a href="#cb52-10"></a>  public:</span>
<span id="cb52-11"><a href="#cb52-11"></a>    constexpr void set_separator(basic_string_view&lt;charT&gt; sep);</span>
<span id="cb52-12"><a href="#cb52-12"></a>    constexpr void set_brackets(basic_string_view&lt;charT&gt; opening, basic_string_view&lt;charT&gt; closing);</span>
<span id="cb52-13"><a href="#cb52-13"></a></span>
<span id="cb52-14"><a href="#cb52-14"></a>    template &lt;class ParseContext&gt;</span>
<span id="cb52-15"><a href="#cb52-15"></a>      constexpr typename ParseContext::iterator</span>
<span id="cb52-16"><a href="#cb52-16"></a>        parse(ParseContext&amp; ctx);</span>
<span id="cb52-17"><a href="#cb52-17"></a></span>
<span id="cb52-18"><a href="#cb52-18"></a>    template &lt;class FormatContext&gt;</span>
<span id="cb52-19"><a href="#cb52-19"></a>      typename FormatContext::iterator</span>
<span id="cb52-20"><a href="#cb52-20"></a>        format(<em>maybe-const-r</em>&amp; elems, FormatContext&amp; ctx) const;</span>
<span id="cb52-21"><a href="#cb52-21"></a>  };</span>
<span id="cb52-22"><a href="#cb52-22"></a>}</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_49" id="pnum_49">13</a></span> [<em>Note</em>: The <code class="sourceCode cpp"><span class="op">(!</span>same_as<span class="op">&lt;</span>remove_cvref_t<span class="op">&lt;</span>ranges<span class="op">::</span>range_reference_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;</span>, R<span class="op">&gt;)</span></code> constraint is to be prevent constraint recursion for ranges whose reference type is the same range type. For example, <code class="sourceCode cpp">std<span class="op">::</span>filesystem<span class="op">::</span>path</code> is a range of <code class="sourceCode cpp">std<span class="op">::</span>filesystem<span class="op">::</span>path</code>. <em>-end note</em> ]</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb53-1"><a href="#cb53-1"></a>constexpr void set_separator(basic_string_view&lt;charT&gt; sep);</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_50" id="pnum_50">14</a></span> <em>Effects</em>: Equivalent to <code class="sourceCode cpp"><em>underlying_</em><span class="op">.</span>set_separator<span class="op">(</span>sep<span class="op">)</span></code>;</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb54-1"><a href="#cb54-1"></a>constexpr void set_brackets(basic_string_view&lt;charT&gt; opening, basic_string_view&lt;charT&gt; closing);</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_51" id="pnum_51">15</a></span> <em>Effects</em>: Equivalent to <code class="sourceCode cpp"><em>underlying_</em><span class="op">.</span>set_brackets<span class="op">(</span>opening, closing<span class="op">)</span></code>;</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb55-1"><a href="#cb55-1"></a>template &lt;class ParseContext&gt;</span>
<span id="cb55-2"><a href="#cb55-2"></a>  constexpr typename ParseContext::iterator</span>
<span id="cb55-3"><a href="#cb55-3"></a>    parse(ParseContext&amp; ctx);</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_52" id="pnum_52">16</a></span> <em>Effects</em>: Equivalent to <code class="sourceCode cpp"><span class="cf">return</span> <em>underlying_</em><span class="op">.</span>parse<span class="op">(</span>ctx<span class="op">)</span>;</code></p>
<div class="sourceCode" id="cb56"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb56-1"><a href="#cb56-1"></a>template &lt;class FormatContext&gt;</span>
<span id="cb56-2"><a href="#cb56-2"></a>  typename FormatContext::iterator</span>
<span id="cb56-3"><a href="#cb56-3"></a>    format(<em>maybe-const-r</em>&amp; elems, FormatContext&amp; ctx) const;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_53" id="pnum_53">17</a></span> <em>Effects</em>: Equivalent to <code class="sourceCode cpp"><span class="cf">return</span> <em>underlying_</em><span class="op">.</span>format<span class="op">(</span>elems, ctx<span class="op">)</span>;</code></p>
</div>
</blockquote>
<h3 data-number="5.3.1" id="formatting-for-specific-ranges-all-the-maps-and-sets"><span class="header-section-number">5.3.1</span> Formatting for specific ranges: all the maps and sets<a href="#formatting-for-specific-ranges-all-the-maps-and-sets" class="self-link"></a></h3>
<p>Add a clause (maybe after <span>24.5 <a href="https://wg21.link/unord">[unord]</a></span> and before <span>24.6 <a href="https://wg21.link/container.adaptors">[container.adaptors]</a></span>) [assoc.format] Associative Formatting:</p>
<blockquote>
<div class="addu">
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_54" id="pnum_54">1</a></span> For each of <code class="sourceCode cpp">map</code>, <code class="sourceCode cpp">multimap</code>, <code class="sourceCode cpp">unordered_map</code>, and <code class="sourceCode cpp">unordered_multimap</code>, the library provides the following formatter specialization where <code class="sourceCode cpp"><em>map-type</em></code> is the name of the template:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb57-1"><a href="#cb57-1"></a>namespace std {</span>
<span id="cb57-2"><a href="#cb57-2"></a>  template &lt;class charT, class Key, formattable&lt;charT&gt; T, class... U&gt;</span>
<span id="cb57-3"><a href="#cb57-3"></a>    requires formattable&lt;const Key, charT&gt;</span>
<span id="cb57-4"><a href="#cb57-4"></a>  struct formatter&lt;<em>map-type</em>&lt;Key, T, U...&gt;, charT&gt;</span>
<span id="cb57-5"><a href="#cb57-5"></a>  {</span>
<span id="cb57-6"><a href="#cb57-6"></a>  private:</span>
<span id="cb57-7"><a href="#cb57-7"></a>    using <em>maybe-const-map</em> = <em>fmt-maybe-const</em>&lt;<em>map-type</em>&lt;Key, T, U...&gt;, charT&gt;;  // exposition only</span>
<span id="cb57-8"><a href="#cb57-8"></a>    range_formatter&lt;remove_cvref_t&lt;ranges::range_reference_t&lt;<em>maybe-const-map</em>&gt;&gt;, charT&gt; <em>underlying_</em>; // exposition only</span>
<span id="cb57-9"><a href="#cb57-9"></a>  public:</span>
<span id="cb57-10"><a href="#cb57-10"></a>    constexpr formatter();</span>
<span id="cb57-11"><a href="#cb57-11"></a></span>
<span id="cb57-12"><a href="#cb57-12"></a>    template &lt;class ParseContext&gt;</span>
<span id="cb57-13"><a href="#cb57-13"></a>      constexpr typename ParseContext::iterator</span>
<span id="cb57-14"><a href="#cb57-14"></a>        parse(ParseContext&amp; ctx);</span>
<span id="cb57-15"><a href="#cb57-15"></a></span>
<span id="cb57-16"><a href="#cb57-16"></a>    template &lt;class FormatContext&gt;</span>
<span id="cb57-17"><a href="#cb57-17"></a>      typename FormatContext::iterator</span>
<span id="cb57-18"><a href="#cb57-18"></a>        format(<em>maybe-const-map</em>&amp; r, FormatContext&amp; ctx) const;</span>
<span id="cb57-19"><a href="#cb57-19"></a>  };</span>
<span id="cb57-20"><a href="#cb57-20"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb58"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb58-1"><a href="#cb58-1"></a>constexpr formatter();</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_55" id="pnum_55">2</a></span> <em>Effects</em>: Equivalent to:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb59-1"><a href="#cb59-1"></a><em>underlying_</em>.set_brackets(<em>STATICALLY-WIDEN</em>&lt;charT&gt;(&quot;{&quot;), <em>STATICALLY-WIDEN</em>&lt;charT&gt;(&quot;}&quot;));</span>
<span id="cb59-2"><a href="#cb59-2"></a><em>underlying_</em>.underlying().set_brackets({}, {});</span>
<span id="cb59-3"><a href="#cb59-3"></a><em>underlying_</em>.underlying().set_separator(<em>STATICALLY-WIDEN</em>&lt;charT&gt;(&quot;: &quot;));</span></code></pre></div>
<div class="sourceCode" id="cb60"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb60-1"><a href="#cb60-1"></a>template &lt;class ParseContext&gt;</span>
<span id="cb60-2"><a href="#cb60-2"></a>  constexpr typename ParseContext::iterator</span>
<span id="cb60-3"><a href="#cb60-3"></a>    parse(ParseContext&amp; ctx);</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_56" id="pnum_56">3</a></span> <em>Effects</em>: Equivalent to <code class="sourceCode cpp"><span class="cf">return</span> <em>underlying_</em><span class="op">.</span>parse<span class="op">(</span>ctx<span class="op">)</span>;</code></p>
<div class="sourceCode" id="cb61"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb61-1"><a href="#cb61-1"></a>template &lt;class FormatContext&gt;</span>
<span id="cb61-2"><a href="#cb61-2"></a>  typename FormatContext::iterator</span>
<span id="cb61-3"><a href="#cb61-3"></a>    format(<em>maybe-const-map</em>&amp; r, FormatContext&amp; ctx) const;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_57" id="pnum_57">4</a></span> <em>Effects</em>: Equivalent to <code class="sourceCode cpp"><span class="cf">return</span> <em>underlying_</em><span class="op">.</span>format<span class="op">(</span>r, ctx<span class="op">)</span>;</code></p>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_58" id="pnum_58">5</a></span> For each of <code class="sourceCode cpp">set</code>, <code class="sourceCode cpp">multiset</code>, <code class="sourceCode cpp">unordered_set</code>, and <code class="sourceCode cpp">unordered_multiset</code>, the library provides the following formatter specialization where <code class="sourceCode cpp"><em>set-type</em></code> is the name of the template:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb62-1"><a href="#cb62-1"></a>namespace std {</span>
<span id="cb62-2"><a href="#cb62-2"></a>  template &lt;class charT, class Key, class... U&gt;</span>
<span id="cb62-3"><a href="#cb62-3"></a>    requires formattable&lt;const Key, charT&gt;</span>
<span id="cb62-4"><a href="#cb62-4"></a>  struct formatter&lt;<em>set-type</em>&lt;Key, U...&gt;, charT&gt;</span>
<span id="cb62-5"><a href="#cb62-5"></a>  {</span>
<span id="cb62-6"><a href="#cb62-6"></a>  private:</span>
<span id="cb62-7"><a href="#cb62-7"></a>    range_formatter&lt;Key, charT&gt; <em>underlying_</em>; // exposition only</span>
<span id="cb62-8"><a href="#cb62-8"></a></span>
<span id="cb62-9"><a href="#cb62-9"></a>  public:</span>
<span id="cb62-10"><a href="#cb62-10"></a>    constexpr formatter();</span>
<span id="cb62-11"><a href="#cb62-11"></a></span>
<span id="cb62-12"><a href="#cb62-12"></a>    template &lt;class ParseContext&gt;</span>
<span id="cb62-13"><a href="#cb62-13"></a>      constexpr typename ParseContext::iterator</span>
<span id="cb62-14"><a href="#cb62-14"></a>        parse(ParseContext&amp; ctx);</span>
<span id="cb62-15"><a href="#cb62-15"></a></span>
<span id="cb62-16"><a href="#cb62-16"></a>    template &lt;class FormatContext&gt;</span>
<span id="cb62-17"><a href="#cb62-17"></a>      typename FormatContext::iterator</span>
<span id="cb62-18"><a href="#cb62-18"></a>        format(const <em>set-type</em>&lt;Key, U...&gt;&amp; r, FormatContext&amp; ctx) const;</span>
<span id="cb62-19"><a href="#cb62-19"></a>  };</span>
<span id="cb62-20"><a href="#cb62-20"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb63"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb63-1"><a href="#cb63-1"></a>constexpr formatter();</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_59" id="pnum_59">6</a></span> <em>Effects</em>: Equivalent to:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb64-1"><a href="#cb64-1"></a><em>underlying_</em>.set_brackets(<em>STATICALLY-WIDEN</em>&lt;charT&gt;(&quot;{&quot;), <em>STATICALLY-WIDEN</em>&lt;charT&gt;(&quot;}&quot;));</span></code></pre></div>
<div class="sourceCode" id="cb65"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb65-1"><a href="#cb65-1"></a>template &lt;class ParseContext&gt;</span>
<span id="cb65-2"><a href="#cb65-2"></a>  constexpr typename ParseContext::iterator</span>
<span id="cb65-3"><a href="#cb65-3"></a>    parse(ParseContext&amp; ctx);</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_60" id="pnum_60">7</a></span> <em>Effects</em>: Equivalent to <code class="sourceCode cpp"><span class="cf">return</span> <em>underlying_</em><span class="op">.</span>parse<span class="op">(</span>ctx<span class="op">)</span>;</code></p>
<div class="sourceCode" id="cb66"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb66-1"><a href="#cb66-1"></a>template &lt;class FormatContext&gt;</span>
<span id="cb66-2"><a href="#cb66-2"></a>  typename FormatContext::iterator</span>
<span id="cb66-3"><a href="#cb66-3"></a>    format(const <em>set-type</em>&lt;Key, U...&gt;&amp; r, FormatContext&amp; ctx) const;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_61" id="pnum_61">8</a></span> <em>Effects</em>: Equivalent to <code class="sourceCode cpp"><span class="cf">return</span> <em>underlying_</em><span class="op">.</span>format<span class="op">(</span>r, ctx<span class="op">)</span>;</code></p>
</div>
</blockquote>
<h3 data-number="5.3.2" id="formatting-for-specific-ranges-all-the-container-adaptors"><span class="header-section-number">5.3.2</span> Formatting for specific ranges: all the container adaptors<a href="#formatting-for-specific-ranges-all-the-container-adaptors" class="self-link"></a></h3>
<p>At the end of <span>24.6 <a href="https://wg21.link/container.adaptors">[container.adaptors]</a></span>, add a clause [container.adaptors.format]:</p>
<blockquote>
<div class="addu">
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_62" id="pnum_62">1</a></span> For each of <code class="sourceCode cpp">queue</code>, <code class="sourceCode cpp">priority_queue</code>, and <code class="sourceCode cpp">stack</code>, the library provides the following formatter specialization where <code class="sourceCode cpp"><em>adaptor-type</em></code> is the name of the template:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb67-1"><a href="#cb67-1"></a>namespace std {</span>
<span id="cb67-2"><a href="#cb67-2"></a>  template &lt;class charT, class T, formattable&lt;charT&gt; Container, class... U&gt;</span>
<span id="cb67-3"><a href="#cb67-3"></a>  struct formatter&lt;<em>adaptor-type</em>&lt;T, Container, U...&gt;, charT&gt;</span>
<span id="cb67-4"><a href="#cb67-4"></a>  {</span>
<span id="cb67-5"><a href="#cb67-5"></a>  private:</span>
<span id="cb67-6"><a href="#cb67-6"></a>    using <em>maybe-const-adaptor</em> = <em>fmt-maybe-const</em>&lt;<em>adaptor-type</em>&lt;T, Container, U...&gt;, charT&gt;;   // exposition only</span>
<span id="cb67-7"><a href="#cb67-7"></a>    formatter&lt;Container, charT&gt; <em>underlying_</em>; // exposition only</span>
<span id="cb67-8"><a href="#cb67-8"></a></span>
<span id="cb67-9"><a href="#cb67-9"></a>  public:</span>
<span id="cb67-10"><a href="#cb67-10"></a>    template &lt;class ParseContext&gt;</span>
<span id="cb67-11"><a href="#cb67-11"></a>      constexpr typename ParseContext::iterator</span>
<span id="cb67-12"><a href="#cb67-12"></a>        parse(ParseContext&amp; ctx);</span>
<span id="cb67-13"><a href="#cb67-13"></a></span>
<span id="cb67-14"><a href="#cb67-14"></a>    template &lt;class FormatContext&gt;</span>
<span id="cb67-15"><a href="#cb67-15"></a>      typename FormatContext::iterator</span>
<span id="cb67-16"><a href="#cb67-16"></a>        format(<em>maybe-const-adaptor</em>&amp; r, FormatContext&amp; ctx) const;</span>
<span id="cb67-17"><a href="#cb67-17"></a>  };</span>
<span id="cb67-18"><a href="#cb67-18"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb68"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb68-1"><a href="#cb68-1"></a>template &lt;class ParseContext&gt;</span>
<span id="cb68-2"><a href="#cb68-2"></a>  constexpr typename ParseContext::iterator</span>
<span id="cb68-3"><a href="#cb68-3"></a>    parse(ParseContext&amp; ctx);</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_63" id="pnum_63">2</a></span> <em>Effects</em>: Equivalent to <code class="sourceCode cpp"><span class="cf">return</span> <em>underlying_</em><span class="op">.</span>parse<span class="op">(</span>ctx<span class="op">)</span>;</code></p>
<div class="sourceCode" id="cb69"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb69-1"><a href="#cb69-1"></a>template &lt;class FormatContext&gt;</span>
<span id="cb69-2"><a href="#cb69-2"></a>  typename FormatContext::iterator</span>
<span id="cb69-3"><a href="#cb69-3"></a>    format(<em>maybe-const-adaptor</em>&amp; r, FormatContext&amp; ctx) const;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_64" id="pnum_64">3</a></span> <em>Effects</em>: Equivalent to <code class="sourceCode cpp"><span class="cf">return</span> <em>underlying_</em><span class="op">.</span>format<span class="op">(</span>r<span class="op">.</span>c, ctx<span class="op">)</span>;</code></p>
</div>
</blockquote>
<h2 data-number="5.4" id="formatting-for-pair-and-tuple"><span class="header-section-number">5.4</span> Formatting for <code class="sourceCode cpp">pair</code> and <code class="sourceCode cpp">tuple</code><a href="#formatting-for-pair-and-tuple" class="self-link"></a></h2>
<p>And a new clause [format.tuple]:</p>
<blockquote>
<div class="addu">
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_65" id="pnum_65">1</a></span> For each of <code class="sourceCode cpp">pair</code> and <code class="sourceCode cpp">tuple</code>, the library provides the following formatter specialization where <code class="sourceCode cpp"><em>tuple-type</em></code> is the name of the template:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb70-1"><a href="#cb70-1"></a>namespace std {</span>
<span id="cb70-2"><a href="#cb70-2"></a>template &lt;class charT, formattable&lt;charT&gt;... Ts&gt;</span>
<span id="cb70-3"><a href="#cb70-3"></a>  struct formatter&lt;<em>tuple-type</em>&lt;Ts...&gt;, charT&gt; {</span>
<span id="cb70-4"><a href="#cb70-4"></a>  private:</span>
<span id="cb70-5"><a href="#cb70-5"></a>    tuple&lt;formatter&lt;remove_cvref_t&lt;Ts&gt;, charT&gt;...&gt; <em>underlying_</em>;               // exposition only</span>
<span id="cb70-6"><a href="#cb70-6"></a>    basic_string_view&lt;charT&gt; <em>separator_</em> = <em>STATICALLY-WIDEN</em>&lt;charT&gt;(&quot;, &quot;);      // exposition only</span>
<span id="cb70-7"><a href="#cb70-7"></a>    basic_string_view&lt;charT&gt; <em>opening-bracket_</em> = <em>STATICALLY-WIDEN</em>&lt;charT&gt;(&quot;(&quot;); // exposition only</span>
<span id="cb70-8"><a href="#cb70-8"></a>    basic_string_view&lt;charT&gt; <em>closing-bracket_</em> = <em>STATICALLY-WIDEN</em>&lt;charT&gt;(&quot;)&quot;); // exposition only</span>
<span id="cb70-9"><a href="#cb70-9"></a></span>
<span id="cb70-10"><a href="#cb70-10"></a>  public:</span>
<span id="cb70-11"><a href="#cb70-11"></a>    void set_separator(basic_string_view&lt;charT&gt; sep);</span>
<span id="cb70-12"><a href="#cb70-12"></a>    void set_brackets(basic_string_view&lt;charT&gt; opening, basic_string_view&lt;charT&gt; closing);</span>
<span id="cb70-13"><a href="#cb70-13"></a></span>
<span id="cb70-14"><a href="#cb70-14"></a>    template &lt;class ParseContext&gt;</span>
<span id="cb70-15"><a href="#cb70-15"></a>      constexpr typename ParseContext::iterator</span>
<span id="cb70-16"><a href="#cb70-16"></a>        parse(ParseContext&amp; ctx);</span>
<span id="cb70-17"><a href="#cb70-17"></a></span>
<span id="cb70-18"><a href="#cb70-18"></a>    template &lt;class FormatContext&gt;</span>
<span id="cb70-19"><a href="#cb70-19"></a>      typename FormatContext::iterator</span>
<span id="cb70-20"><a href="#cb70-20"></a>        format(<em>see below</em>&amp; elems, FormatContext&amp; ctx) const;</span>
<span id="cb70-21"><a href="#cb70-21"></a>  };</span>
<span id="cb70-22"><a href="#cb70-22"></a>}</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_66" id="pnum_66">2</a></span> The <code class="sourceCode cpp">parse</code> member functions of these formatters interpret the format specification as a <code class="sourceCode cpp"><em>tuple-format-spec</em></code> according to the following syntax:</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb71-1"><a href="#cb71-1"></a><em>tuple-format-spec</em>:</span>
<span id="cb71-2"><a href="#cb71-2"></a>    <em>tuple-fill-and-align</em><sub>opt</sub> <em>width</em><sub>opt</sub> <em>tuple-type</em><sub>opt</sub></span>
<span id="cb71-3"><a href="#cb71-3"></a></span>
<span id="cb71-4"><a href="#cb71-4"></a><em>tuple-fill-and-align</em>:</span>
<span id="cb71-5"><a href="#cb71-5"></a>    <em>tuple-fill</em><sub>opt</sub> <em>align</em></span>
<span id="cb71-6"><a href="#cb71-6"></a></span>
<span id="cb71-7"><a href="#cb71-7"></a><em>tuple-fill</em>:</span>
<span id="cb71-8"><a href="#cb71-8"></a>    any character other than { or } or :</span>
<span id="cb71-9"><a href="#cb71-9"></a></span>
<span id="cb71-10"><a href="#cb71-10"></a><em>tuple-type</em>:</span>
<span id="cb71-11"><a href="#cb71-11"></a>    m</span>
<span id="cb71-12"><a href="#cb71-12"></a>    n</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_67" id="pnum_67">3</a></span> The <code class="sourceCode cpp"><em>tuple-fill-and-align</em></code> is interpreted the same way as a <code class="sourceCode cpp"><em>tuple-and-align</em></code> ([format.string.std]). The productions <code class="sourceCode cpp"><em>align</em></code> and <code class="sourceCode cpp"><em>width</em></code> are described in [format.string].</p>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_68" id="pnum_68">4</a></span> The <code class="sourceCode cpp"><em>tuple-type</em></code> specifier changes the way a <code class="sourceCode cpp">pair</code> or <code class="sourceCode cpp">tuple</code> is formatted, with certain options only valid with certain argument types. The meaning of the various type options is as specified in Table X.</p>
<table>
<colgroup>
<col style="width: 33%"></col>
<col style="width: 33%"></col>
<col style="width: 33%"></col>
</colgroup>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Option</strong>
</div></th>
<th><div style="text-align:center">
<strong>Requirements</strong>
</div></th>
<th><div style="text-align:center">
<strong>Meaning</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="sourceCode cpp">m</code></td>
<td><code class="sourceCode cpp"><span class="kw">sizeof</span><span class="op">...(</span>Ts<span class="op">)</span> <span class="op">==</span> <span class="dv">2</span></code></td>
<td>Equivalent to: <code class="sourceCode cpp">set_separator<span class="op">(</span><span class="st">&quot;: &quot;</span><span class="op">)</span>; set_brackets<span class="op">({}</span>, <span class="op">{})</span>;</code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">n</code></td>
<td>none</td>
<td>Equivalent to: <code class="sourceCode cpp">set_brackets<span class="op">({}</span>, <span class="op">{})</span>;</code></td>
</tr>
<tr class="odd">
<td>none</td>
<td>none</td>
<td>No effects</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb72"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb72-1"><a href="#cb72-1"></a>void set_separator(basic_string_view&lt;charT&gt; sep);</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_69" id="pnum_69">5</a></span> <em>Effects</em>: Equivalent to <code class="sourceCode cpp"><em>separator_</em> <span class="op">=</span> sep</code>;</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb73-1"><a href="#cb73-1"></a>void set_brackets(basic_string_view&lt;charT&gt; opening, basic_string_view&lt;charT&gt; closing);</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_70" id="pnum_70">6</a></span> <em>Effects</em>: Equivalent to</p>
<blockquote>
<div class="sourceCode" id="cb74"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb74-1"><a href="#cb74-1"></a><em>opening-bracket_</em> = opening;</span>
<span id="cb74-2"><a href="#cb74-2"></a><em>closing-bracket_</em> = closing;</span></code></pre></div>
</blockquote>
<div class="sourceCode" id="cb75"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb75-1"><a href="#cb75-1"></a>template &lt;class ParseContext&gt;</span>
<span id="cb75-2"><a href="#cb75-2"></a>  constexpr typename ParseContext::iterator</span>
<span id="cb75-3"><a href="#cb75-3"></a>    parse(ParseContext&amp; ctx);</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_71" id="pnum_71">7</a></span> <em>Effects</em>: Parses the format specifier as a <code class="sourceCode cpp"><em>tuple-format-spec</em></code> and stores the parsed specifiers in <code class="sourceCode cpp"><span class="op">*</span><span class="kw">this</span></code>. The values of <code class="sourceCode cpp"><em>opening-bracket_</em></code>, <code class="sourceCode cpp"><em>closing-bracket_</em></code>, and <code class="sourceCode cpp"><em>separator_</em></code> are modified if and only if required by the <em>tuple-type</em>. For each element <code class="sourceCode cpp"><em>e</em></code> in <code class="sourceCode cpp"><em>underlying_</em></code>, if <code class="sourceCode cpp"><em>e</em><span class="op">.</span>set_debug_format<span class="op">()</span></code> is a valid expression, calls <code class="sourceCode cpp"><em>e</em><span class="op">.</span>set_debug_format<span class="op">()</span></code>.</p>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_72" id="pnum_72">8</a></span> <em>Returns</em>: an iterator past the end of the <code class="sourceCode cpp"><em>tuple-format-spec</em></code>.</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb76-1"><a href="#cb76-1"></a>template &lt;class FormatContext&gt;</span>
<span id="cb76-2"><a href="#cb76-2"></a>  typename FormatContext::iterator</span>
<span id="cb76-3"><a href="#cb76-3"></a>    format(<em>see below</em>&amp; elems, FormatContext&amp; ctx) const;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_73" id="pnum_73">9</a></span> The type of <code class="sourceCode cpp">elems</code> is:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_74" id="pnum_74">(9.1)</a></span> If <code class="sourceCode cpp"><span class="op">(</span>formattable<span class="op">&lt;</span><span class="kw">const</span> Ts, charT<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> <span class="op">...)</span></code> is <code class="sourceCode cpp"><span class="kw">true</span></code>, <code class="sourceCode cpp"><span class="kw">const</span> <em>tuple-type</em><span class="op">&lt;</span>Ts<span class="op">...&gt;&amp;</span></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_75" id="pnum_75">(9.2)</a></span> Otherwise <code class="sourceCode cpp"><em>tuple-type</em><span class="op">&lt;</span>Ts<span class="op">...&gt;&amp;</span></code>.</li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_76" id="pnum_76">10</a></span> <em>Effects</em>: Writes the following into <code class="sourceCode cpp">ctx<span class="op">.</span>out<span class="op">()</span></code>, adjusted according to the <code class="sourceCode cpp"><em>tuple-format-spec</em></code>:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_77" id="pnum_77">(10.1)</a></span> <code class="sourceCode cpp"><em>opening-bracket_</em></code></li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_78" id="pnum_78">(10.2)</a></span> for each index <code class="sourceCode cpp">I</code> in the range <code class="sourceCode cpp"><span class="op">[</span><span class="dv">0</span>, <span class="kw">sizeof</span><span class="op">...(</span>Ts<span class="op">))</span></code>:
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_79" id="pnum_79">(10.2.1)</a></span> if <code class="sourceCode cpp">I <span class="op">!=</span> <span class="dv">0</span></code>, <code class="sourceCode cpp"><em>separator_</em></code></li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_80" id="pnum_80">(10.2.2)</a></span> the result of writing <code class="sourceCode cpp">get<span class="op">&lt;</span>I<span class="op">&gt;(</span>elems<span class="op">)</span></code> via <code class="sourceCode cpp">get<span class="op">&lt;</span>I<span class="op">&gt;(</span><em>underlying_</em><span class="op">)</span></code></li>
</ul></li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_81" id="pnum_81">(10.3)</a></span> <code class="sourceCode cpp"><em>closing-bracket_</em></code></li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_82" id="pnum_82">11</a></span> <em>Returns</em>: an iterator past the end of the output range.</p>
</div>
</blockquote>
<h2 data-number="5.5" id="formatter-for-vectorboolreference"><span class="header-section-number">5.5</span> Formatter for <code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;::</span>reference</code><a href="#formatter-for-vectorboolreference" class="self-link"></a></h2>
<p>Add to <span>24.3.6 <a href="https://wg21.link/vector.syn">[vector.syn]</a></span></p>
<blockquote>
<div>
<div class="sourceCode" id="cb77"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb77-1"><a href="#cb77-1"></a>namespace std {</span>
<span id="cb77-2"><a href="#cb77-2"></a>  // [vector], class template vector</span>
<span id="cb77-3"><a href="#cb77-3"></a>  template&lt;class T, class Allocator = allocator&lt;T&gt;&gt; class vector;</span>
<span id="cb77-4"><a href="#cb77-4"></a></span>
<span id="cb77-5"><a href="#cb77-5"></a>  // ...</span>
<span id="cb77-6"><a href="#cb77-6"></a></span>
<span id="cb77-7"><a href="#cb77-7"></a>  // [vector.bool], class vector&lt;bool&gt;</span>
<span id="cb77-8"><a href="#cb77-8"></a>  template&lt;class Allocator&gt; class vector&lt;bool, Allocator&gt;;</span>
<span id="cb77-9"><a href="#cb77-9"></a></span>
<span id="cb77-10"><a href="#cb77-10"></a><span class="va">+ template&lt;class T&gt;</span></span>
<span id="cb77-11"><a href="#cb77-11"></a><span class="va">+   inline constexpr bool <em>is-vector-bool-reference</em> = <em>see below</em>; // exposition only</span></span>
<span id="cb77-12"><a href="#cb77-12"></a></span>
<span id="cb77-13"><a href="#cb77-13"></a><span class="va">+ template&lt;class T, class charT&gt; requires <em>is-vector-bool-reference</em>&lt;T&gt;</span></span>
<span id="cb77-14"><a href="#cb77-14"></a><span class="va">+   struct formatter&lt;T, charT&gt;;</span></span></code></pre></div>
</div>
</blockquote>
<p>Add to [vector.bool] at the end:</p>
<blockquote>
<div class="addu">
<div class="sourceCode" id="cb78"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb78-1"><a href="#cb78-1"></a>template&lt;class R&gt;</span>
<span id="cb78-2"><a href="#cb78-2"></a>  inline constexpr bool <em>is-vector-bool-reference</em> = <em>see below</em>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_83" id="pnum_83">8</a></span> The variable template <code class="sourceCode cpp"><em>is-vector-bool-reference</em><span class="op">&lt;</span>T<span class="op">&gt;</span></code> is <code class="sourceCode cpp"><span class="kw">true</span></code> if <code class="sourceCode cpp">T</code> denotes the type <code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">bool</span>, Alloc<span class="op">&gt;::</span>reference</code> for some type <code class="sourceCode cpp">Alloc</code> and <code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">bool</span>, Alloc<span class="op">&gt;</span></code> is not a program-defined specialization.</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb79-1"><a href="#cb79-1"></a>template&lt;class T, class charT&gt; requires <em>is-vector-bool-reference</em>&lt;T&gt;</span>
<span id="cb79-2"><a href="#cb79-2"></a>  struct formatter&lt;T, charT&gt; {</span>
<span id="cb79-3"><a href="#cb79-3"></a>  private:</span>
<span id="cb79-4"><a href="#cb79-4"></a>    formatter&lt;bool, charT&gt; <em>underlying_</em>;     // exposition only</span>
<span id="cb79-5"><a href="#cb79-5"></a></span>
<span id="cb79-6"><a href="#cb79-6"></a>  public:</span>
<span id="cb79-7"><a href="#cb79-7"></a>    template &lt;class ParseContext&gt;</span>
<span id="cb79-8"><a href="#cb79-8"></a>      constexpr typename ParseContext::iterator</span>
<span id="cb79-9"><a href="#cb79-9"></a>        parse(ParseContext&amp; ctx);</span>
<span id="cb79-10"><a href="#cb79-10"></a></span>
<span id="cb79-11"><a href="#cb79-11"></a>    template &lt;class FormatContext&gt;</span>
<span id="cb79-12"><a href="#cb79-12"></a>      typename FormatContext::iterator</span>
<span id="cb79-13"><a href="#cb79-13"></a>        format(const T&amp; ref, FormatContext&amp; ctx) const;</span>
<span id="cb79-14"><a href="#cb79-14"></a>  };</span></code></pre></div>
<div class="sourceCode" id="cb80"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb80-1"><a href="#cb80-1"></a>template &lt;class ParseContext&gt;</span>
<span id="cb80-2"><a href="#cb80-2"></a>  constexpr typename ParseContext::iterator</span>
<span id="cb80-3"><a href="#cb80-3"></a>    parse(ParseContext&amp; ctx);</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_84" id="pnum_84">9</a></span> <em>Effects</em>: Equivalent to <code class="sourceCode cpp"><span class="cf">return</span> <em>underlying_</em><span class="op">.</span>parse<span class="op">(</span>ctx<span class="op">)</span>;</code></p>
<div class="sourceCode" id="cb81"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb81-1"><a href="#cb81-1"></a>template &lt;class FormatContext&gt;</span>
<span id="cb81-2"><a href="#cb81-2"></a>  typename FormatContext::iterator</span>
<span id="cb81-3"><a href="#cb81-3"></a>    format(const T&amp; ref, FormatContext&amp; ctx) const;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_85" id="pnum_85">10</a></span> <em>Effects</em>: Equivalent to <code class="sourceCode cpp"><span class="cf">return</span> <em>underlying_</em><span class="op">.</span>format<span class="op">(</span>ref, ctx<span class="op">)</span>;</code></p>
</div>
</blockquote>
<h2 data-number="5.6" id="feature-test-macro"><span class="header-section-number">5.6</span> Feature-test Macro<a href="#feature-test-macro" class="self-link"></a></h2>
<p>Bump the feature-test macro for <code class="sourceCode cpp">__cpp_lib_format</code> in <span>17.3.2 <a href="https://wg21.link/version.syn">[version.syn]</a></span>:</p>
<blockquote>
<div>
<div class="sourceCode" id="cb82"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb82-1"><a href="#cb82-1"></a><span class="st">- #define __cpp_lib_format  <span class="diffdel">202110L</span> // also in &lt;format&gt;</span></span>
<span id="cb82-2"><a href="#cb82-2"></a><span class="va">+ #define __cpp_lib_format  <span class="diffins">2022XXL</span> // also in &lt;format&gt;</span></span></code></pre></div>
</div>
</blockquote>
<h1 data-number="6" style="border-bottom:1px solid #cccccc" id="acknowledgments"><span class="header-section-number">6</span> Acknowledgments<a href="#acknowledgments" class="self-link"></a></h1>
<p>Thanks to Victor Zverovich for <code class="sourceCode cpp"><span class="op">{</span>fmt<span class="op">}</span></code>, explanation of Unicode, and numerous design discussions. Thanks to Peter Dimov for design feedback. Thanks to Tim Song for invaluable help on the design and wording.</p>
<h1 data-number="7" style="border-bottom:1px solid #cccccc" id="bibliography"><span class="header-section-number">7</span> References<a href="#bibliography" class="self-link"></a></h1>
<div id="refs" class="references hanging-indent" role="doc-bibliography">
<div id="ref-LWG3478">
<p>[LWG3478] Barry Revzin. views::split drops trailing empty range. <br />
<a href="https://wg21.link/lwg3478">https://wg21.link/lwg3478</a></p>
</div>
<div id="ref-LWG3636">
<p>[LWG3636] Arthur O’Dwyer. formatter<t>::format should be const-qualified. <br />
<a href="https://wg21.link/lwg3636">https://wg21.link/lwg3636</a></p>
</div>
<div id="ref-P1636R2">
<p>[P1636R2] Lars Gullik Bjønnes. 2019-10-06. Formatters for library types. <br />
<a href="https://wg21.link/p1636r2">https://wg21.link/p1636r2</a></p>
</div>
<div id="ref-P2214R1">
<p>[P2214R1] Barry Revzin, Conor Hoekstra, Tim Song. 2021-09-14. A Plan for C++23 Ranges. <br />
<a href="https://wg21.link/p2214r1">https://wg21.link/p2214r1</a></p>
</div>
<div id="ref-P2286R0">
<p>[P2286R0] Barry Revzin. 2021-01-15. Formatting Ranges. <br />
<a href="https://wg21.link/p2286r0">https://wg21.link/p2286r0</a></p>
</div>
<div id="ref-P2286R1">
<p>[P2286R1] Barry Revzin. 2021-02-19. Formatting Ranges. <br />
<a href="https://wg21.link/p2286r1">https://wg21.link/p2286r1</a></p>
</div>
<div id="ref-P2286R2">
<p>[P2286R2] Barry Revzin. 2021-08-16. Formatting Ranges. <br />
<a href="https://wg21.link/p2286r2">https://wg21.link/p2286r2</a></p>
</div>
<div id="ref-P2286R3">
<p>[P2286R3] Barry Revzin. 2021-11-17. Formatting Ranges. <br />
<a href="https://wg21.link/p2286r3">https://wg21.link/p2286r3</a></p>
</div>
<div id="ref-P2286R4">
<p>[P2286R4] Barry Revzin. 2021-12-18. Formatting Ranges. <br />
<a href="https://wg21.link/p2286r4">https://wg21.link/p2286r4</a></p>
</div>
<div id="ref-P2286R5">
<p>[P2286R5] Barry Revzin. 2022-01-15. Formatting Ranges. <br />
<a href="https://wg21.link/p2286r5">https://wg21.link/p2286r5</a></p>
</div>
<div id="ref-P2286R6">
<p>[P2286R6] Barry Revzin. 2022-01-19. Formatting Ranges. <br />
<a href="https://wg21.link/p2286r6">https://wg21.link/p2286r6</a></p>
</div>
<div id="ref-P2290R2">
<p>[P2290R2] Corentin Jabot. 2021-07-15. Delimited escape sequences. <br />
<a href="https://wg21.link/p2290r2">https://wg21.link/p2290r2</a></p>
</div>
<div id="ref-P2321R2">
<p>[P2321R2] Tim Song. 2021-06-11. zip. <br />
<a href="https://wg21.link/p2321r2">https://wg21.link/p2321r2</a></p>
</div>
<div id="ref-P2418R0">
<p>[P2418R0] Victor Zverovich. 2021-08-08. Add support for std::generator-like types to std::format. <br />
<a href="https://wg21.link/p2418r0">https://wg21.link/p2418r0</a></p>
</div>
<div id="ref-P2418R2">
<p>[P2418R2] Victor Zverovich. 2021-09-24. Add support for std::generator-like types to std::format. <br />
<a href="https://wg21.link/p2418r2">https://wg21.link/p2418r2</a></p>
</div>
<div id="ref-PEP-3138">
<p>[PEP-3138] Atsuo Ishimoto. 2008. PEP 3138 – String representation in Python 3000. <br />
<a href="https://www.python.org/dev/peps/pep-3138/">https://www.python.org/dev/peps/pep-3138/</a></p>
</div>
</div>
</div>
</div>
</body>
</html>
