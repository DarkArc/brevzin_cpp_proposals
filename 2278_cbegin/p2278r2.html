<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="mpark/wg21" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2021-11-13" />
  <title>cbegin should always return a constant iterator</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
      div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
      ul.task-list{list-style: none;}
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode
        {  background-color: #f6f8fa; }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span. { } /* Normal */
      code span.al { color: #ff0000; } /* Alert */
      code span.an { } /* Annotation */
      code span.at { } /* Attribute */
      code span.bn { color: #9f6807; } /* BaseN */
      code span.bu { color: #9f6807; } /* BuiltIn */
      code span.cf { color: #00607c; } /* ControlFlow */
      code span.ch { color: #9f6807; } /* Char */
      code span.cn { } /* Constant */
      code span.co { color: #008000; font-style: italic; } /* Comment */
      code span.cv { color: #008000; font-style: italic; } /* CommentVar */
      code span.do { color: #008000; } /* Documentation */
      code span.dt { color: #00607c; } /* DataType */
      code span.dv { color: #9f6807; } /* DecVal */
      code span.er { color: #ff0000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #9f6807; } /* Float */
      code span.fu { } /* Function */
      code span.im { } /* Import */
      code span.in { color: #008000; } /* Information */
      code span.kw { color: #00607c; } /* Keyword */
      code span.op { color: #af1915; } /* Operator */
      code span.ot { } /* Other */
      code span.pp { color: #6f4e37; } /* Preprocessor */
      code span.re { } /* RegionMarker */
      code span.sc { color: #9f6807; } /* SpecialChar */
      code span.ss { color: #9f6807; } /* SpecialString */
      code span.st { color: #9f6807; } /* String */
      code span.va { } /* Variable */
      code span.vs { color: #9f6807; } /* VerbatimString */
      code span.wa { color: #008000; font-weight: bold; } /* Warning */
      code.diff {color: #898887}
      code.diff span.va {color: #006e28}
      code.diff span.st {color: #bf0303}
  </style>
  <style type="text/css">
body {
margin: 5em;
font-family: serif;

hyphens: auto;
line-height: 1.35;
}
div.wrapper {
max-width: 60em;
margin: auto;
}
ul {
list-style-type: none;
padding-left: 2em;
margin-top: -0.2em;
margin-bottom: -0.2em;
}
a {
text-decoration: none;
color: #4183C4;
}
a.hidden_link {
text-decoration: none;
color: inherit;
}
li {
margin-top: 0.6em;
margin-bottom: 0.6em;
}
h1, h2, h3, h4 {
position: relative;
line-height: 1;
}
a.self-link {
position: absolute;
top: 0;
left: calc(-1 * (3.5rem - 26px));
width: calc(3.5rem - 26px);
height: 2em;
text-align: center;
border: none;
transition: opacity .2s;
opacity: .5;
font-family: sans-serif;
font-weight: normal;
font-size: 83%;
}
a.self-link:hover { opacity: 1; }
a.self-link::before { content: "§"; }
ul > li:before {
content: "\2014";
position: absolute;
margin-left: -1.5em;
}
:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }
.abbr_ref { float: right; }
.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }
:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }
.secnum { display: inline-block; min-width: 35pt; }
.header-section-number { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }
div.sourceLinkParent {
float: right;
}
a.sourceLink {
position: absolute;
opacity: 0;
margin-left: 10pt;
}
a.sourceLink:hover {
opacity: 1;
}
a.itemDeclLink {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
opacity: 0;
}
a.itemDeclLink:hover { opacity: 1; }
span.marginalizedparent {
position: relative;
left: -5em;
}
li span.marginalizedparent { left: -7em; }
li ul > li span.marginalizedparent { left: -9em; }
li ul > li ul > li span.marginalizedparent { left: -11em; }
li ul > li ul > li ul > li span.marginalizedparent { left: -13em; }
div.footnoteNumberParent {
position: relative;
left: -4.7em;
}
a.marginalized {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
}
a.enumerated_item_num {
position: relative;
left: -3.5em;
display: inline-block;
margin-right: -3em;
text-align: right;
width: 3em;
}
div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }
span.indexparent {
display: inline;
position: relative;
float: right;
right: -1em;
}
a.index {
position: absolute;
display: none;
}
a.index:before { content: "⟵"; }

a.index:target {
display: inline;
}
.indexitems {
margin-left: 2em;
text-indent: -2em;
}
div.itemdescr {
margin-left: 3em;
}
.bnf {
font-family: serif;
margin-left: 40pt;
margin-top: 0.5em;
margin-bottom: 0.5em;
}
.ncbnf {
font-family: serif;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
}
.ncsimplebnf {
font-family: serif;
font-style: italic;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
background: inherit; 
}
span.textnormal {
font-style: normal;
font-family: serif;
white-space: normal;
display: inline-block;
}
span.rlap {
display: inline-block;
width: 0px;
}
span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }
span.phantom { color: white; }

span.math { font-style: normal; }
span.mathblock {
display: block;
margin-left: auto;
margin-right: auto;
margin-top: 1.2em;
margin-bottom: 1.2em;
text-align: center;
}
span.mathalpha {
font-style: italic;
}
span.synopsis {
font-weight: bold;
margin-top: 0.5em;
display: block;
}
span.definition {
font-weight: bold;
display: block;
}
.codeblock {
margin-left: 1.2em;
line-height: 127%;
}
.outputblock {
margin-left: 1.2em;
line-height: 127%;
}
div.itemdecl {
margin-top: 2ex;
}
code.itemdeclcode {
white-space: pre;
display: block;
}
span.textsuperscript {
vertical-align: super;
font-size: smaller;
line-height: 0;
}
.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }
.footnote {
font-size: small;
margin-left: 2em;
margin-right: 2em;
margin-top: 0.6em;
margin-bottom: 0.6em;
}
div.minipage {
display: inline-block;
margin-right: 3em;
}
div.numberedTable {
text-align: center;
margin: 2em;
}
div.figure {
text-align: center;
margin: 2em;
}
table {
border: 1px solid black;
border-collapse: collapse;
margin-left: auto;
margin-right: auto;
margin-top: 0.8em;
text-align: left;
hyphens: none; 
}
td, th {
padding-left: 1em;
padding-right: 1em;
vertical-align: top;
}
td.empty {
padding: 0px;
padding-left: 1px;
}
td.left {
text-align: left;
}
td.right {
text-align: right;
}
td.center {
text-align: center;
}
td.justify {
text-align: justify;
}
td.border {
border-left: 1px solid black;
}
tr.rowsep, td.cline {
border-top: 1px solid black;
}
tr.even, tr.odd {
border-bottom: 1px solid black;
}
tr.capsep {
border-top: 3px solid black;
border-top-style: double;
}
tr.header {
border-bottom: 3px solid black;
border-bottom-style: double;
}
th {
border-bottom: 1px solid black;
}
span.centry {
font-weight: bold;
}
div.table {
display: block;
margin-left: auto;
margin-right: auto;
text-align: center;
width: 90%;
}
span.indented {
display: block;
margin-left: 2em;
margin-bottom: 1em;
margin-top: 1em;
}
ol.enumeratea { list-style-type: none; background: inherit; }
ol.enumerate { list-style-type: none; background: inherit; }

code.sourceCode > span { display: inline; }
</style>
  <style type="text/css">a {
color : #4183C4;
text-decoration: underline;
}
a.marginalized {
text-decoration: none;
}
a.self-link {
text-decoration: none;
}
h1#toctitle {
border-bottom: 1px solid #cccccc;
}
#TOC li {
margin-top: 1px;
margin-bottom: 1px;
}
#TOC ul>li:before { display: none; }
h3.subtitle { margin-top: -15px; }
h1:target { background-color: transparent; }
h2:target { background-color: transparent; }
h3:target { background-color: transparent; }
h4:target { background-color: transparent; }
h5:target { background-color: transparent; }
h6:target { background-color: transparent; }
code span.co { font-family: monospace; }
table tr {
background-color: white;
}
table tr:nth-child(2n) {
background-color: #f6f8fa;
}
#title-block-header > table tr:nth-child(2n) {
background-color: white;
}
td > div.sourceCode {
background-color: inherit;
}
table {
border-collapse: collapse;
}
table td, table th {
border: 1px solid #cccccc;
}
table th {
border-bottom: 1px solid black;
text-align: center;
}
table tr:first-child th {
border-top: 0;
}
table tr:last-child td {
border-bottom: 0;
}
table tr td:first-child,
table tr th:first-child {
border-left: 0;
}
table tr td:last-child,
table tr th:last-child {
border-right: 0;
}
table tbody tr:first-child td {
border-top: 1px solid black;
}
#title-block-header td { border: 0; }
@media all {
body {
margin: 2em;
}
}
@media screen and (min-width: 480px) {
body {
margin: 5em;
}
}
#refs code{padding-left: 0px; text-indent: 0px;}
:root {
--diff-ins: #e6ffed;
--diff-strongins: #acf2bd;
--diff-del: #ffdddd;
--diff-strongdel: #ff8888;
}
span.diffins {
background-color: var(--diff-strongins);
}
span.diffdel {
background-color: var(--diff-strongdel);
}
div.rm { text-decoration: line-through; }
div.rm code.sourceCode { text-decoration: line-through; }
div.addu, span.addu {
color: #006e28;
background-color: var(--diff-ins);
}

div.rm pre, div.add pre { background-color: #f6f8fa; }
div.addu pre { background-color: var(--diff-ins); }
div.add, div.add pre { background-color: var(--diff-ins); }
div.addu blockquote {
border-left: 4px solid #00a000;
padding: 0 15px;
color: #006e28;
text-decoration: none;
}
div.addu blockquote code.sourceCode { text-decoration: none; }
div.addu blockquote pre { text-decoration: none; }
div.addu blockquote pre code { text-decoration: none; }
div.quote {
border-left: 7px solid #ccc;
background: #f9f9f9;
margin: 1.5em 10px;
padding-left: 20px;
}
code.diff span.va { color: #000000; background-color: var(--diff-ins); }
code.diff span.st { color: #000000; background-color: var(--diff-del); }
</style>
  <link href="data:image/x-icon;base64,AAABAAIAEBAAAAEAIABoBAAAJgAAACAgAAABACAAqBAAAI4EAAAoAAAAEAAAACAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAVoJEAN6CRADegkQAWIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wCCRAAAgkQAAIJEAACCRAAsgkQAvoJEAP+CRAD/gkQA/4JEAP+CRADAgkQALoJEAACCRAAAgkQAAP///wD///8AgkQAAIJEABSCRACSgkQA/IJEAP99PQD/dzMA/3czAP99PQD/gkQA/4JEAPyCRACUgkQAFIJEAAD///8A////AHw+AFiBQwDqgkQA/4BBAP9/PxP/uZd6/9rJtf/bybX/upd7/39AFP+AQQD/gkQA/4FDAOqAQgBc////AP///wDKklv4jlEa/3o7AP+PWC//8+3o///////////////////////z7un/kFox/35AAP+GRwD/mVYA+v///wD///8A0Zpk+NmibP+0d0T/8evj///////+/fv/1sKz/9bCs//9/fr//////+/m2/+NRwL/nloA/5xYAPj///8A////ANKaZPjRmGH/5cKh////////////k149/3UwAP91MQD/lmQ//86rhv+USg3/m1YA/5hSAP+bVgD4////AP///wDSmmT4zpJY/+/bx///////8+TV/8mLT/+TVx//gkIA/5lVAP+VTAD/x6B//7aEVv/JpH7/s39J+P///wD///8A0ppk+M6SWP/u2sf///////Pj1f/Nj1T/2KFs/8mOUv+eWhD/lEsA/8aee/+0glT/x6F7/7J8Rvj///8A////ANKaZPjRmGH/48Cf///////+/v7/2qt//82PVP/OkFX/37KJ/86siv+USg7/mVQA/5hRAP+bVgD4////AP///wDSmmT40ppk/9CVXP/69O////////7+/v/x4M//8d/P//7+/f//////9u7n/6tnJf+XUgD/nFgA+P///wD///8A0ppk+NKaZP/RmWL/1qNy//r07///////////////////////+vXw/9akdP/Wnmn/y5FY/6JfFvj///8A////ANKaZFTSmmTo0ppk/9GYYv/Ql1//5cWm//Hg0P/x4ND/5cWm/9GXYP/RmGH/0ppk/9KaZOjVnmpY////AP///wDSmmQA0ppkEtKaZI7SmmT60ppk/9CWX//OkVb/zpFW/9CWX//SmmT/0ppk/NKaZJDSmmQS0ppkAP///wD///8A0ppkANKaZADSmmQA0ppkKtKaZLrSmmT/0ppk/9KaZP/SmmT/0ppkvNKaZCrSmmQA0ppkANKaZAD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkUtKaZNzSmmTc0ppkVNKaZADSmmQA0ppkANKaZADSmmQA////AP5/AAD4HwAA4AcAAMADAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAMADAADgBwAA+B8AAP5/AAAoAAAAIAAAAEAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAyCRACMgkQA6oJEAOqCRACQgkQAEIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRABigkQA5oJEAP+CRAD/gkQA/4JEAP+CRADqgkQAZoJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAA4gkQAwoJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQAxIJEADyCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAP///wD///8A////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAWgkQAmIJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAJyCRAAYgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAdIJEAPCCRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAPSCRAB4gkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQASoJEANKCRAD/gkQA/4JEAP+CRAD/g0YA/39AAP9zLgD/bSQA/2shAP9rIQD/bSQA/3MuAP9/PwD/g0YA/4JEAP+CRAD/gkQA/4JEAP+CRADUgkQAToJEAACCRAAAgkQAAP///wD///8A////AP///wB+PwAAgkUAIoJEAKiCRAD/gkQA/4JEAP+CRAD/hEcA/4BBAP9sIwD/dTAA/5RfKv+viF7/vp56/76ee/+wiF7/lWAr/3YxAP9sIwD/f0AA/4RHAP+CRAD/gkQA/4JEAP+CRAD/gkQArIJEACaBQwAA////AP///wD///8A////AIBCAEBzNAD6f0EA/4NFAP+CRAD/gkQA/4VIAP92MwD/bSUA/6N1Tv/ezsL/////////////////////////////////38/D/6V3Uv9uJgD/dTEA/4VJAP+CRAD/gkQA/4JEAP+BQwD/fUAA/4FDAEj///8A////AP///wD///8AzJRd5qBlKf91NgD/dDUA/4JEAP+FSQD/cy4A/3YyAP/PuKP//////////////////////////////////////////////////////9K7qP94NQD/ciwA/4VJAP+CRAD/fkEA/35BAP+LSwD/mlYA6v///wD///8A////AP///wDdpnL/4qx3/8KJUv+PUhf/cTMA/3AsAP90LgD/4dK+/////////////////////////////////////////////////////////////////+TYxf91MAD/dTIA/31CAP+GRwD/llQA/6FcAP+gWwD8////AP///wD///8A////ANGZY/LSm2X/4ap3/92mcP+wdT3/byQA/8mwj////////////////////////////////////////////////////////////////////////////+LYxv9zLgP/jUoA/59bAP+hXAD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/RmWL/1p9q/9ubXv/XqXj////////////////////////////7+fD/vZyG/6BxS/+gcUr/vJuE//r37f//////////////////////3MOr/5dQBf+dVQD/nVkA/5xYAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmWP/yohJ//jo2P//////////////////////4NTG/4JDFf9lGAD/bSQA/20kAP9kGAD/fz8S/+Xb0f//////5NG9/6txN/+LOgD/m1QA/51aAP+cWAD/m1cA/5xYAP+cWADy////AP///wD///8A////ANKaZPLSmmT/0ppk/8+TWf/Unmv//v37//////////////////////+TWRr/VwsA/35AAP+ERgD/g0UA/4JGAP9lHgD/kFga/8KXX/+TRwD/jT4A/49CAP+VTQD/n10A/5xYAP+OQQD/lk4A/55cAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/y4tO/92yiP//////////////////////8NnE/8eCQP+rcTT/ez0A/3IyAP98PgD/gEMA/5FSAP+USwD/jj8A/5lUAP+JNwD/yqV2/694Mf+HNQD/jkAA/82rf/+laBj/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/LiUr/4byY///////////////////////gupX/0I5P/+Wuev/Lklz/l1sj/308AP+QSwD/ol0A/59aAP+aVQD/k0oA/8yoh///////+fXv/6pwO//Lp3v///////Pr4f+oay7y////AP///wD///8A////ANKaZPLSmmT/0ppk/8uJSv/hvJj//////////////////////+G7l//Jhkb/0ppk/96nc//fqXX/x4xO/6dkFP+QSQD/llEA/5xXAP+USgD/yaOA///////38uv/qG05/8ijdv//////8efb/6ZpLPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/zIxO/9yxh///////////////////////7dbA/8iEQf/Sm2X/0Zlj/9ScZv/eqHf/2KJv/7yAQf+XTgD/iToA/5lSAP+JNgD/yKFv/611LP+HNQD/jT8A/8qmeP+kZRT/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/Pk1n/1J5q//78+//////////////////+/fv/1aFv/8iEQv/Tm2b/0ppl/9GZY//Wn2z/1pZc/9eldf/Bl2b/kUcA/4w9AP+OQAD/lUwA/59eAP+cWQD/jT8A/5ZOAP+eXADy////AP///wD///8A////ANKaZPLSmmT/0ppk/9KZY//KiEn/8d/P///////////////////////47+f/05tm/8iCP//KiEj/yohJ/8eCP//RmGH//vfy///////n1sP/rXQ7/4k4AP+TTAD/nVoA/5xYAP+cVwD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/0ptl/8uLTf/aq37////////////////////////////+/fz/6c2y/961jv/etY7/6Myx//78+v//////////////////////3MWv/5xXD/+ORAD/mFQA/51ZAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmmT/0ppk/8mFRP/s1b//////////////////////////////////////////////////////////////////////////////+PD/0JFU/7NzMv+WUQD/kUsA/5tXAP+dWQDy////AP///wD///8A////ANKaZP/SmmT/0ppk/9KaZP/Sm2X/z5NZ/8yMT//z5NX/////////////////////////////////////////////////////////////////9Ofa/8yNUP/UmGH/36p5/8yTWv+qaSD/kksA/5ROAPz///8A////AP///wD///8A0ppk5NKaZP/SmmT/0ppk/9KaZP/TnGf/zY9T/82OUv/t1sD//////////////////////////////////////////////////////+7Yw//OkFX/zI5R/9OcZ//SmmP/26V0/9ymdf/BhUf/ol8R6P///wD///8A////AP///wDSmmQ80ppk9tKaZP/SmmT/0ppk/9KaZP/TnGj/zpFW/8qJSv/dson/8uHS//////////////////////////////////Lj0//etIv/y4lL/86QVf/TnGj/0ppk/9KaZP/RmWP/05xn/9ymdfjUnWdC////AP///wD///8A////ANKaZADSmmQc0ppkotKaZP/SmmT/0ppk/9KaZP/Tm2b/0Zli/8qJSf/NjlH/16Z3/+G8mP/myKr/5siq/+G8mP/Xp3f/zY5S/8qISf/RmGH/05tm/9KaZP/SmmT/0ppk/9KaZP/SmmSm0pljINWdaQD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkQtKaZMrSmmT/0ppk/9KaZP/SmmT/0ptl/9GYYf/Nj1P/y4lL/8qISP/KiEj/y4lK/82PU//RmGH/0ptl/9KaZP/SmmT/0ppk/9KaZP/SmmTO0ppkRtKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZGzSmmTu0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmTw0ppkcNKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZBLSmmSQ0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppklNKaZBTSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQy0ppkutKaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppkvtKaZDbSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkXNKaZODSmmT/0ppk/9KaZP/SmmT/0ppk5NKaZGDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkBtKaZIbSmmTo0ppk6tKaZIrSmmQK0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP/8P///+B///+AH//+AAf//AAD//AAAP/AAAA/gAAAHwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA+AAAAfwAAAP/AAAP/8AAP//gAH//+AH///4H////D//" rel="icon" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
</head>
<body>
<div class="wrapper">
<header id="title-block-header">
<h1 class="title" style="text-align:center"><code class="sourceCode cpp">cbegin</code> should always return a constant iterator</h1>

<table style="border:none;float:right">
  <tr>
    <td>Document #:</td>
    <td>P2278R2</td>
  </tr>
  <tr>
    <td>Date:</td>
    <td>2021-11-13</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Project:</td>
    <td>Programming Language C++</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Audience:</td>
    <td>
      LEWG<br>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top">Reply-to:</td>
    <td>
      Barry Revzin<br>&lt;<a href="mailto:barry.revzin@gmail.com" class="email">barry.revzin@gmail.com</a>&gt;<br>
    </td>
  </tr>
</table>

</header>
<div style="clear:both">
<div id="TOC" role="doc-toc">
<h1 id="toctitle">Contents</h1>
<ul>
<li><a href="#revision-history"><span class="toc-section-number">1</span> Revision History<span></span></a></li>
<li><a href="#how-we-got-to-here"><span class="toc-section-number">2</span> How we got to here<span></span></a>
<ul>
<li><a href="#prologue-terminology"><span class="toc-section-number">2.1</span> Prologue: Terminology<span></span></a></li>
<li><a href="#act-i-introduction-of-member-cbegin"><span class="toc-section-number">2.2</span> Act I: Introduction of Member <code class="sourceCode cpp">cbegin</code><span></span></a></li>
<li><a href="#act-ii-rise-of-non-member-cbegin"><span class="toc-section-number">2.3</span> Act II: Rise of Non-Member <code class="sourceCode cpp">cbegin</code><span></span></a></li>
<li><a href="#act-iii-climax-of-the-views"><span class="toc-section-number">2.4</span> Act III: Climax of the Views<span></span></a></li>
<li><a href="#intermezzo-examining-the-c20-status-quo"><span class="toc-section-number">2.5</span> Intermezzo: Examining the C++20 Status Quo<span></span></a></li>
<li><a href="#a-non-solution-member-cbegin"><span class="toc-section-number">2.6</span> A Non-Solution: Member <code class="sourceCode cpp">cbegin<span class="op">()</span></code><span></span></a></li>
</ul></li>
<li><a href="#act-iv-stdconst_iterator"><span class="toc-section-number">3</span> Act IV: <code class="sourceCode cpp">std<span class="op">::</span>const_iterator</code><span></span></a>
<ul>
<li><a href="#a-reverse-digression"><span class="toc-section-number">3.1</span> A Reverse Digression<span></span></a></li>
<li><a href="#const-is-no-different"><span class="toc-section-number">3.2</span> Const Is No Different<span></span></a></li>
<li><a href="#implementing-stdbasic_const_iteratori"><span class="toc-section-number">3.3</span> Implementing <code class="sourceCode cpp">std<span class="op">::</span>basic_const_iterator<span class="op">&lt;</span>I<span class="op">&gt;</span></code><span></span></a></li>
<li><a href="#better-algorithms-for-stdrangescbegin-and-stdrangesend"><span class="toc-section-number">3.4</span> Better Algorithms for <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>end</code><span></span></a></li>
<li><a href="#a-viewsall_const"><span class="toc-section-number">3.5</span> A <code class="sourceCode cpp">views<span class="op">::</span>all_const</code><span></span></a>
<ul>
<li><a href="#naming"><span class="toc-section-number">3.5.1</span> Naming<span></span></a></li>
</ul></li>
<li><a href="#what-about-stdcbegin-and-stdcend"><span class="toc-section-number">3.6</span> What About <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>cend</code>?<span></span></a></li>
<li><a href="#now-reverse-it"><span class="toc-section-number">3.7</span> Now Reverse It<span></span></a></li>
<li><a href="#customizing-make_const_iterator"><span class="toc-section-number">3.8</span> Customizing <code class="sourceCode cpp">make_const_iterator</code><span></span></a></li>
<li><a href="#what-does-this-mean-for-spant"><span class="toc-section-number">3.9</span> What does this mean for <code class="sourceCode cpp">span<span class="op">&lt;</span>T<span class="op">&gt;</span></code>?<span></span></a></li>
</ul></li>
<li><a href="#act-v-a-concluding-proposal"><span class="toc-section-number">4</span> Act V: A Concluding Proposal<span></span></a>
<ul>
<li><a href="#wording"><span class="toc-section-number">4.1</span> Wording<span></span></a>
<ul>
<li><a href="#span"><span class="toc-section-number">4.1.1</span> Span<span></span></a></li>
<li><a href="#iterators"><span class="toc-section-number">4.1.2</span> Iterators<span></span></a></li>
<li><a href="#ranges"><span class="toc-section-number">4.1.3</span> Ranges<span></span></a></li>
<li><a href="#all-const-view-range.all.const">24.7.? All const view [range.all.const]<span></span></a></li>
<li><a href="#feature-test-macro"><span class="toc-section-number">4.1.4</span> Feature-test macro<span></span></a></li>
</ul></li>
</ul></li>
<li><a href="#epilogue"><span class="toc-section-number">5</span> Epilogue<span></span></a></li>
<li><a href="#bibliography"><span class="toc-section-number">6</span> References<span></span></a></li>
</ul>
</div>
<h1 data-number="1" style="border-bottom:1px solid #cccccc" id="revision-history"><span class="header-section-number">1</span> Revision History<a href="#revision-history" class="self-link"></a></h1>
<p>Since <span class="citation" data-cites="P2278R1">[<a href="#ref-P2278R1" role="doc-biblioref">P2278R1</a>]</span>, renamed <code class="sourceCode cpp">views<span class="op">::</span>as_const</code> to <code class="sourceCode cpp">views<span class="op">::</span>all_const</code>. Added several additional alias templates and a feature-test macro. Fixed some wording issues.</p>
<p>Since <span class="citation" data-cites="P2278R0">[<a href="#ref-P2278R0" role="doc-biblioref">P2278R0</a>]</span>, added wording (including <code class="sourceCode cpp">ranges<span class="op">::</span>cdata</code>, which was omitted in the first revision, and adding member <code class="sourceCode cpp">cbegin</code> and <code class="sourceCode cpp">cend</code> to <code class="sourceCode cpp">view_interface</code>). Renamed <code class="sourceCode cpp">views<span class="op">::</span>as_const</code> to <code class="sourceCode cpp">views<span class="op">::</span>as_const</code>. Also fixed <code class="sourceCode cpp">views<span class="op">::</span>as_const</code> definition to handle deep-const <code class="sourceCode cpp">view</code>s (they do exist).</p>
<h1 data-number="2" style="border-bottom:1px solid #cccccc" id="how-we-got-to-here"><span class="header-section-number">2</span> How we got to here<a href="#how-we-got-to-here" class="self-link"></a></h1>
<p>A tale in many acts.</p>
<h2 data-number="2.1" id="prologue-terminology"><span class="header-section-number">2.1</span> Prologue: Terminology<a href="#prologue-terminology" class="self-link"></a></h2>
<p><span>23.3.1 <a href="https://wg21.link/iterator.requirements.general">[iterator.requirements.general]</a></span>/5 states:</p>
<blockquote>
<p>Iterators that further meet the requirements of output iterators are called <em>mutable iterators</em>. Nonmutable iterators are referred to as <em>constant iterators</em>.</p>
</blockquote>
<p>This paper uses those terms with those meanings: a mutable iterator is one that is writable to, a constant iterator is one that is not writable to.</p>
<h2 data-number="2.2" id="act-i-introduction-of-member-cbegin"><span class="header-section-number">2.2</span> Act I: Introduction of Member <code class="sourceCode cpp">cbegin</code><a href="#act-i-introduction-of-member-cbegin" class="self-link"></a></h2>
<p>In 2004, C++0x had added <code class="sourceCode cpp"><span class="kw">auto</span></code> but not yet added the range-based for statement. So there was this problem: how do you write a for loop that is immutable? The goal of the paper was quite clear:</p>
<div class="quote">
<p>This paper proposes to improve user access to the <code class="sourceCode cpp"><span class="kw">const</span></code> versions of C++ container <code class="sourceCode cpp">iterator</code>s and <code class="sourceCode cpp">reverse_iterator</code>s.</p>
</div>
<p>and:</p>
<div class="quote">
<p>However, when a container traversal is intended for inspection only, it is a generally preferred practice to use a <code class="sourceCode cpp">const_iterator</code> in order to permit the compiler to diagnose <code class="sourceCode cpp"><span class="kw">const</span></code>-correctness violations</p>
</div>
<p>The solution proposed in <span class="citation" data-cites="N1674">[<a href="#ref-N1674" role="doc-biblioref">N1674</a>]</span> (and later adopted by way of <span class="citation" data-cites="N1913">[<a href="#ref-N1913" role="doc-biblioref">N1913</a>]</span>) was to add members <code class="sourceCode cpp">cbegin<span class="op">()</span></code> and <code class="sourceCode cpp">cend<span class="op">()</span></code> (and <code class="sourceCode cpp">crbegin<span class="op">()</span></code> and <code class="sourceCode cpp">crend<span class="op">()</span></code>) to all the standard library containers, facilitating this code:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> it <span class="op">=</span> v<span class="op">.</span>cbegin<span class="op">()</span>, end <span class="op">=</span> v<span class="op">.</span>cend<span class="op">()</span>; it <span class="op">!=</span> end; <span class="op">++</span>it<span class="op">)</span>  <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>    <span class="co">//use *it ...</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="op">}</span></span></code></pre></div>
<p><code class="sourceCode cpp">c<span class="op">.</span>cbegin<span class="op">()</span></code> was specified in all of these containers to perform <code class="sourceCode cpp">as_const<span class="op">(</span>c<span class="op">).</span>begin<span class="op">()</span></code>. Although <code class="sourceCode cpp">std<span class="op">::</span>as_const</code> itself was not added until much later - it is a C++17 feature, first proposed in <span class="citation" data-cites="N4380">[<a href="#ref-N4380" role="doc-biblioref">N4380</a>]</span>.</p>
<h2 data-number="2.3" id="act-ii-rise-of-non-member-cbegin"><span class="header-section-number">2.3</span> Act II: Rise of Non-Member <code class="sourceCode cpp">cbegin</code><a href="#act-ii-rise-of-non-member-cbegin" class="self-link"></a></h2>
<p>C++11 thus added the free functions <code class="sourceCode cpp">std<span class="op">::</span>begin</code> and <code class="sourceCode cpp">std<span class="op">::</span>end</code>, and member functions <code class="sourceCode cpp">c<span class="op">.</span>cbegin<span class="op">()</span></code> and <code class="sourceCode cpp">c<span class="op">.</span>cend<span class="op">()</span></code>. But it did not yet have free functions to fetch constant iterators: those were added in 2013 by way of <span class="citation" data-cites="LWG2128">[<a href="#ref-LWG2128" role="doc-biblioref">LWG2128</a>]</span>.</p>
<p>While, <code class="sourceCode cpp">std<span class="op">::</span>begin<span class="op">(</span>c<span class="op">)</span></code> always calls <code class="sourceCode cpp">c<span class="op">.</span>begin<span class="op">()</span></code> (except for C arrays), <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>c<span class="op">)</span></code> was not specified to call <code class="sourceCode cpp">c<span class="op">.</span>cbegin<span class="op">()</span></code>. Instead it, too, called <code class="sourceCode cpp">std<span class="op">::</span>begin<span class="op">(</span>c<span class="op">)</span></code> (not even <code class="sourceCode cpp">c<span class="op">.</span>begin<span class="op">()</span></code>):</p>
<div class="quote">
<p>Implement <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code>/<code class="sourceCode cpp">cend<span class="op">()</span></code> by calling <code class="sourceCode cpp">std<span class="op">::</span>begin</code>/<code class="sourceCode cpp">end<span class="op">()</span></code>. This has numerous advantages:</p>
<ol type="1">
<li>It automatically works with arrays, which is the whole point of these non-member functions.</li>
<li>It works with C++98/03-era user containers, written before <code class="sourceCode cpp">cbegin</code>/<code class="sourceCode cpp">cend<span class="op">()</span></code> members were invented.</li>
<li>It works with <code class="sourceCode cpp">initializer_list</code>, which is extremely minimal and lacks <code class="sourceCode cpp">cbegin</code>/<code class="sourceCode cpp">cend<span class="op">()</span></code> members.</li>
<li>22.2.1 [container.requirements.general] guarantees that this is equivalent to calling <code class="sourceCode cpp">cbegin</code>/<code class="sourceCode cpp">cend<span class="op">()</span></code> members.</li>
</ol>
</div>
<p>There are two important goals here to highlight.</p>
<p>First, the goal is still to provide constant iterators, not just call <code class="sourceCode cpp">begin<span class="op">()</span> <span class="kw">const</span></code>. The latter is an implementation strategy for the former.</p>
<p>Second, the goal is to avoid boilerplate. An implementation where <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>c<span class="op">)</span></code> called <code class="sourceCode cpp">c<span class="op">.</span>cbegin<span class="op">()</span></code> would require <code class="sourceCode cpp">c<span class="op">.</span>cbegin<span class="op">()</span></code> to exist, which, as is clear from the list above, is not the case for a lot of useful types.</p>
<p>As a result, <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>c<span class="op">)</span></code> is basically specified to be <code class="sourceCode cpp">std<span class="op">::</span>begin<span class="op">(</span>as_const<span class="op">(</span>c<span class="op">))</span></code> (although, again, predating <code class="sourceCode cpp">std<span class="op">::</span>as_const</code>) which is basically <code class="sourceCode cpp">as_const<span class="op">(</span>c<span class="op">).</span>begin<span class="op">()</span></code>.</p>
<p>The status quo at this point is that <code class="sourceCode cpp">c<span class="op">.</span>cbegin<span class="op">()</span></code>, <code class="sourceCode cpp">as_const<span class="op">(</span>c<span class="op">).</span>begin<span class="op">()</span></code>, and <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>c<span class="op">)</span></code> are all equivalent (where they are all valid) and all yield constant iterators.</p>
<h2 data-number="2.4" id="act-iii-climax-of-the-views"><span class="header-section-number">2.4</span> Act III: Climax of the Views<a href="#act-iii-climax-of-the-views" class="self-link"></a></h2>
<p>Before 2018, the standard library had two non-owning range types: <code class="sourceCode cpp">std<span class="op">::</span>initializer_list<span class="op">&lt;</span>T<span class="op">&gt;</span></code> (since C++11) and <code class="sourceCode cpp">std<span class="op">::</span>string_view</code> (since C++17). Non-owning ranges are shallow-<code class="sourceCode cpp"><span class="kw">const</span></code>, but both of these types are <em>always</em>-<code class="sourceCode cpp"><span class="kw">const</span></code> so that distinction was insignificant.</p>
<p>That soon changed. 2018 opened with the addition of <code class="sourceCode cpp">std<span class="op">::</span>span</code> <span class="citation" data-cites="P0122R7">[<a href="#ref-P0122R7" role="doc-biblioref">P0122R7</a>]</span> and closed with the adoption of Ranges <span class="citation" data-cites="P0896R4">[<a href="#ref-P0896R4" role="doc-biblioref">P0896R4</a>]</span>, with a few more views added the subsequent year by way of <span class="citation" data-cites="P1035R7">[<a href="#ref-P1035R7" role="doc-biblioref">P1035R7</a>]</span>. Now, for the first time, the C++ standard library had non-owning ranges that were nevertheless mutable. Ranges itself was but a small part of the range-v3 library, so there is a promise of many more views to come.</p>
<p>These types really throw a wrench in the <code class="sourceCode cpp">cbegin</code> design: because now <code class="sourceCode cpp">begin<span class="op">()</span> <span class="kw">const</span></code> does not necessarily yield a constant iterator, whereas this had previously always been the case.</p>
<p>It’s important to note that while it had previously always been the case <em>in the standard library</em>, that is not true for the broad C++ community. In particular, Boost.Range (which begat range-v3 which begat C++20 Ranges) has for a very long time had a type named <code class="sourceCode cpp">boost<span class="op">::</span>iterator_range<span class="op">&lt;</span>It<span class="op">&gt;</span></code> (the predecessor to <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>subrange<span class="op">&lt;</span>It<span class="op">&gt;</span></code>). This is a view, although that term hadn’t existed yet, and so it had a <code class="sourceCode cpp">begin<span class="op">()</span> <span class="kw">const</span></code> member function that just returned an <code class="sourceCode cpp">It</code>. Which means that <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> on an <code class="sourceCode cpp">iterator_range<span class="op">&lt;</span><span class="dt">int</span><span class="op">*&gt;</span></code> gives you an <code class="sourceCode cpp"><span class="dt">int</span><span class="op">*</span></code> - a mutable iterator.</p>
<p>Where this discrepancy became most apparently visible was the specification of <code class="sourceCode cpp">std<span class="op">::</span>span</code> during the ballot resolution (by way of <span class="citation" data-cites="LWG3320">[<a href="#ref-LWG3320" role="doc-biblioref">LWG3320</a>]</span>). For the sake of simplicity, I am going to assume that the iterator types of <code class="sourceCode cpp">span<span class="op">&lt;</span>T<span class="op">&gt;</span></code> and <code class="sourceCode cpp">span<span class="op">&lt;</span>T <span class="kw">const</span><span class="op">&gt;</span></code> are just <code class="sourceCode cpp">T<span class="op">*</span></code> and <code class="sourceCode cpp">T <span class="kw">const</span><span class="op">*</span></code>, respectively.</p>
<ul>
<li><code class="sourceCode cpp">span<span class="op">&lt;</span>T<span class="op">&gt;::</span>begin<span class="op">()</span> <span class="kw">const</span></code>, like all the other views, is shallow <code class="sourceCode cpp"><span class="kw">const</span></code>, and so returns <code class="sourceCode cpp">T<span class="op">*</span></code>.</li>
<li><code class="sourceCode cpp">span<span class="op">&lt;</span>T<span class="op">&gt;::</span>cbegin<span class="op">()</span> <span class="kw">const</span></code>, like the other standard library containers, was provided for convenient access to a constant iterator. This returned <code class="sourceCode cpp">T <span class="kw">const</span><span class="op">*</span></code>. Unlike the other standard library containers, this did not simply defer to <code class="sourceCode cpp">begin<span class="op">()</span> <span class="kw">const</span></code>.</li>
</ul>
<p>So far so good. But because <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>s<span class="op">)</span></code> is specified to do <code class="sourceCode cpp">std<span class="op">::</span>begin<span class="op">(</span>as_const<span class="op">(</span>s<span class="op">))</span></code>, we end up having different behavior between <code class="sourceCode cpp">s<span class="op">.</span>cbegin<span class="op">()</span></code> and <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>s<span class="op">)</span></code>. This is the first (and, thus far, only) type in the standard library for which this is the case - and while <code class="sourceCode cpp">s<span class="op">.</span>cbegin<span class="op">()</span></code> would have yielded a constant iterator, <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>s<span class="op">)</span></code> does not.</p>
<p>As a result of NB comment resolution, to ship a coherent C++20, <code class="sourceCode cpp">span</code>’s <code class="sourceCode cpp">cbegin<span class="op">()</span></code> and <code class="sourceCode cpp">cend<span class="op">()</span></code> members were removed, for consistency.</p>
<h2 data-number="2.5" id="intermezzo-examining-the-c20-status-quo"><span class="header-section-number">2.5</span> Intermezzo: Examining the C++20 Status Quo<a href="#intermezzo-examining-the-c20-status-quo" class="self-link"></a></h2>
<p>This leaves us in a state where:</p>
<ul>
<li><p>for all the standard library containers, <code class="sourceCode cpp">r<span class="op">.</span>cbegin<span class="op">()</span></code> and <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>r<span class="op">)</span></code> are equivalent, both meaning <code class="sourceCode cpp">as_const<span class="op">(</span>r<span class="op">).</span>begin<span class="op">()</span></code>, and both yielding a constant iterator. This is likely true for many containers defined outside of the standard library as well.</p></li>
<li><p>for most of the standard library views, <code class="sourceCode cpp">r<span class="op">.</span>cbegin<span class="op">()</span></code> does not exist and <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>r<span class="op">)</span></code> is a valid expression that could yield a mutable iterator (e.g. <code class="sourceCode cpp">std<span class="op">::</span>span<span class="op">&lt;</span>T<span class="op">&gt;</span></code>). There are three different kinds of exceptions:</p>
<ol type="1">
<li><code class="sourceCode cpp">std<span class="op">::</span>string_view<span class="op">::</span>cbegin<span class="op">()</span></code> exists and is a constant iterator (since it is <code class="sourceCode cpp"><span class="kw">const</span></code>-only). <code class="sourceCode cpp">std<span class="op">::</span>initializer_list<span class="op">&lt;</span>T<span class="op">&gt;::</span>cbegin<span class="op">()</span></code> does <em>not</em> exist, but <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>il<span class="op">)</span></code> also yields a constant iterator.</li>
<li><code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>single_view<span class="op">&lt;</span>T<span class="op">&gt;</span></code> is an owning view and is actually thus deep <code class="sourceCode cpp"><span class="kw">const</span></code>. While it does not have a <code class="sourceCode cpp">cbegin<span class="op">()</span></code> member function, <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>v<span class="op">)</span></code> nevertheless yields a constant iterator (the proposed <code class="sourceCode cpp">views<span class="op">::</span>maybe</code> in <span class="citation" data-cites="P1255R6">[<a href="#ref-P1255R6" role="doc-biblioref">P1255R6</a>]</span> would also fit into this category).</li>
<li><code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>filter_view<span class="op">&lt;</span>V, F<span class="op">&gt;</span></code> is not actually <code class="sourceCode cpp"><span class="kw">const</span></code>-iterable at all, so it is neither the case that <code class="sourceCode cpp">filt<span class="op">.</span>cbegin<span class="op">()</span></code> exists as a member function nor that <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>filt<span class="op">)</span></code> (nor <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin<span class="op">(</span>filt<span class="op">)</span></code>) is well-formed. Many other views fit this category as well (<code class="sourceCode cpp">drop_view</code> being the most obvious, but <code class="sourceCode cpp">drop</code>, <code class="sourceCode cpp">reverse</code>, and <code class="sourceCode cpp">join</code> may not be either, etc.). Other future views may fit into this category as well (e.g. my proposed improvement to <code class="sourceCode cpp">views<span class="op">::</span>split</code> in <span class="citation" data-cites="P2210R0">[<a href="#ref-P2210R0" role="doc-biblioref">P2210R0</a>]</span>).</li>
</ol></li>
</ul>
<p>Put differently, the C++20 status quo is that <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> on an owning range always provides a constant iterator while <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> on a non-owning view could provide a mutable iterator or not compile at all.</p>
<p>The original desire of Walter’s paper from more than 15 years ago (which, in 2020 terms, may as well have happened at the last Jupiter/Saturn conjunction) still holds today:</p>
<div class="quote">
<p>However, when a container traversal is intended for inspection only, it is a generally preferred practice to use a <code class="sourceCode cpp">const_iterator</code> in order to permit the compiler to diagnose <code class="sourceCode cpp"><span class="kw">const</span></code>-correctness violations</p>
</div>
<p>How could we add <code class="sourceCode cpp"><span class="kw">const</span></code>-correctness to views?</p>
<h2 data-number="2.6" id="a-non-solution-member-cbegin"><span class="header-section-number">2.6</span> A Non-Solution: Member <code class="sourceCode cpp">cbegin<span class="op">()</span></code><a href="#a-non-solution-member-cbegin" class="self-link"></a></h2>
<p>One approach we could take to provide reliable <code class="sourceCode cpp"><span class="kw">const</span></code>-traversal of unknown ranges is to push the problem onto the ranges:</p>
<ol type="1">
<li>We could say that <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>c<span class="op">)</span></code> (and <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin<span class="op">(</span>c<span class="op">)</span></code> as well) first tries to call <code class="sourceCode cpp">c<span class="op">.</span>cbegin<span class="op">()</span></code> if that exists and only if it doesn’t to fall-back to its present behavior of <code class="sourceCode cpp">std<span class="op">::</span>begin<span class="op">(</span>as_const<span class="op">(</span>c<span class="op">))</span></code>.</li>
<li>We could then pair such a change with going through the standard library and ensuring that all views have a member <code class="sourceCode cpp">cbegin<span class="op">()</span> <span class="kw">const</span></code> that yields a constant iterator. Even the ones like <code class="sourceCode cpp">std<span class="op">::</span>initializer_list<span class="op">&lt;</span>T<span class="op">&gt;</span></code> that don’t currently have such a member?</li>
</ol>
<p>Such a design would ensure that for all standard library ranges, <code class="sourceCode cpp">r<span class="op">.</span>cbegin<span class="op">()</span></code> and <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>r<span class="op">)</span></code> are equivalent and yield a constant iterator. Except for <code class="sourceCode cpp">filter_view</code>, for which <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>filt<span class="op">)</span></code> would continue to not compile as it takes a <code class="sourceCode cpp">C <span class="kw">const</span><span class="op">&amp;</span></code>.</p>
<p>What does this do for all the views outside of the standard library? It does nothing. <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>v<span class="op">)</span></code> on such views would continue to yield a mutable iterator, as it does today with <code class="sourceCode cpp">boost<span class="op">::</span>iterator_range</code>. That, in of itself, makes this change somewhat unsatisfactory.</p>
<p>But what would it actually mean to add a member <code class="sourceCode cpp">cbegin<span class="op">()</span> <span class="kw">const</span></code> to every view type? What would such a member function do? What it <em>should</em> do is the exact same thing for every view — the same exact same thing that all views external to the standard library would have to do in order to opt in to <code class="sourceCode cpp"><span class="kw">const</span></code>-traversal-on-demand.</p>
<p>But if every type needs to do the same thing, that’s an algorithm. The standard library should provide it once rather than having every view re-implement it. Or, more likely, have every view delegate to the algorithm and just have boilerplate member function implementations. A substantial amount of view implementations are already boilerplate, we do not need more.</p>
<h1 data-number="3" style="border-bottom:1px solid #cccccc" id="act-iv-stdconst_iterator"><span class="header-section-number">3</span> Act IV: <code class="sourceCode cpp">std<span class="op">::</span>const_iterator</code><a href="#act-iv-stdconst_iterator" class="self-link"></a></h1>
<p>The problem we actually have is this: given an iterator, how do I create an iterator that is identical in all respects except for top-level mutability? This is, ultimately, the problem that from the very beginning <code class="sourceCode cpp">vector<span class="op">&lt;</span>T<span class="op">&gt;::</span>const_iterator</code> is intending to solve. It is a <code class="sourceCode cpp">vector<span class="op">&lt;</span>T<span class="op">&gt;::</span>iterator</code> in all respects (it’s contiguous, its value type is <code class="sourceCode cpp">T</code>, it would have the same bounds coming from the same container) except that dereferencing such an iterator would give a <code class="sourceCode cpp">T <span class="kw">const</span><span class="op">&amp;</span></code> instead of a <code class="sourceCode cpp">T<span class="op">&amp;</span></code>.</p>
<h2 data-number="3.1" id="a-reverse-digression"><span class="header-section-number">3.1</span> A Reverse Digression<a href="#a-reverse-digression" class="self-link"></a></h2>
<p>We’re already used to the fact that some iterators are generic wrappers over other iterators. <code class="sourceCode cpp">vector<span class="op">&lt;</span>T<span class="op">&gt;</span></code> is already specified as:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">namespace</span> std <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="kw">class</span> Allocator <span class="op">=</span> allocator<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>  <span class="kw">class</span> vector <span class="op">{</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>    <span class="co">// types</span></span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a>    <span class="kw">using</span> iterator               <span class="op">=</span> <em>implementation-defined</em>; <span class="co">// see [container.requirements]</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>    <span class="kw">using</span> const_iterator         <span class="op">=</span> <em>implementation-defined</em>; <span class="co">// see [container.requirements]</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>    <span class="kw">using</span> reverse_iterator       <span class="op">=</span> std<span class="op">::</span>reverse_iterator<span class="op">&lt;</span>iterator<span class="op">&gt;</span>;</span>
<span id="cb2-10"><a href="#cb2-10"></a>    <span class="kw">using</span> const_reverse_iterator <span class="op">=</span> std<span class="op">::</span>reverse_iterator<span class="op">&lt;</span>const_iterator<span class="op">&gt;</span>;</span></code></pre></div>
<p>Nobody is especially surprised by the fact that every container isn’t manually implementing its own bespoke reverse iterators. <code class="sourceCode cpp">std<span class="op">::</span>reverse_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span></code> does the job. Yet, <code class="sourceCode cpp">std<span class="op">::</span>rbegin<span class="op">(</span>c<span class="op">)</span></code> always calls <code class="sourceCode cpp">c<span class="op">.</span>rbegin<span class="op">()</span></code> (except for arrays). Even though we’ve had this perfectly generic solution for a long time, if you wanted your container to support reverse-iteration, you just had to write these boilerplate <code class="sourceCode cpp">rbegin<span class="op">()</span></code>/<code class="sourceCode cpp">rend<span class="op">()</span></code> member functions that wrapped your iterators.</p>
<p>Ranges improved this situation. <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>rbegin<span class="op">(</span>E<span class="op">)</span></code> is a much more complicated algorithm that takes many steps (see <span>24.3.6 <a href="https://wg21.link/range.access.rbegin">[range.access.rbegin]</a></span> for complete description), but a key aspect of the design there is that if <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>begin<span class="op">(</span>E<span class="op">)</span></code> and <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>end<span class="op">(</span>E<span class="op">)</span></code> give you <code class="sourceCode cpp">bidirectional_iterator</code>s, then <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>rbegin<span class="op">(</span>E<span class="op">)</span></code> itself does the wrapping and provides you <code class="sourceCode cpp">make_reverse_iterator<span class="op">(</span>ranges​<span class="op">::</span>​end<span class="op">(</span>E<span class="op">))</span></code>. No more pushing work onto the containers. That means that it works even in this case:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">struct</span> simple_span <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>    <span class="dt">int</span><span class="op">*</span> begin<span class="op">()</span> <span class="kw">const</span>;</span>
<span id="cb3-3"><a href="#cb3-3"></a>    <span class="dt">int</span><span class="op">*</span> end<span class="op">()</span> <span class="kw">const</span>;</span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="op">}</span>;</span>
<span id="cb3-5"><a href="#cb3-5"></a></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="dt">void</span> algo<span class="op">(</span>simple_span ss<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>    <span class="kw">auto</span> rit <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>rbegin<span class="op">(</span>ss<span class="op">)</span>; <span class="co">// ok</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>    <span class="kw">auto</span> rend <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>rend<span class="op">(</span>ss<span class="op">)</span>;  <span class="co">// ok</span></span>
<span id="cb3-9"><a href="#cb3-9"></a>    <span class="co">// ...</span></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="op">}</span></span></code></pre></div>
<p><code class="sourceCode cpp">std<span class="op">::</span>rbegin</code> would’ve failed in this case, because we don’t have the boilerplate necessary to make it work. But instead of pushing that boilerplate onto <code class="sourceCode cpp">simple_span</code>, we consigned it into <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>rbegin</code>. A much better solution.</p>
<h2 data-number="3.2" id="const-is-no-different"><span class="header-section-number">3.2</span> Const Is No Different<a href="#const-is-no-different" class="self-link"></a></h2>
<p>A generic <code class="sourceCode cpp">reverse_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span></code> is not that complicated. We’re basically inverting operations. But the crux of the iterator remains the same: <code class="sourceCode cpp"><span class="op">*</span>it</code> passes through to its underlying iterator.</p>
<p>A generic <code class="sourceCode cpp">const_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span></code> at first seems much less complicated. <em>Every</em> operation is passthrough, except for one. We are <em>only</em> modifying the behavior of the dereference operator. Yet, doing the right thing for dereference is decidedly non-trivial. Let’s go through some cases. We’re going to look at both the value type and reference type of several ranges and say what we want the desired <code class="sourceCode cpp">const_iterator<span class="op">&lt;</span>iterator_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;</span></code> to dereference into:</p>
<table>
<colgroup>
<col style="width: 25%"></col>
<col style="width: 25%"></col>
<col style="width: 25%"></col>
<col style="width: 25%"></col>
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><div style="text-align:center">
<strong><code class="sourceCode cpp">range_value_t<span class="op">&lt;</span>R<span class="op">&gt;</span></code></strong>
</div></th>
<th><div style="text-align:center">
<strong><code class="sourceCode cpp">range_reference_t<span class="op">&lt;</span>R<span class="op">&gt;</span></code></strong>
</div></th>
<th><div style="text-align:center">
<strong>desired result type</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span><span class="op">&amp;</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span> <span class="kw">const</span><span class="op">&amp;</span></code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="kw">const</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span> <span class="kw">const</span><span class="op">&amp;</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span> <span class="kw">const</span><span class="op">&amp;</span></code></td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp">array<span class="op">&lt;</span><span class="dt">int</span> <span class="kw">const</span>, N<span class="op">&gt;</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span> <span class="kw">const</span><span class="op">&amp;</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span> <span class="kw">const</span><span class="op">&amp;</span></code></td>
</tr>
<tr class="even">
<td>a range of prvalue <code class="sourceCode cpp"><span class="dt">int</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span></code></td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;</span> <span class="kw">const</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">bool</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">bool</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">bool</span></code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">bool</span></code></td>
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;::</span>reference</code></td>
<td><code class="sourceCode cpp"><span class="dt">bool</span></code></td>
</tr>
<tr class="odd">
<td>zipping a <code class="sourceCode cpp">vector<span class="op">&lt;</span>T<span class="op">&gt;</span></code> and <code class="sourceCode cpp">vector<span class="op">&lt;</span>U<span class="op">&gt;</span></code></td>
<td><code class="sourceCode cpp">tuple<span class="op">&lt;</span>T, U<span class="op">&gt;</span></code></td>
<td><code class="sourceCode cpp">tuple<span class="op">&lt;</span>T<span class="op">&amp;</span>, U<span class="op">&amp;&gt;</span></code></td>
<td><code class="sourceCode cpp">tuple<span class="op">&lt;</span>T <span class="kw">const</span><span class="op">&amp;</span>, U <span class="kw">const</span><span class="op">&amp;&gt;</span></code></td>
</tr>
</tbody>
</table>
<p>This table points out a few things:</p>
<ul>
<li>A first thought might be that we need to return a <code class="sourceCode cpp">range_value_t<span class="op">&lt;</span>R<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span></code>, but while that works in some cases, it would lead to every element dangling in other cases.</li>
<li>Sometimes, <code class="sourceCode cpp">It</code> is already a constant iterator, so we would want to actively avoid wrapping in such a case.</li>
<li>The last couple rows are hard.</li>
</ul>
<p>Thankfully, this is a solved problem. The <code class="sourceCode cpp">views<span class="op">::</span>const_</code> adapter <a href="https://github.com/ericniebler/range-v3/blob/d098b9610ac2f182f667ae9274ac2fac7f1327f5/include/range/v3/view/const.hpp">in range-v3</a> has for many years used a formula that works for all of these cases. In C++20 Ranges terms, I would spell it this way:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>input_iterator It<span class="op">&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="kw">using</span> const_ref_for <span class="op">=</span> std<span class="op">::</span>common_reference_t<span class="op">&lt;</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>    std<span class="op">::</span>iter_value_t<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;&amp;</span>,</span>
<span id="cb4-4"><a href="#cb4-4"></a>    std<span class="op">::</span>iter_reference_t<span class="op">&lt;</span>It<span class="op">&gt;&gt;</span>;</span></code></pre></div>
<p>This does not yield the correct result for the last row in my table at the moment, but now that we are making the changes to <code class="sourceCode cpp">std<span class="op">::</span>tuple</code> prescribed in <span class="citation" data-cites="P2321R2">[<a href="#ref-P2321R2" role="doc-biblioref">P2321R2</a>]</span>, it soon will.</p>
<p>Avoiding unnecessary wrapping can be achieved through a factory function that checks to see if such wrapping would change type:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="co">// a type is a constant iterator if its an iterator whose reference type is</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="co">// the same as the type that const_ref_for would pick for it</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> It<span class="op">&gt;</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="kw">concept</span> <em>constant-iterator</em> <span class="op">=</span> std<span class="op">::</span>input_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>                         <span class="op">&amp;&amp;</span> std<span class="op">::</span>same_as<span class="op">&lt;</span>const_ref_for<span class="op">&lt;</span>It<span class="op">&gt;</span>, std<span class="op">::</span>iter_reference_t<span class="op">&lt;</span>It<span class="op">&gt;&gt;</span>;</span>
<span id="cb5-6"><a href="#cb5-6"></a></span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="co">// a type is a constant range if it is a range whose iterator is a constant iterator</span></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> R<span class="op">&gt;</span></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="kw">concept</span> <em>constant-range</em> <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>range<span class="op">&lt;</span>R<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> <em>constant-iterator</em><span class="op">&lt;</span>std<span class="op">::</span>ranges<span class="op">::</span>iterator_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;</span>;</span>
<span id="cb5-10"><a href="#cb5-10"></a></span>
<span id="cb5-11"><a href="#cb5-11"></a><span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>input_iterator It<span class="op">&gt;</span></span>
<span id="cb5-12"><a href="#cb5-12"></a><span class="kw">constexpr</span> <span class="kw">auto</span> make_const_iterator<span class="op">(</span>It it<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-13"><a href="#cb5-13"></a>    <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span><em>constant-iterator</em><span class="op">&lt;</span>It<span class="op">&gt;)</span> <span class="op">{</span></span>
<span id="cb5-14"><a href="#cb5-14"></a>        <span class="co">// already a constant iterator</span></span>
<span id="cb5-15"><a href="#cb5-15"></a>        <span class="cf">return</span> it;</span>
<span id="cb5-16"><a href="#cb5-16"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb5-17"><a href="#cb5-17"></a>        <span class="cf">return</span> basic_const_iterator<span class="op">&lt;</span>It<span class="op">&gt;(</span>it<span class="op">)</span>;</span>
<span id="cb5-18"><a href="#cb5-18"></a>    <span class="op">}</span></span>
<span id="cb5-19"><a href="#cb5-19"></a><span class="op">}</span></span>
<span id="cb5-20"><a href="#cb5-20"></a></span>
<span id="cb5-21"><a href="#cb5-21"></a><span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>input_iterator It<span class="op">&gt;</span></span>
<span id="cb5-22"><a href="#cb5-22"></a><span class="kw">using</span> const_iterator <span class="op">=</span> <span class="kw">decltype</span><span class="op">(</span>make_const_iterator<span class="op">(</span>std<span class="op">::</span>declval<span class="op">&lt;</span>It<span class="op">&gt;()))</span>;</span></code></pre></div>
<p>Unfortunately we have a lot of names here:</p>
<ul>
<li><code class="sourceCode cpp">const_iterator<span class="op">&lt;</span>I<span class="op">&gt;</span></code> is an alias template that gives you a constant iterator version of <code class="sourceCode cpp">I</code>. If <code class="sourceCode cpp">I</code> is already a constant iterator, then <code class="sourceCode cpp">const_iterator<span class="op">&lt;</span>I<span class="op">&gt;</span></code> is <code class="sourceCode cpp">I</code>.</li>
<li><code class="sourceCode cpp">make_const_iterator<span class="op">&lt;</span>I<span class="op">&gt;(</span>i<span class="op">)</span></code> is a factory function template that takes an input iterator and produces a <code class="sourceCode cpp">const_iterator<span class="op">&lt;</span>I<span class="op">&gt;</span></code>. Likewise, if <code class="sourceCode cpp">I</code> is already a constant iterator, then this function returns <code class="sourceCode cpp">i</code>.</li>
<li><code class="sourceCode cpp">basic_const_iterator<span class="op">&lt;</span>I<span class="op">&gt;</span></code> is an implementation detail of the library to satisfy the requirements of the above to ensure that we get a constant iterator.</li>
</ul>
<p>It’s important to have <code class="sourceCode cpp">const_iterator<span class="op">&lt;</span><span class="dt">int</span> <span class="kw">const</span><span class="op">*&gt;</span></code> produce the type <code class="sourceCode cpp"><span class="dt">int</span> <span class="kw">const</span><span class="op">*</span></code>. If we just had a single class template <code class="sourceCode cpp">const_iterator</code> (that itself was the implementation for a constant iterator), then it could lead to subtle misuse:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="kw">struct</span> span <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>    <span class="kw">using</span> iterator <span class="op">=</span> <span class="co">/* ... */</span>;</span>
<span id="cb6-4"><a href="#cb6-4"></a>    <span class="kw">using</span> const_iterator <span class="op">=</span> std<span class="op">::</span>const_iterator<span class="op">&lt;</span>iterator<span class="op">&gt;</span>;</span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="op">}</span>;</span></code></pre></div>
<p><code class="sourceCode cpp">span<span class="op">&lt;</span>T <span class="kw">const</span><span class="op">&gt;::</span>iterator</code> is already a constant iterator, it doesn’t need to be wrapped further. So <code class="sourceCode cpp">span<span class="op">&lt;</span>T <span class="kw">const</span><span class="op">&gt;::</span>const_iterator</code> should really be the same type. It would be nice if the above were already just correct. Hence, the extra names. Users probably never need to use <code class="sourceCode cpp">std<span class="op">::</span>basic_const_iterator<span class="op">&lt;</span>I<span class="op">&gt;</span></code> directly (or, indeed, even <code class="sourceCode cpp">make_const_iterator</code>).</p>
<h2 data-number="3.3" id="implementing-stdbasic_const_iteratori"><span class="header-section-number">3.3</span> Implementing <code class="sourceCode cpp">std<span class="op">::</span>basic_const_iterator<span class="op">&lt;</span>I<span class="op">&gt;</span></code><a href="#implementing-stdbasic_const_iteratori" class="self-link"></a></h2>
<p>There’s a lot of boilerplate in implementing a C++20 iterator. And especially for <code class="sourceCode cpp">basic_const_iterator<span class="op">&lt;</span>I<span class="op">&gt;</span></code> where just about every operation is simply a pass-through to the underlying iterator. Only one function ends up having a body consisting of more than a single <code class="sourceCode cpp"><span class="cf">return</span></code> statement.</p>
<p>Despite that, there’s one especially important aspect to implementing a <code class="sourceCode cpp">basic_const_iterator<span class="op">&lt;</span>I<span class="op">&gt;</span></code> that adds complexity: conversions and comparisons. We have this expectation that a range’s mutable iterator is convertible to its constant iterator. That is, given any type <code class="sourceCode cpp">R</code> such <code class="sourceCode cpp">range<span class="op">&lt;</span>R<span class="op">&gt;</span></code> and <code class="sourceCode cpp">range<span class="op">&lt;</span>R <span class="kw">const</span><span class="op">&gt;</span></code> both hold, that <code class="sourceCode cpp">iterator_t<span class="op">&lt;</span>R<span class="op">&gt;</span></code> is convertible to <code class="sourceCode cpp">iterator_t<span class="op">&lt;</span>R <span class="kw">const</span><span class="op">&gt;</span></code>. For example, we expect <code class="sourceCode cpp">vector<span class="op">&lt;</span>T<span class="op">&gt;::</span>iterator</code> to be convertible to <code class="sourceCode cpp">vector<span class="op">&lt;</span>T<span class="op">&gt;::</span>const_iterator</code>, and likewise for any other container or view.</p>
<p>Adding the concept of a <code class="sourceCode cpp">const_iterator</code> further complicates matters because now we have the following cross-convertibility and cross-comparability graph:</p>
<p><img src="data:image/png;base64,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" title="iterator/const_iterator conversions and comparisons" alt="iterator/const_iterator conversions and comparisons" /></p>
<p>A black arrow from <code class="sourceCode cpp">T</code> to <code class="sourceCode cpp">U</code> indicates that <code class="sourceCode cpp">T</code> needs to be convertible to <code class="sourceCode cpp">U</code>, while the blue bidirectional dotted arrows between <code class="sourceCode cpp">T</code> and <code class="sourceCode cpp">U</code> indicate that <code class="sourceCode cpp">equality_comparable_with<span class="op">&lt;</span>T, U<span class="op">&gt;</span></code> holds (i.e. not only that the types can be compared with <code class="sourceCode cpp"><span class="op">==</span></code> and <code class="sourceCode cpp"><span class="op">!=</span></code> but also that there is a common type between them). That is, every pair of types here needs to model <code class="sourceCode cpp">equality_comparable_with</code>.</p>
<p>Even though <code class="sourceCode cpp">iterator_t<span class="op">&lt;</span>R <span class="kw">const</span><span class="op">&gt;</span></code> and <code class="sourceCode cpp">const_iterator<span class="op">&lt;</span>iterator_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;</span></code> are not convertible to each other, they still have a common type that both are convertible to (<code class="sourceCode cpp">const_iterator<span class="op">&lt;</span>iterator_t<span class="op">&lt;</span>R <span class="kw">const</span><span class="op">&gt;&gt;</span></code>) which also needs to be reflected.</p>
<p>The implementation of <code class="sourceCode cpp">basic_const_iterator<span class="op">&lt;</span>I<span class="op">&gt;</span></code> needs to properly support this graph: which means ensuring the right set of constructors, comparison operators, and even specializations of <code class="sourceCode cpp">common_type</code>.</p>
<p>The same sort of idea holds for sentinels. How would we wrap sentinels? Imagine a hypothetical <code class="sourceCode cpp">const_sentinel<span class="op">&lt;</span>I, S<span class="op">&gt;</span></code>. It would have to have the following behavior:</p>
<p><img src="data:image/png;base64,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" alt /></p>
<p>Because <code class="sourceCode cpp">iterator_t<span class="op">&lt;</span>R <span class="kw">const</span><span class="op">&gt;</span></code> would be comparable to <code class="sourceCode cpp">sentinel_t<span class="op">&lt;</span>R<span class="op">&gt;</span></code>, it needs to follow that <code class="sourceCode cpp">const_iterator<span class="op">&lt;</span>iterator_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;</span></code> needs to be comparable to <code class="sourceCode cpp">sentinel_t<span class="op">&lt;</span>R<span class="op">&gt;</span></code> as well. That is, <code class="sourceCode cpp">sentinel_for<span class="op">&lt;</span>const_iterator<span class="op">&lt;</span>I<span class="op">&gt;</span>, S<span class="op">&gt;</span></code> needs to hold whenever <code class="sourceCode cpp">sentinel_for<span class="op">&lt;</span>I, S<span class="op">&gt;</span></code> holds. This begs the question of if we need a <code class="sourceCode cpp">const_sentinel<span class="op">&lt;</span>I, S<span class="op">&gt;</span></code> type at all, given that we need to support comparisons to the unwrapped sentinel anyway. It’s a complex interplay of types to get right, and it doesn’t seem like a <code class="sourceCode cpp">const_sentinel</code> type adds value for us at all. Hopefully, we don’t find a problem that necessitates wrapping in the future (c.f. <span class="citation" data-cites="LWG3386">[<a href="#ref-LWG3386" role="doc-biblioref">LWG3386</a>]</span>).</p>
<p>The tricky part of the implementation is to avoid constraint recursion in ensuring that wrapped random access iterators are totally ordered and ensuring that wrapped sized sentinels are still sized sentinels. A first attempt at attempting to define an <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">&lt;=&gt;</span></code> for <code class="sourceCode cpp">basic_const_iterator<span class="op">&lt;</span>I<span class="op">&gt;</span></code> might start with:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>input_iterator It<span class="op">&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="kw">struct</span> basic_const_iterator <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>    <span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>totally_ordered_with<span class="op">&lt;</span>It<span class="op">&gt;</span> Rhs<span class="op">&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>        <span class="kw">requires</span> std<span class="op">::</span>random_access_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">&lt;=&gt;(</span>Rhs <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">const</span>;</span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="op">}</span>;</span></code></pre></div>
<p>But when checking to see if <code class="sourceCode cpp">totally_ordered<span class="op">&lt;</span>basic_const_iterator<span class="op">&lt;</span><span class="dt">int</span><span class="op">*&gt;&gt;</span></code>, we would check to see if we can instantiate <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">&lt;=&gt;</span></code>, which requires checking if <code class="sourceCode cpp">totally_ordered_with<span class="op">&lt;</span>basic_const_iterator<span class="op">&lt;</span><span class="dt">int</span><span class="op">*&gt;</span>, basic_const_iterator<span class="op">&lt;</span><span class="dt">int</span><span class="op">*&gt;&gt;</span></code> (since <code class="sourceCode cpp">Rhs</code> is our same type), which itself requires checking <code class="sourceCode cpp">totally_ordered<span class="op">&lt;</span>basic_const_iterator<span class="op">&lt;</span><span class="dt">int</span><span class="op">*&gt;&gt;</span></code>. And now we’ve completed the cycle.</p>
<p>The way I chose to handle this problem is to split the implementation into two functions: a same-type, non-template comparison and a template that is constrained on different types:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>input_iterator It<span class="op">&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="kw">struct</span> basic_const_iterator <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">&lt;=&gt;(</span>basic_const_iterator <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">const</span></span>
<span id="cb8-4"><a href="#cb8-4"></a>        <span class="kw">requires</span> std<span class="op">::</span>random_access_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span>;</span>
<span id="cb8-5"><a href="#cb8-5"></a></span>
<span id="cb8-6"><a href="#cb8-6"></a>    <span class="kw">template</span> <span class="op">&lt;</span><em>not-same-as</em><span class="op">&lt;</span>basic_const_iterator<span class="op">&gt;</span> Rhs<span class="op">&gt;</span></span>
<span id="cb8-7"><a href="#cb8-7"></a>        <span class="kw">requires</span> std<span class="op">::</span>random_access_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span></span>
<span id="cb8-8"><a href="#cb8-8"></a>             <span class="kw">and</span> std<span class="op">::</span>totally_ordered_with<span class="op">&lt;</span>It, Rhs<span class="op">&gt;</span></span>
<span id="cb8-9"><a href="#cb8-9"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">&lt;=&gt;(</span>Rhs <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">const</span>;</span>
<span id="cb8-10"><a href="#cb8-10"></a><span class="op">}</span>;</span></code></pre></div>
<p>Other things to note about this implementation:</p>
<ol type="1">
<li>Providing <code class="sourceCode cpp">iterator_concept <span class="op">=</span> contiguous_iterator_tag;</code> ensures that wrapping a contiguous mutable iterator produces a contiguous constant iterator.</li>
<li>Only providing <code class="sourceCode cpp">iterator_category</code> for <code class="sourceCode cpp">forward_iterator</code>s ensures that we correctly handle C++20 input iterators (more on this later, and see also <span class="citation" data-cites="P2259R0">[<a href="#ref-P2259R0" role="doc-biblioref">P2259R0</a>]</span>).</li>
<li>The spelling of the <code class="sourceCode cpp">reference</code> type for this iterator, described earlier.</li>
</ol>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> It<span class="op">&gt;</span> <span class="kw">struct</span> iterator_concept_for <span class="op">{</span> <span class="op">}</span>;</span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> It<span class="op">&gt;</span> <span class="kw">requires</span> std<span class="op">::</span>contiguous_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="kw">struct</span> iterator_concept_for<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb9-4"><a href="#cb9-4"></a>    <span class="kw">using</span> iterator_concept <span class="op">=</span> std<span class="op">::</span>contiguous_iterator_tag;</span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="op">}</span>;</span>
<span id="cb9-6"><a href="#cb9-6"></a></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> It<span class="op">&gt;</span> <span class="kw">struct</span> iterator_category_for <span class="op">{</span> <span class="op">}</span>;</span>
<span id="cb9-8"><a href="#cb9-8"></a><span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>forward_iterator It<span class="op">&gt;</span></span>
<span id="cb9-9"><a href="#cb9-9"></a><span class="kw">struct</span> iterator_category_for<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb9-10"><a href="#cb9-10"></a>    <span class="kw">using</span> iterator_category <span class="op">=</span> <span class="kw">typename</span> std<span class="op">::</span>iterator_traits<span class="op">&lt;</span>It<span class="op">&gt;::</span>iterator_category;</span>
<span id="cb9-11"><a href="#cb9-11"></a><span class="op">}</span>;</span>
<span id="cb9-12"><a href="#cb9-12"></a></span>
<span id="cb9-13"><a href="#cb9-13"></a><span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>input_iterator It<span class="op">&gt;</span></span>
<span id="cb9-14"><a href="#cb9-14"></a><span class="kw">class</span> basic_const_iterator <span class="op">:</span> <span class="kw">public</span> iterator_concept_for<span class="op">&lt;</span>It<span class="op">&gt;</span></span>
<span id="cb9-15"><a href="#cb9-15"></a>                           , <span class="kw">public</span> iterator_category_for<span class="op">&lt;</span>It<span class="op">&gt;</span></span>
<span id="cb9-16"><a href="#cb9-16"></a><span class="op">{</span></span>
<span id="cb9-17"><a href="#cb9-17"></a>    It it;</span>
<span id="cb9-18"><a href="#cb9-18"></a></span>
<span id="cb9-19"><a href="#cb9-19"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb9-20"><a href="#cb9-20"></a>    <span class="kw">using</span> value_type <span class="op">=</span> std<span class="op">::</span>iter_value_t<span class="op">&lt;</span>It<span class="op">&gt;</span>;</span>
<span id="cb9-21"><a href="#cb9-21"></a>    <span class="kw">using</span> difference_type <span class="op">=</span> std<span class="op">::</span>iter_difference_t<span class="op">&lt;</span>It<span class="op">&gt;</span>;</span>
<span id="cb9-22"><a href="#cb9-22"></a>    <span class="kw">using</span> reference <span class="op">=</span> const_ref_for<span class="op">&lt;</span>It<span class="op">&gt;</span>;</span>
<span id="cb9-23"><a href="#cb9-23"></a></span>
<span id="cb9-24"><a href="#cb9-24"></a>    basic_const_iterator<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb9-25"><a href="#cb9-25"></a>    basic_const_iterator<span class="op">(</span>It it<span class="op">)</span> <span class="op">:</span> it<span class="op">(</span>std<span class="op">::</span>move<span class="op">(</span>it<span class="op">))</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb9-26"><a href="#cb9-26"></a>    <span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>convertible_to<span class="op">&lt;</span>It<span class="op">&gt;</span> U<span class="op">&gt;</span></span>
<span id="cb9-27"><a href="#cb9-27"></a>    basic_const_iterator<span class="op">(</span>basic_const_iterator<span class="op">&lt;</span>U<span class="op">&gt;</span> c<span class="op">)</span> <span class="op">:</span> it<span class="op">(</span>std<span class="op">::</span>move<span class="op">(</span>c<span class="op">.</span>base<span class="op">()))</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb9-28"><a href="#cb9-28"></a>    basic_const_iterator<span class="op">(</span>std<span class="op">::</span>convertible_to<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="kw">auto</span><span class="op">&amp;&amp;</span> c<span class="op">)</span> <span class="op">:</span> it<span class="op">(</span>FWD<span class="op">(</span>c<span class="op">))</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb9-29"><a href="#cb9-29"></a></span>
<span id="cb9-30"><a href="#cb9-30"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">++()</span> <span class="op">-&gt;</span> basic_const_iterator<span class="op">&amp;</span> <span class="op">{</span> <span class="op">++</span>it; <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span>; <span class="op">}</span></span>
<span id="cb9-31"><a href="#cb9-31"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">++(</span><span class="dt">int</span><span class="op">)</span> <span class="op">-&gt;</span> basic_const_iterator <span class="kw">requires</span> std<span class="op">::</span>forward_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> <span class="kw">auto</span> cpy <span class="op">=</span> <span class="op">*</span><span class="kw">this</span>; <span class="op">++*</span><span class="kw">this</span>; <span class="cf">return</span> cpy; <span class="op">}</span></span>
<span id="cb9-32"><a href="#cb9-32"></a>    <span class="dt">void</span> <span class="kw">operator</span><span class="op">++(</span><span class="dt">int</span><span class="op">)</span> <span class="op">{</span> <span class="op">++*</span><span class="kw">this</span>; <span class="op">}</span></span>
<span id="cb9-33"><a href="#cb9-33"></a></span>
<span id="cb9-34"><a href="#cb9-34"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">--()</span> <span class="op">-&gt;</span> basic_const_iterator<span class="op">&amp;</span> <span class="kw">requires</span> std<span class="op">::</span>bidirectional_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> <span class="op">--</span>it; <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span>; <span class="op">}</span></span>
<span id="cb9-35"><a href="#cb9-35"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">--(</span><span class="dt">int</span><span class="op">)</span> <span class="op">-&gt;</span> basic_const_iterator <span class="kw">requires</span> std<span class="op">::</span>bidirectional_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> <span class="kw">auto</span> cpy <span class="op">=</span> <span class="op">*</span><span class="kw">this</span>; <span class="op">--*</span><span class="kw">this</span>; <span class="cf">return</span> cpy; <span class="op">}</span></span>
<span id="cb9-36"><a href="#cb9-36"></a></span>
<span id="cb9-37"><a href="#cb9-37"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">+(</span>difference_type n<span class="op">)</span> <span class="kw">const</span> <span class="op">-&gt;</span> basic_const_iterator <span class="kw">requires</span> std<span class="op">::</span>random_access_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> basic_const_iterator<span class="op">(</span>it <span class="op">+</span> n<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb9-38"><a href="#cb9-38"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">-(</span>difference_type n<span class="op">)</span> <span class="kw">const</span> <span class="op">-&gt;</span> basic_const_iterator <span class="kw">requires</span> std<span class="op">::</span>random_access_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> basic_const_iterator<span class="op">(</span>it <span class="op">-</span> n<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb9-39"><a href="#cb9-39"></a>    <span class="kw">friend</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">+(</span>difference_type n, basic_const_iterator <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="op">-&gt;</span> basic_const_iterator <span class="op">{</span> <span class="cf">return</span> rhs <span class="op">+</span> n; <span class="op">}</span></span>
<span id="cb9-40"><a href="#cb9-40"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">+=(</span>difference_type n<span class="op">)</span> <span class="op">-&gt;</span> basic_const_iterator<span class="op">&amp;</span> <span class="kw">requires</span> std<span class="op">::</span>random_access_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> it <span class="op">+=</span> n; <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span>; <span class="op">}</span></span>
<span id="cb9-41"><a href="#cb9-41"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">-=(</span>difference_type n<span class="op">)</span> <span class="op">-&gt;</span> basic_const_iterator<span class="op">&amp;</span> <span class="kw">requires</span> std<span class="op">::</span>random_access_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> it <span class="op">-=</span> n; <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span>; <span class="op">}</span></span>
<span id="cb9-42"><a href="#cb9-42"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">-(</span>basic_const_iterator <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">const</span> <span class="op">-&gt;</span> difference_type <span class="kw">requires</span> std<span class="op">::</span>random_access_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> it <span class="op">-</span> rhs<span class="op">.</span>it; <span class="op">}</span></span>
<span id="cb9-43"><a href="#cb9-43"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">[](</span>difference_type n<span class="op">)</span> <span class="kw">const</span> <span class="op">-&gt;</span> reference <span class="kw">requires</span> std<span class="op">::</span>random_access_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> it<span class="op">[</span>n<span class="op">]</span>; <span class="op">}</span></span>
<span id="cb9-44"><a href="#cb9-44"></a></span>
<span id="cb9-45"><a href="#cb9-45"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">*()</span> <span class="kw">const</span> <span class="op">-&gt;</span> reference <span class="op">{</span> <span class="cf">return</span> <span class="op">*</span>it; <span class="op">}</span></span>
<span id="cb9-46"><a href="#cb9-46"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">-&gt;()</span> <span class="kw">const</span> <span class="op">-&gt;</span> value_type <span class="kw">const</span><span class="op">*</span> <span class="kw">requires</span> std<span class="op">::</span>contiguous_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> std<span class="op">::</span>to_address<span class="op">(</span>it<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb9-47"><a href="#cb9-47"></a></span>
<span id="cb9-48"><a href="#cb9-48"></a>    <span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>sentinel_for<span class="op">&lt;</span>It<span class="op">&gt;</span> S<span class="op">&gt;</span></span>
<span id="cb9-49"><a href="#cb9-49"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">==(</span>S <span class="kw">const</span><span class="op">&amp;</span> s<span class="op">)</span> <span class="kw">const</span> <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb9-50"><a href="#cb9-50"></a>        <span class="cf">return</span> it <span class="op">==</span> s;</span>
<span id="cb9-51"><a href="#cb9-51"></a>    <span class="op">}</span></span>
<span id="cb9-52"><a href="#cb9-52"></a></span>
<span id="cb9-53"><a href="#cb9-53"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">&lt;=&gt;(</span>basic_const_iterator <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">const</span> <span class="kw">requires</span> std<span class="op">::</span>random_access_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb9-54"><a href="#cb9-54"></a>        <span class="cf">return</span> it <span class="op">&lt;=&gt;</span> rhs;</span>
<span id="cb9-55"><a href="#cb9-55"></a>    <span class="op">}</span></span>
<span id="cb9-56"><a href="#cb9-56"></a></span>
<span id="cb9-57"><a href="#cb9-57"></a>    <span class="kw">template</span> <span class="op">&lt;</span><em>not-same-as</em><span class="op">&lt;</span>basic_const_iterator<span class="op">&gt;</span> Rhs<span class="op">&gt;</span></span>
<span id="cb9-58"><a href="#cb9-58"></a>        <span class="kw">requires</span> std<span class="op">::</span>random_access_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span></span>
<span id="cb9-59"><a href="#cb9-59"></a>             <span class="kw">and</span> std<span class="op">::</span>totally_ordered_with<span class="op">&lt;</span>It, Rhs<span class="op">&gt;</span></span>
<span id="cb9-60"><a href="#cb9-60"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">&lt;=&gt;(</span>Rhs <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">const</span> <span class="op">{</span></span>
<span id="cb9-61"><a href="#cb9-61"></a>        <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span>std<span class="op">::</span>three_way_comparable_with<span class="op">&lt;</span>It, Rhs<span class="op">&gt;)</span> <span class="op">{</span></span>
<span id="cb9-62"><a href="#cb9-62"></a>            <span class="cf">return</span> it <span class="op">&lt;=&gt;</span> rhs;</span>
<span id="cb9-63"><a href="#cb9-63"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span>std<span class="op">::</span>sized_sentinel_for<span class="op">&lt;</span>Rhs, It<span class="op">&gt;)</span> <span class="op">{</span></span>
<span id="cb9-64"><a href="#cb9-64"></a>            <span class="cf">return</span> <span class="op">(</span>it <span class="op">-</span> rhs<span class="op">)</span> <span class="op">&lt;=&gt;</span> <span class="dv">0</span>;</span>
<span id="cb9-65"><a href="#cb9-65"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb9-66"><a href="#cb9-66"></a>            <span class="cf">if</span> <span class="op">(</span>it <span class="op">&lt;</span> rhs<span class="op">)</span> <span class="cf">return</span> std<span class="op">::</span>strong_ordering<span class="op">::</span>less;</span>
<span id="cb9-67"><a href="#cb9-67"></a>            <span class="cf">if</span> <span class="op">(</span>rhs <span class="op">&lt;</span> it<span class="op">)</span> <span class="cf">return</span> std<span class="op">::</span>strong_ordering<span class="op">::</span>greater;</span>
<span id="cb9-68"><a href="#cb9-68"></a>            <span class="cf">return</span> std<span class="op">::</span>strong_ordering<span class="op">::</span>equal;</span>
<span id="cb9-69"><a href="#cb9-69"></a>        <span class="op">}</span></span>
<span id="cb9-70"><a href="#cb9-70"></a>    <span class="op">}</span></span>
<span id="cb9-71"><a href="#cb9-71"></a></span>
<span id="cb9-72"><a href="#cb9-72"></a>    <span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>sized_sentinel_for<span class="op">&lt;</span>It<span class="op">&gt;</span> S<span class="op">&gt;</span></span>
<span id="cb9-73"><a href="#cb9-73"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">-(</span>S <span class="kw">const</span><span class="op">&amp;</span> s<span class="op">)</span> <span class="kw">const</span> <span class="op">-&gt;</span> std<span class="op">::</span>iter_difference_t<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb9-74"><a href="#cb9-74"></a>        <span class="cf">return</span> it <span class="op">-</span> s;</span>
<span id="cb9-75"><a href="#cb9-75"></a>    <span class="op">}</span></span>
<span id="cb9-76"><a href="#cb9-76"></a></span>
<span id="cb9-77"><a href="#cb9-77"></a>    <span class="kw">template</span> <span class="op">&lt;</span><em>not-same-as</em><span class="op">&lt;</span>basic_const_iterator<span class="op">&gt;</span> S<span class="op">&gt;</span></span>
<span id="cb9-78"><a href="#cb9-78"></a>        <span class="kw">requires</span> std<span class="op">::</span>sized_sentinel_for<span class="op">&lt;</span>S, It<span class="op">&gt;</span></span>
<span id="cb9-79"><a href="#cb9-79"></a>    <span class="kw">friend</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">-(</span>S <span class="kw">const</span><span class="op">&amp;</span> s, basic_const_iterator <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="op">-&gt;</span> std<span class="op">::</span>iter_difference_t<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb9-80"><a href="#cb9-80"></a>        <span class="cf">return</span> s <span class="op">-</span> rhs<span class="op">.</span>it;</span>
<span id="cb9-81"><a href="#cb9-81"></a>    <span class="op">}</span></span>
<span id="cb9-82"><a href="#cb9-82"></a></span>
<span id="cb9-83"><a href="#cb9-83"></a>    <span class="kw">auto</span> base<span class="op">()</span> <span class="op">-&gt;</span> It<span class="op">&amp;</span> <span class="op">{</span> <span class="cf">return</span> it; <span class="op">}</span></span>
<span id="cb9-84"><a href="#cb9-84"></a>    <span class="kw">auto</span> base<span class="op">()</span> <span class="kw">const</span> <span class="op">-&gt;</span> It <span class="kw">const</span><span class="op">&amp;</span> <span class="op">{</span> <span class="cf">return</span> it; <span class="op">}</span></span>
<span id="cb9-85"><a href="#cb9-85"></a><span class="op">}</span>;</span>
<span id="cb9-86"><a href="#cb9-86"></a></span>
<span id="cb9-87"><a href="#cb9-87"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T, std<span class="op">::</span>common_with<span class="op">&lt;</span>T<span class="op">&gt;</span> U<span class="op">&gt;</span></span>
<span id="cb9-88"><a href="#cb9-88"></a><span class="kw">struct</span> std<span class="op">::</span>common_type<span class="op">&lt;</span>basic_const_iterator<span class="op">&lt;</span>T<span class="op">&gt;</span>, U<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb9-89"><a href="#cb9-89"></a>    <span class="kw">using</span> type <span class="op">=</span> basic_const_iterator<span class="op">&lt;</span>std<span class="op">::</span>common_type_t<span class="op">&lt;</span>T, U<span class="op">&gt;&gt;</span>;</span>
<span id="cb9-90"><a href="#cb9-90"></a><span class="op">}</span>;</span>
<span id="cb9-91"><a href="#cb9-91"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T, std<span class="op">::</span>common_with<span class="op">&lt;</span>T<span class="op">&gt;</span> U<span class="op">&gt;</span></span>
<span id="cb9-92"><a href="#cb9-92"></a><span class="kw">struct</span> std<span class="op">::</span>common_type<span class="op">&lt;</span>U, basic_const_iterator<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span> <span class="op">{</span></span>
<span id="cb9-93"><a href="#cb9-93"></a>    <span class="kw">using</span> type <span class="op">=</span> basic_const_iterator<span class="op">&lt;</span>std<span class="op">::</span>common_type_t<span class="op">&lt;</span>T, U<span class="op">&gt;&gt;</span>;</span>
<span id="cb9-94"><a href="#cb9-94"></a><span class="op">}</span>;</span>
<span id="cb9-95"><a href="#cb9-95"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T, std<span class="op">::</span>common_with<span class="op">&lt;</span>T<span class="op">&gt;</span> U<span class="op">&gt;</span></span>
<span id="cb9-96"><a href="#cb9-96"></a><span class="kw">struct</span> std<span class="op">::</span>common_type<span class="op">&lt;</span>basic_const_iterator<span class="op">&lt;</span>T<span class="op">&gt;</span>, basic_const_iterator<span class="op">&lt;</span>U<span class="op">&gt;&gt;</span> <span class="op">{</span></span>
<span id="cb9-97"><a href="#cb9-97"></a>    <span class="kw">using</span> type <span class="op">=</span> basic_const_iterator<span class="op">&lt;</span>std<span class="op">::</span>common_type_t<span class="op">&lt;</span>T, U<span class="op">&gt;&gt;</span>;</span>
<span id="cb9-98"><a href="#cb9-98"></a><span class="op">}</span>;</span></code></pre></div>
<p>Since the above implementation satisfies the requirements for a <code class="sourceCode cpp">sentinel</code> where appropriate, we can complete our implementation by providing a <code class="sourceCode cpp">make_const_sentinel</code> to mirror the <code class="sourceCode cpp">make_const_iterator</code> shown earlier:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> S<span class="op">&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="kw">constexpr</span> <span class="kw">auto</span> make_const_sentinel<span class="op">(</span>S s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3"></a>    <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span>std<span class="op">::</span>input_iterator<span class="op">&lt;</span>S<span class="op">&gt;)</span> <span class="op">{</span></span>
<span id="cb10-4"><a href="#cb10-4"></a>        <span class="co">// the sentinel here is an iterator in its own right, so we need to (possibly) wrap it the same way</span></span>
<span id="cb10-5"><a href="#cb10-5"></a>        <span class="cf">return</span> make_const_iterator<span class="op">(</span>std<span class="op">::</span>move<span class="op">(</span>s<span class="op">))</span>;</span>
<span id="cb10-6"><a href="#cb10-6"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb10-7"><a href="#cb10-7"></a>        <span class="cf">return</span> s;</span>
<span id="cb10-8"><a href="#cb10-8"></a>    <span class="op">}</span></span>
<span id="cb10-9"><a href="#cb10-9"></a><span class="op">}</span></span></code></pre></div>
<p>We could take the iterator type as a template parameter to enforce that <code class="sourceCode cpp">S</code> satisfies <code class="sourceCode cpp">sentinel_for<span class="op">&lt;</span>I<span class="op">&gt;</span></code>, but this function is only used as a building block of an algorithm that would already enforce this, so it’s probably not necessary.</p>
<h2 data-number="3.4" id="better-algorithms-for-stdrangescbegin-and-stdrangesend"><span class="header-section-number">3.4</span> Better Algorithms for <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>end</code><a href="#better-algorithms-for-stdrangescbegin-and-stdrangesend" class="self-link"></a></h2>
<p><code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin</code> today (<span>24.3.4 <a href="https://wg21.link/range.access.cbegin">[range.access.cbegin]</a></span>) unconditionally calls <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>begin</code>. Similarly, <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> today (<span>23.7 <a href="https://wg21.link/iterator.range">[iterator.range]</a></span>) unconditionally calls <code class="sourceCode cpp">std<span class="op">::</span>begin</code>. The status quo in the library is that nothing anywhere invokes <em>member</em> <code class="sourceCode cpp">cbegin</code>. The goal is to provide a constant iterator version of <code class="sourceCode cpp">begin<span class="op">()</span></code> — we have not had a customization point for this facility in the past and we can achieve this goal without having to add a customization point for the future.</p>
<p>With the above pieces, we implement a <code class="sourceCode cpp">ranges<span class="op">::</span>cbegin</code> and <code class="sourceCode cpp">ranges<span class="op">::</span>end</code> to ensure that we get a constant iterator (see full implementation <span class="citation" data-cites="const-impl">[<a href="#ref-const-impl" role="doc-biblioref">const-impl</a>]</span>, complete with many tests):</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">inline</span> <span class="kw">constexpr</span> <span class="kw">auto</span> possibly_const <span class="op">=</span> <span class="op">[]&lt;</span>std<span class="op">::</span>ranges<span class="op">::</span>range R<span class="op">&gt;(</span>R<span class="op">&amp;</span> r<span class="op">)</span> <span class="op">-&gt;</span> <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>    <span class="co">// we only cast to const if it is meaningful to do so</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>    <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span><em>constant-range</em><span class="op">&lt;</span>R <span class="kw">const</span><span class="op">&gt;</span> <span class="kw">and</span> <span class="kw">not</span> <em>constant-range</em><span class="op">&lt;</span>R<span class="op">&gt;)</span> <span class="op">{</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>        <span class="cf">return</span> <span class="kw">const_cast</span><span class="op">&lt;</span>R <span class="kw">const</span><span class="op">&amp;&gt;(</span>r<span class="op">)</span>;</span>
<span id="cb11-5"><a href="#cb11-5"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb11-6"><a href="#cb11-6"></a>        <span class="cf">return</span> r;</span>
<span id="cb11-7"><a href="#cb11-7"></a>    <span class="op">}</span></span>
<span id="cb11-8"><a href="#cb11-8"></a><span class="op">}</span>;</span>
<span id="cb11-9"><a href="#cb11-9"></a></span>
<span id="cb11-10"><a href="#cb11-10"></a><span class="kw">inline</span> <span class="kw">constexpr</span> <span class="kw">auto</span> cbegin <span class="op">=</span> first_of<span class="op">(</span></span>
<span id="cb11-11"><a href="#cb11-11"></a>    <span class="co">// 1. non-borrowed rvalue</span></span>
<span id="cb11-12"><a href="#cb11-12"></a>    delete_if_nonborrowed_rvalue,</span>
<span id="cb11-13"><a href="#cb11-13"></a>    <span class="co">// 2. possibly-wrapped begin of possibly-const r</span></span>
<span id="cb11-14"><a href="#cb11-14"></a>    <span class="op">[](</span>std<span class="op">::</span>ranges<span class="op">::</span>range <span class="kw">auto</span><span class="op">&amp;&amp;</span> r<span class="op">)</span></span>
<span id="cb11-15"><a href="#cb11-15"></a>        RETURNS<span class="op">(</span>make_const_iterator<span class="op">(</span>std<span class="op">::</span>ranges<span class="op">::</span>begin<span class="op">(</span>possibly_const<span class="op">(</span>r<span class="op">))))</span></span>
<span id="cb11-16"><a href="#cb11-16"></a><span class="op">)</span>;</span>
<span id="cb11-17"><a href="#cb11-17"></a></span>
<span id="cb11-18"><a href="#cb11-18"></a><span class="kw">inline</span> <span class="kw">constexpr</span> <span class="kw">auto</span> cend <span class="op">=</span> first_of<span class="op">(</span></span>
<span id="cb11-19"><a href="#cb11-19"></a>    <span class="co">// 1. non-borrowed rvalue</span></span>
<span id="cb11-20"><a href="#cb11-20"></a>    delete_if_nonborrowed_rvalue,</span>
<span id="cb11-21"><a href="#cb11-21"></a>    <span class="co">// 2. possibly-wrapped end of possibly-const r</span></span>
<span id="cb11-22"><a href="#cb11-22"></a>    <span class="op">[](</span>std<span class="op">::</span>ranges<span class="op">::</span>range <span class="kw">auto</span><span class="op">&amp;&amp;</span> r<span class="op">)</span></span>
<span id="cb11-23"><a href="#cb11-23"></a>        RETURNS<span class="op">(</span>make_const_sentinel<span class="op">(</span>std<span class="op">::</span>ranges<span class="op">::</span>end<span class="op">(</span>possibly_const<span class="op">(</span>r<span class="op">))))</span></span>
<span id="cb11-24"><a href="#cb11-24"></a><span class="op">)</span>;</span></code></pre></div>
<p>Here, <code class="sourceCode cpp">cbegin<span class="op">(</span>r<span class="op">)</span></code> and <code class="sourceCode cpp">cend<span class="op">(</span>r<span class="op">)</span></code> produce a range that is top-level const over any underlying range, without having to modify any of those underlying ranges to opt in to this behavior. This works for <code class="sourceCode cpp">std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span></code> and <code class="sourceCode cpp">std<span class="op">::</span>span<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span></code> and <code class="sourceCode cpp">boost<span class="op">::</span>iterator_range<span class="op">&lt;</span><span class="dt">int</span><span class="op">*&gt;</span></code> and even views like <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>filter_view</code> (<code class="sourceCode cpp">possibly_const</code> ensures that if get passed a non-<code class="sourceCode cpp"><span class="kw">const</span></code> <code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span></code>, we treat it as <code class="sourceCode cpp"><span class="kw">const</span></code> first — which is both valid and necessary — while <code class="sourceCode cpp">filter_view <span class="kw">const</span></code> isn’t a <code class="sourceCode cpp">range</code> so we cannot treat it as <code class="sourceCode cpp"><span class="kw">const</span></code> first).</p>
<p>Avoiding a customization point here lets us give an easy answer to the question of whether or not types should provide a member <code class="sourceCode cpp">cbegin</code> going forward: no, they shouldn’t. Users that want a constant iterator can use this facility, which will work for all ranges.</p>
<p>In addition to simply working across all ranges, it has a few other features worth noting:</p>
<ul>
<li>For a <code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v</code>, <code class="sourceCode cpp">cbegin<span class="op">(</span>v<span class="op">)</span></code> gives precisely the type <code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>const_iterator</code> (not <code class="sourceCode cpp">const_iterator<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>iterator<span class="op">&gt;</span></code>).</li>
<li>For a <code class="sourceCode cpp">span<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> s</code>, <code class="sourceCode cpp">cbegin<span class="op">(</span>s<span class="op">)</span></code> provides a contiguous iterator over <code class="sourceCode cpp"><span class="dt">int</span> <span class="kw">const</span><span class="op">&amp;</span></code>, not just any kind of iterator.</li>
<li>For a <code class="sourceCode cpp">transform_view<span class="op">&lt;</span>V, F<span class="op">&gt;</span></code>, we <em>avoid</em> casting to <code class="sourceCode cpp"><span class="kw">const</span></code>, since it doesn’t do anything for us. But for a <code class="sourceCode cpp">single_view<span class="op">&lt;</span>T<span class="op">&gt;</span></code> (which is an owning view and thus deep <code class="sourceCode cpp"><span class="kw">const</span></code>), we <em>do</em> cast to <code class="sourceCode cpp"><span class="kw">const</span></code>.</li>
</ul>
<p>Note that here, <code class="sourceCode cpp">ranges<span class="op">::</span>end</code> already checks that the type returned is a <code class="sourceCode cpp">sentinel</code> for the type returned by <code class="sourceCode cpp">ranges<span class="op">::</span>begin</code>. Given that fact, the implementation here already ensures that <code class="sourceCode cpp">sentinel_for<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>cbegin<span class="op">(</span>r<span class="op">))</span>, <span class="kw">decltype</span><span class="op">(</span>cend<span class="op">(</span>r<span class="op">))&gt;</span></code> holds.</p>
<h2 data-number="3.5" id="a-viewsall_const"><span class="header-section-number">3.5</span> A <code class="sourceCode cpp">views<span class="op">::</span>all_const</code><a href="#a-viewsall_const" class="self-link"></a></h2>
<p>A whole const-view can be implemented on top of these pieces, in the same way that <code class="sourceCode cpp">views<span class="op">::</span>reverse</code> is implemented on top of <code class="sourceCode cpp">reverse_iterator</code> (see the full implementation <span class="citation" data-cites="const-impl">[<a href="#ref-const-impl" role="doc-biblioref">const-impl</a>]</span>):</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>ranges<span class="op">::</span>input_range V<span class="op">&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>    <span class="kw">requires</span> std<span class="op">::</span>ranges<span class="op">::</span>view<span class="op">&lt;</span>V<span class="op">&gt;</span></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="kw">class</span> const_view <span class="op">:</span> <span class="kw">public</span> std<span class="op">::</span>ranges<span class="op">::</span>view_interface<span class="op">&lt;</span>const_view<span class="op">&lt;</span>V<span class="op">&gt;&gt;</span> <span class="op">{</span></span>
<span id="cb12-4"><a href="#cb12-4"></a>    V base <span class="op">=</span> V<span class="op">()</span>;</span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb12-6"><a href="#cb12-6"></a>    <span class="kw">constexpr</span> const_view<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb12-7"><a href="#cb12-7"></a>    <span class="kw">constexpr</span> const_view<span class="op">(</span>V base<span class="op">)</span> <span class="op">:</span> base<span class="op">(</span>std<span class="op">::</span>move<span class="op">(</span>base<span class="op">))</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb12-8"><a href="#cb12-8"></a></span>
<span id="cb12-9"><a href="#cb12-9"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> begin<span class="op">()</span> <span class="kw">requires</span> <span class="op">(!</span><em>simple-view</em><span class="op">&lt;</span>V<span class="op">&gt;)</span> <span class="op">{</span> <span class="cf">return</span> cbegin<span class="op">(</span>base<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb12-10"><a href="#cb12-10"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> end<span class="op">()</span> <span class="kw">requires</span> <span class="op">(!</span><em>simple-view</em><span class="op">&lt;</span>V<span class="op">&gt;)</span> <span class="op">{</span> <span class="cf">return</span> cend<span class="op">(</span>base<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb12-11"><a href="#cb12-11"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> size<span class="op">()</span> <span class="kw">requires</span> std<span class="op">::</span>ranges<span class="op">::</span>sized_range<span class="op">&lt;</span>V<span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> std<span class="op">::</span>ranges<span class="op">::</span>size<span class="op">(</span>base<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb12-12"><a href="#cb12-12"></a></span>
<span id="cb12-13"><a href="#cb12-13"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> begin<span class="op">()</span> <span class="kw">const</span> <span class="kw">requires</span> std<span class="op">::</span>ranges<span class="op">::</span>range<span class="op">&lt;</span>V <span class="kw">const</span><span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> cbegin<span class="op">(</span>base<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb12-14"><a href="#cb12-14"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> end<span class="op">()</span> <span class="kw">const</span> <span class="kw">requires</span> std<span class="op">::</span>ranges<span class="op">::</span>range<span class="op">&lt;</span>V <span class="kw">const</span><span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> cend<span class="op">(</span>base<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb12-15"><a href="#cb12-15"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> size<span class="op">()</span> <span class="kw">const</span> <span class="kw">requires</span> std<span class="op">::</span>ranges<span class="op">::</span>sized_range<span class="op">&lt;</span>V <span class="kw">const</span><span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> std<span class="op">::</span>ranges<span class="op">::</span>size<span class="op">(</span>base<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb12-16"><a href="#cb12-16"></a><span class="op">}</span>;</span>
<span id="cb12-17"><a href="#cb12-17"></a></span>
<span id="cb12-18"><a href="#cb12-18"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> V<span class="op">&gt;</span></span>
<span id="cb12-19"><a href="#cb12-19"></a><span class="kw">inline</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="op">::</span>std<span class="op">::</span>ranges<span class="op">::</span>enable_borrowed_range<span class="op">&lt;</span>const_view<span class="op">&lt;</span>V<span class="op">&gt;&gt;</span> <span class="op">=</span></span>
<span id="cb12-20"><a href="#cb12-20"></a>    std<span class="op">::</span>ranges<span class="op">::</span>enable_borrowed_range<span class="op">&lt;</span>V<span class="op">&gt;</span>;</span>
<span id="cb12-21"><a href="#cb12-21"></a></span>
<span id="cb12-22"><a href="#cb12-22"></a><span class="co">// libstdc++ specific (hopefully standard version coming soon from P2387!)</span></span>
<span id="cb12-23"><a href="#cb12-23"></a><span class="kw">inline</span> <span class="kw">constexpr</span> std<span class="op">::</span>views<span class="op">::</span>__adaptor<span class="op">::</span>_RangeAdaptorClosure all_const <span class="op">=</span></span>
<span id="cb12-24"><a href="#cb12-24"></a>    <span class="op">[]&lt;</span>std<span class="op">::</span>ranges<span class="op">::</span>viewable_range R<span class="op">&gt;(</span>R<span class="op">&amp;&amp;</span> r<span class="op">)</span></span>
<span id="cb12-25"><a href="#cb12-25"></a>    <span class="op">{</span></span>
<span id="cb12-26"><a href="#cb12-26"></a>        <span class="kw">using</span> U <span class="op">=</span> std<span class="op">::</span>remove_cvref_t<span class="op">&lt;</span>R<span class="op">&gt;</span>;</span>
<span id="cb12-27"><a href="#cb12-27"></a></span>
<span id="cb12-28"><a href="#cb12-28"></a>        <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span><em>constant-range</em><span class="op">&lt;</span>std<span class="op">::</span>views<span class="op">::</span>all_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;)</span> <span class="op">{</span></span>
<span id="cb12-29"><a href="#cb12-29"></a>            <span class="cf">return</span> std<span class="op">::</span>views<span class="op">::</span>all<span class="op">(</span>FWD<span class="op">(</span>r<span class="op">))</span>;</span>
<span id="cb12-30"><a href="#cb12-30"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span>std<span class="op">::</span>is_lvalue_reference_v<span class="op">&lt;</span>R<span class="op">&gt;</span></span>
<span id="cb12-31"><a href="#cb12-31"></a>                             <span class="kw">and</span> <em>constant-range</em><span class="op">&lt;</span>U <span class="kw">const</span><span class="op">&gt;</span></span>
<span id="cb12-32"><a href="#cb12-32"></a>                             <span class="kw">and</span> <span class="kw">not</span> std<span class="op">::</span>ranges<span class="op">::</span>view<span class="op">&lt;</span>U<span class="op">&gt;)</span> <span class="op">{</span></span>
<span id="cb12-33"><a href="#cb12-33"></a>            <span class="cf">return</span> std<span class="op">::</span>views<span class="op">::</span>all<span class="op">(</span>std<span class="op">::</span>as_const<span class="op">(</span>r<span class="op">))</span>;</span>
<span id="cb12-34"><a href="#cb12-34"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb12-35"><a href="#cb12-35"></a>            <span class="cf">return</span> const_view<span class="op">&lt;</span>std<span class="op">::</span>views<span class="op">::</span>all_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;(</span>std<span class="op">::</span>views<span class="op">::</span>all<span class="op">(</span>FWD<span class="op">(</span>r<span class="op">)))</span>;</span>
<span id="cb12-36"><a href="#cb12-36"></a>        <span class="op">}</span></span>
<span id="cb12-37"><a href="#cb12-37"></a>    <span class="op">}</span>;</span></code></pre></div>
<p>The three cases here are:</p>
<ol type="1">
<li><code class="sourceCode cpp">r</code> is already a constant range, no need to do anything, pass it through. Examples are <code class="sourceCode cpp">std<span class="op">::</span>span<span class="op">&lt;</span>T <span class="kw">const</span><span class="op">&gt;</span></code> or <code class="sourceCode cpp">std<span class="op">::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="kw">const</span></code> or <code class="sourceCode cpp">std<span class="op">::</span>set<span class="op">&lt;</span>T<span class="op">&gt;</span></code>. We specifically check <code class="sourceCode cpp">all_t<span class="op">&lt;</span>R<span class="op">&gt;</span></code> rather than <code class="sourceCode cpp">R</code> to handle the case where <code class="sourceCode cpp">R</code> might be a view that is a constant range, but we have a const object that is a deep-const view (e.g. if <code class="sourceCode cpp">r</code> is a <code class="sourceCode cpp">single_view<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="kw">const</span></code>, then <code class="sourceCode cpp">views<span class="op">::</span>all<span class="op">(</span>r<span class="op">)</span></code> would be a <code class="sourceCode cpp">single_view<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span></code> which is no longer a constant range).</li>
<li><code class="sourceCode cpp">r</code> is not a constant range but <code class="sourceCode cpp">std<span class="op">::</span>as_const<span class="op">(</span>r<span class="op">)</span></code> would be. Rather than do any wrapping ourselves, we defer to <code class="sourceCode cpp">std<span class="op">::</span>as_const</code>. Example is <code class="sourceCode cpp">std<span class="op">::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span></code>. We explicitly remove <code class="sourceCode cpp">view</code>s from this set, because <code class="sourceCode cpp">views<span class="op">::</span>all<span class="op">()</span></code> would drop the <code class="sourceCode cpp"><span class="kw">const</span></code> anyway and we may need to preserve it (e.g. <code class="sourceCode cpp">single_view<span class="op">&lt;</span>T<span class="op">&gt;</span></code>). We only allow lvalue ranges (necessary in a post-<span class="citation" data-cites="P2415R2">[<a href="#ref-P2415R2" role="doc-biblioref">P2415R2</a>]</span> world) because rvalue ranges (like views) would also drop the <code class="sourceCode cpp"><span class="kw">const</span></code> even if we added it.</li>
<li><code class="sourceCode cpp">r</code> is neither a constant range nor can easily be made one, so we have to wrap ourselves. Examples are basically any mutable view.</li>
</ol>
<p>To me, being able to provide a <code class="sourceCode cpp">views<span class="op">::</span>as_const</code> is the ultimate solution for this problem, since it’s the one that guarantees correctness even in the presence of a range-based for statement:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1"></a><span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="kw">const</span><span class="op">&amp;</span> e <span class="op">:</span> r <span class="op">|</span> views<span class="op">::</span>as_const<span class="op">)</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span></code></pre></div>
<p>Or passing a constant range to an algorithm:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a>dont_touch_me<span class="op">(</span>views<span class="op">::</span>as_const<span class="op">(</span>r<span class="op">))</span>;</span></code></pre></div>
<h3 data-number="3.5.1" id="naming"><span class="header-section-number">3.5.1</span> Naming<a href="#naming" class="self-link"></a></h3>
<p>As far as naming goes, obviously we can’t just call it <code class="sourceCode cpp">views<span class="op">::</span><span class="kw">const</span></code>. range-v3 calls it <code class="sourceCode cpp">const_</code>, but there’s a few other good name options here like <code class="sourceCode cpp">views<span class="op">::</span>as_const</code> (like <code class="sourceCode cpp">std<span class="op">::</span>as_const</code>, but for <code class="sourceCode cpp">views</code>) or <code class="sourceCode cpp">views<span class="op">::</span>to_const</code> or <code class="sourceCode cpp">views<span class="op">::</span>constify</code> or <code class="sourceCode cpp">views<span class="op">::</span>all_const</code> (like <code class="sourceCode cpp">views<span class="op">::</span>all</code>). <span class="citation" data-cites="P2278R0">[<a href="#ref-P2278R0" role="doc-biblioref">P2278R0</a>]</span> used range-v3’s <code class="sourceCode cpp">views<span class="op">::</span>const_</code>, <span class="citation" data-cites="P2287R1">[<a href="#ref-P2287R1" role="doc-biblioref">P2287R1</a>]</span> used <code class="sourceCode cpp">views<span class="op">::</span>as_const</code>. The advantage of <code class="sourceCode cpp">views<span class="op">::</span>as_const</code> is that it is a mirror of <code class="sourceCode cpp">std<span class="op">::</span>as_const</code> and so sharing a name seems reasonable. The disadvantage is that it could cause users to use <code class="sourceCode cpp">std<span class="op">::</span>as_const</code> when they meant to use <code class="sourceCode cpp">views<span class="op">::</span>as_const</code>.</p>
<p>A recent LEWG telecon <span class="citation" data-cites="p2278-minutes">[<a href="#ref-p2278-minutes" role="doc-biblioref">p2278-minutes</a>]</span> preferred the name <code class="sourceCode cpp">views<span class="op">::</span>all_const</code> under the premise that <code class="sourceCode cpp">views<span class="op">::</span>as_const</code> is too much like <code class="sourceCode cpp">std<span class="op">::</span>as_const</code> and that users might think it applies <code class="sourceCode cpp"><span class="kw">const</span></code> to the top-level range rather than each element.</p>
<h2 data-number="3.6" id="what-about-stdcbegin-and-stdcend"><span class="header-section-number">3.6</span> What About <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>cend</code>?<a href="#what-about-stdcbegin-and-stdcend" class="self-link"></a></h2>
<p>The above presents an implementation strategy for <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cend</code>.</p>
<p>But what about <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>cend</code>? The problem is, while the former is C++20 technology and so can make use of the C++20 iterator model, <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> is C++11 technology and so has to remain fixed with the C++11 iterator model. The biggest difference for these purposes has to do with input iterators.</p>
<p>In C++11, even for an input iterator, this is valid code:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">auto</span> val <span class="op">=</span> <span class="op">*</span>it<span class="op">++</span>;</span></code></pre></div>
<p>But in C++20, an input iterator’s postfix increment operator need not return a copy of itself. All the ones in the standard library return <code class="sourceCode cpp"><span class="dt">void</span></code>. This is the safer design, since any use of postfix increment that isn’t either ignoring the result or exactly the above expression are simply wrong for input iterators.</p>
<p>Trying to be backwards compatible with pre-C++20 iterators is quite hard (again, see <span class="citation" data-cites="P2259R0">[<a href="#ref-P2259R0" role="doc-biblioref">P2259R0</a>]</span>), and the <code class="sourceCode cpp">basic_const_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span></code> implementation provided in this paper would <em>not</em> be a valid C++17 input iterator. Additionally, C++20 input iterators are required to be default constructible while C++17 input iterators were not.</p>
<p>On the other hand, is it critically important to have a constant iterator for a C++17 input iterator? You’re not going to mutate anything meaningful anyway.</p>
<p>A simple solution could have <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>c<span class="op">)</span></code> pass through C++17 input iterators unconditionally, and otherwise do <code class="sourceCode cpp">make_const_iterator<span class="op">(</span>as_const<span class="op">(</span>c<span class="op">).</span>begin<span class="op">())</span></code> (i.e. the <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin</code> described above) for all iterators that are either C++20 iterators or C++17 forward iterators. This probably addresses the majority of the use-cases with minimal fuss.</p>
<p>Moreover, would we want to extend <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> to also handle non-<code class="sourceCode cpp"><span class="kw">const</span></code>-iterable ranges? This is technically doable:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> C<span class="op">&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="kw">concept</span> can_begin <span class="op">=</span> <span class="kw">requires</span> <span class="op">(</span>C<span class="op">&amp;</span> c<span class="op">)</span> <span class="op">{</span> std<span class="op">::</span>begin<span class="op">(</span>c<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb16-3"><a href="#cb16-3"></a></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> C<span class="op">&gt;</span></span>
<span id="cb16-5"><a href="#cb16-5"></a>    <span class="kw">requires</span> can_begin<span class="op">&lt;</span><span class="kw">const</span> C<span class="op">&gt;</span></span>
<span id="cb16-6"><a href="#cb16-6"></a><span class="kw">constexpr</span> <span class="kw">auto</span> cbegin<span class="op">(</span><span class="kw">const</span> C<span class="op">&amp;</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-7"><a href="#cb16-7"></a>    <span class="co">// today&#39;s overload, but also conditionally wrap</span></span>
<span id="cb16-8"><a href="#cb16-8"></a><span class="op">}</span></span>
<span id="cb16-9"><a href="#cb16-9"></a></span>
<span id="cb16-10"><a href="#cb16-10"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> C<span class="op">&gt;</span></span>
<span id="cb16-11"><a href="#cb16-11"></a>    <span class="kw">requires</span> <span class="op">(</span>can_begin<span class="op">&lt;</span>C<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> <span class="op">!</span>can_begin<span class="op">&lt;</span><span class="kw">const</span> C<span class="op">&gt;)</span></span>
<span id="cb16-12"><a href="#cb16-12"></a><span class="kw">constexpr</span> <span class="kw">auto</span> cbegin<span class="op">(</span>C<span class="op">&amp;</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-13"><a href="#cb16-13"></a>    <span class="co">// fallback for non-const-iterable ranges</span></span>
<span id="cb16-14"><a href="#cb16-14"></a><span class="op">}</span></span></code></pre></div>
<p>I negated the constraint to prefer the <code class="sourceCode cpp"><span class="kw">const</span> C<span class="op">&amp;</span></code> overload even for non-const arguments.</p>
<p>But we didn’t introduce a C++20 iteration model to then go back and give us more work to keep two models in lock-step. The C++20 one on its own is hard enough, and is a better model. We should just commit to it.</p>
<p>We could consider doing something like:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> C<span class="op">&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="kw">constexpr</span> <span class="kw">auto</span> cbegin<span class="op">(</span>C <span class="kw">const</span><span class="op">&amp;</span> c<span class="op">)</span></span>
<span id="cb17-3"><a href="#cb17-3"></a>    <span class="kw">requires</span> <span class="kw">requires</span> <span class="op">{</span> std<span class="op">::</span>begin<span class="op">(</span>c<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="op">{</span></span>
<span id="cb17-5"><a href="#cb17-5"></a>    <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span>std<span class="op">::</span>forward_iterator<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>std<span class="op">::</span>begin<span class="op">(</span>c<span class="op">))&gt;)</span> <span class="op">{</span></span>
<span id="cb17-6"><a href="#cb17-6"></a>        <span class="cf">return</span> make_const_iterator<span class="op">(</span>std<span class="op">::</span>begin<span class="op">(</span>c<span class="op">))</span>;</span>
<span id="cb17-7"><a href="#cb17-7"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb17-8"><a href="#cb17-8"></a>        <span class="co">// leave input iterators (or... whatever) alone</span></span>
<span id="cb17-9"><a href="#cb17-9"></a>        <span class="cf">return</span> std<span class="op">::</span>begin<span class="op">(</span>c<span class="op">)</span>;</span>
<span id="cb17-10"><a href="#cb17-10"></a>    <span class="op">}</span></span>
<span id="cb17-11"><a href="#cb17-11"></a><span class="op">}</span></span></code></pre></div>
<p>And similarly for <code class="sourceCode cpp">std<span class="op">::</span>cend</code>. This isn’t entirely without peril: currently we say nothing about the constraints for <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>r<span class="op">)</span></code>; just that it calls <code class="sourceCode cpp">r<span class="op">.</span>begin<span class="op">()</span></code>, <em>whatever that is</em>. There isn’t a requirement that this ends up giving an iterator and there’s no requirement that any of the operations that <code class="sourceCode cpp">std<span class="op">::</span>forward_iterator</code> would check are SFINAE-friendly. I don’t know if we necessarily care about such (mis)uses of <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code>, but it is worth noting.</p>
<p>But what would we gain by making this change? Sure, <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>x<span class="op">)</span></code> is now more likely to produce a constant iterator than it was before since we’re going to improve cases like <code class="sourceCode cpp">span</code>. But it still won’t work for non-const-iterable ranges (like <code class="sourceCode cpp">drop_while</code> or <code class="sourceCode cpp">filter</code>), or shallow-const input ranges, and has a chance to break existing code. As such, it doesn’t really feel worth doing, since <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin</code> simply works for all of these cases, so why not use that?</p>
<h2 data-number="3.7" id="now-reverse-it"><span class="header-section-number">3.7</span> Now Reverse It<a href="#now-reverse-it" class="self-link"></a></h2>
<p>Now that we can produce a constant iterator for a range, producing a reversed constant iterator is a matter of composing operations. We don’t have to worry about sentinels in this case:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">inline</span> <span class="kw">constexpr</span> <span class="kw">auto</span> crbegin <span class="op">=</span> first_of<span class="op">(</span></span>
<span id="cb18-2"><a href="#cb18-2"></a>    <span class="co">// 1. non-borrowed rvalue</span></span>
<span id="cb18-3"><a href="#cb18-3"></a>    delete_if_nonborrowed_rvalue,</span>
<span id="cb18-4"><a href="#cb18-4"></a>    <span class="co">// 2. possibly-wrapped reversed begin of possibly-const range</span></span>
<span id="cb18-5"><a href="#cb18-5"></a>    <span class="op">[](</span>std<span class="op">::</span>ranges<span class="op">::</span>range <span class="kw">auto</span><span class="op">&amp;&amp;</span> r<span class="op">)</span> RETURNS<span class="op">(</span>make_const_iterator<span class="op">(</span>std<span class="op">::</span>ranges<span class="op">::</span>rbegin<span class="op">(</span>possibly_const<span class="op">(</span>r<span class="op">))))</span></span>
<span id="cb18-6"><a href="#cb18-6"></a><span class="op">)</span>;</span>
<span id="cb18-7"><a href="#cb18-7"></a></span>
<span id="cb18-8"><a href="#cb18-8"></a><span class="kw">inline</span> <span class="kw">constexpr</span> <span class="kw">auto</span> crend <span class="op">=</span> first_of<span class="op">(</span></span>
<span id="cb18-9"><a href="#cb18-9"></a>    <span class="co">// 1. non-borrowed rvalue</span></span>
<span id="cb18-10"><a href="#cb18-10"></a>    delete_if_nonborrowed_rvalue,</span>
<span id="cb18-11"><a href="#cb18-11"></a>    <span class="co">// 2. possibly-wrapped reversed end of possibly-const range</span></span>
<span id="cb18-12"><a href="#cb18-12"></a>    <span class="op">[](</span>std<span class="op">::</span>ranges<span class="op">::</span>range <span class="kw">auto</span><span class="op">&amp;&amp;</span> r<span class="op">)</span> RETURNS<span class="op">(</span>make_const_iterator<span class="op">(</span>std<span class="op">::</span>ranges<span class="op">::</span>rend<span class="op">(</span>possibly_const<span class="op">(</span>r<span class="op">))))</span></span>
<span id="cb18-13"><a href="#cb18-13"></a><span class="op">)</span>;</span></code></pre></div>
<p>Notably here, <code class="sourceCode cpp">ranges<span class="op">::</span>rbegin</code> and <code class="sourceCode cpp">ranges<span class="op">::</span>rend</code> already themselves will try to produce a <code class="sourceCode cpp">std<span class="op">::</span>reverse_iterator</code> if the underlying range is bidirectional. Similarly, we’re ourselves trying to produce a <code class="sourceCode cpp">std<span class="op">::</span>const_iterator</code>.</p>
<p>The extension to <code class="sourceCode cpp">std<span class="op">::</span>crbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>crend</code> mirrors the similar extension to <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>cend</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> C<span class="op">&gt;</span></span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="kw">constexpr</span> <span class="kw">auto</span> crbegin<span class="op">(</span>C <span class="kw">const</span><span class="op">&amp;</span> c<span class="op">)</span></span>
<span id="cb19-3"><a href="#cb19-3"></a>    <span class="kw">requires</span> <span class="kw">requires</span> <span class="op">{</span> std<span class="op">::</span>rbegin<span class="op">(</span>c<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="op">{</span></span>
<span id="cb19-5"><a href="#cb19-5"></a>    <span class="cf">if</span> consetxpr <span class="op">(</span>std<span class="op">::</span>forward_iterator<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>std<span class="op">::</span>rbegin<span class="op">(</span>c<span class="op">))&gt;)</span> <span class="op">{</span></span>
<span id="cb19-6"><a href="#cb19-6"></a>        <span class="cf">return</span> make_const_iterator<span class="op">(</span>std<span class="op">::</span>rbegin<span class="op">(</span>c<span class="op">))</span>;</span>
<span id="cb19-7"><a href="#cb19-7"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb19-8"><a href="#cb19-8"></a>        <span class="co">// leave input iterators (or... whatever) alone</span></span>
<span id="cb19-9"><a href="#cb19-9"></a>        <span class="cf">return</span> std<span class="op">::</span>rbegin<span class="op">(</span>c<span class="op">)</span>;</span>
<span id="cb19-10"><a href="#cb19-10"></a>    <span class="op">}</span></span>
<span id="cb19-11"><a href="#cb19-11"></a><span class="op">}</span></span></code></pre></div>
<p>Even though in the standard library we define <code class="sourceCode cpp">const_reverse_iterator</code> as <code class="sourceCode cpp">std<span class="op">::</span>reverse_iterator<span class="op">&lt;</span>const_iterator<span class="op">&gt;</span></code> and the algorithm presented here constifies a reverse iterator, it still produces the same result for all standard library containers because <code class="sourceCode cpp">rbegin<span class="op">()</span> <span class="kw">const</span></code> returns <code class="sourceCode cpp">const_reverse_iterator</code>, so we already have a constant iterator just from <code class="sourceCode cpp">rbegin</code>.</p>
<h2 data-number="3.8" id="customizing-make_const_iterator"><span class="header-section-number">3.8</span> Customizing <code class="sourceCode cpp">make_const_iterator</code><a href="#customizing-make_const_iterator" class="self-link"></a></h2>
<p>The job of <code class="sourceCode cpp">make_const_iterator<span class="op">(</span>it<span class="op">)</span></code> is to ensure that its result is a constant iterator that is as compatible as possible with <code class="sourceCode cpp">it</code> (ideally, exactly <code class="sourceCode cpp">it</code> where possible). For a typical iterator, <code class="sourceCode cpp">I</code>, the best we could do if <code class="sourceCode cpp">I</code> is a mutable iterator is to return a <code class="sourceCode cpp">const_iterator<span class="op">&lt;</span>I<span class="op">&gt;</span></code>. But what if we had more information. Could we do better? <em>Should</em> we do better?</p>
<p>Consider <code class="sourceCode cpp"><span class="dt">char</span><span class="op">*</span></code>. <code class="sourceCode cpp"><span class="dt">char</span><span class="op">*</span></code> is not a constant iterator, and the <code class="sourceCode cpp">make_const_iterator</code> presented here will yield a <code class="sourceCode cpp">const_iterator<span class="op">&lt;</span><span class="dt">char</span><span class="op">*&gt;</span></code>. But there is a different kind of constant iterator we could return in this case that satisfies all the complicated requirements we’ve laid out for how a constant iterator should behave, and it’s kind of the obvious choice: <code class="sourceCode cpp"><span class="dt">char</span> <span class="kw">const</span><span class="op">*</span></code>. Returning <code class="sourceCode cpp"><span class="kw">const</span> <span class="dt">char</span><span class="op">*</span></code> here does the advantage in that we avoid having to do this extra template instantiation, which is certainly not free.</p>
<p>The question is: should <code class="sourceCode cpp">make_const_iterator<span class="op">(</span><span class="dt">char</span><span class="op">*)</span></code> yield a <code class="sourceCode cpp"><span class="dt">char</span> <span class="kw">const</span><span class="op">*</span></code> instead of a <code class="sourceCode cpp">const_iterator<span class="op">&lt;</span><span class="dt">char</span><span class="op">*&gt;</span></code>?</p>
<p>Let’s take a look at a test-case. Here is a contiguous range that is a null-terminated mutable character string:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1"></a><span class="kw">struct</span> zsentinel <span class="op">{</span></span>
<span id="cb20-2"><a href="#cb20-2"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">==(</span><span class="dt">char</span><span class="op">*</span> p<span class="op">)</span> <span class="kw">const</span> <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb20-3"><a href="#cb20-3"></a>        <span class="cf">return</span> <span class="op">*</span>p <span class="op">==</span> <span class="ch">&#39;</span><span class="sc">\0</span><span class="ch">&#39;</span>;</span>
<span id="cb20-4"><a href="#cb20-4"></a>    <span class="op">}</span></span>
<span id="cb20-5"><a href="#cb20-5"></a><span class="op">}</span>;</span>
<span id="cb20-6"><a href="#cb20-6"></a></span>
<span id="cb20-7"><a href="#cb20-7"></a><span class="kw">struct</span> zstring <span class="op">{</span></span>
<span id="cb20-8"><a href="#cb20-8"></a>    <span class="dt">char</span><span class="op">*</span> p;</span>
<span id="cb20-9"><a href="#cb20-9"></a>    <span class="kw">auto</span> begin<span class="op">()</span> <span class="kw">const</span> <span class="op">-&gt;</span> <span class="dt">char</span><span class="op">*</span> <span class="op">{</span> <span class="cf">return</span> p; <span class="op">}</span></span>
<span id="cb20-10"><a href="#cb20-10"></a>    <span class="kw">auto</span> end<span class="op">()</span> <span class="kw">const</span> <span class="op">-&gt;</span> zsentinel <span class="op">{</span> <span class="cf">return</span> <span class="op">{}</span>; <span class="op">}</span></span>
<span id="cb20-11"><a href="#cb20-11"></a><span class="op">}</span>;</span></code></pre></div>
<p>You might think <code class="sourceCode cpp">zentinel</code> is a strange type (why does it compare to <code class="sourceCode cpp"><span class="dt">char</span><span class="op">*</span></code> instead of <code class="sourceCode cpp"><span class="dt">char</span> <span class="kw">const</span><span class="op">*</span></code> when it clearly does not need mutability), but the important thing is that this is a perfectly valid range. <code class="sourceCode cpp">zsentinel</code> does model <code class="sourceCode cpp">sentinel_for<span class="op">&lt;</span><span class="dt">char</span><span class="op">*&gt;</span></code>, and <code class="sourceCode cpp">zstring</code> does model <code class="sourceCode cpp">contiguous_range</code>. As such, it is important that the facilities in this paper <em>work</em>; we need to be able to provide a constant iterator here such that we end up with a constant range.</p>
<p>But here, we would end up in a situation where, given a <code class="sourceCode cpp">zstring z</code>:</p>
<ul>
<li><code class="sourceCode cpp">cbegin<span class="op">(</span>z<span class="op">)</span></code> would return a <code class="sourceCode cpp"><span class="dt">char</span> <span class="kw">const</span><span class="op">*</span></code></li>
<li><code class="sourceCode cpp">cend<span class="op">(</span>z<span class="op">)</span></code> would return a <code class="sourceCode cpp">zsentinel</code> (<code class="sourceCode cpp">zsentinel</code> is not an iterator, so we do not wrap it)</li>
</ul>
<p>But while <code class="sourceCode cpp">zsentinel</code> models <code class="sourceCode cpp">sentinel_for<span class="op">&lt;</span><span class="dt">char</span><span class="op">*&gt;</span></code> and I can ensure in the implementation of <code class="sourceCode cpp">const_iterator<span class="op">&lt;</span>T<span class="op">&gt;</span></code> that <code class="sourceCode cpp">zsentinel</code> also models <code class="sourceCode cpp">sentinel_for<span class="op">&lt;</span>const_iterator<span class="op">&lt;</span><span class="dt">char</span><span class="op">*&gt;&gt;</span></code>, it is not the case that <code class="sourceCode cpp">zsentinel</code> models <code class="sourceCode cpp">sentinel_for<span class="op">&lt;</span><span class="dt">char</span> <span class="kw">const</span><span class="op">*&gt;</span></code>. So we would not end up with a range at all!</p>
<p>It is possible to work around this problem by adding more complexity.</p>
<p>We could add complexity to <code class="sourceCode cpp">make_const_sentinel</code>, passing through the underlying iterator to be able to wrap <code class="sourceCode cpp">zsentinel</code> such that it performs a <code class="sourceCode cpp"><span class="kw">const_cast</span></code> internally. That is, <code class="sourceCode cpp">cend<span class="op">(</span>z<span class="op">)</span></code> would return a type like:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">struct</span> const_zsentinel <span class="op">{</span></span>
<span id="cb21-2"><a href="#cb21-2"></a>    zsentinel z;</span>
<span id="cb21-3"><a href="#cb21-3"></a></span>
<span id="cb21-4"><a href="#cb21-4"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">==(</span><span class="dt">char</span> <span class="kw">const</span><span class="op">*</span> p<span class="op">)</span> <span class="kw">const</span> <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb21-5"><a href="#cb21-5"></a>        <span class="cf">return</span> z <span class="op">==</span> <span class="kw">const_cast</span><span class="op">&lt;</span><span class="dt">char</span><span class="op">*&gt;(</span>p<span class="op">)</span>;</span>
<span id="cb21-6"><a href="#cb21-6"></a>    <span class="op">}</span></span>
<span id="cb21-7"><a href="#cb21-7"></a><span class="op">}</span>;</span></code></pre></div>
<p>Such a <code class="sourceCode cpp"><span class="kw">const_cast</span></code> would be safe since we know we must have originated from a <code class="sourceCode cpp"><span class="dt">char</span><span class="op">*</span></code> to begin with, if the <code class="sourceCode cpp"><span class="dt">char</span> <span class="kw">const</span><span class="op">*</span></code> we’re comparing originated from the <code class="sourceCode cpp">zstring</code>. But there are other <code class="sourceCode cpp"><span class="dt">char</span> <span class="kw">const</span><span class="op">*</span></code>s that don’t come from a <code class="sourceCode cpp">zstring</code>, that may not necessarily be safe to compare against, and now we’re supporting those. This also doesn’t generalize to any other kind of <code class="sourceCode cpp">make_const_iterator</code> customization: this implementation is specific to <code class="sourceCode cpp"><span class="kw">const_cast</span></code>, which is only valid for pointers. We would have to add something like a <code class="sourceCode cpp">const_iterator_cast</code>.</p>
<p>Let’s instead consider adding complexity in the other direction, to <code class="sourceCode cpp">make_const_iterator</code>. We can pass through the underlying sentinel such that we only turn <code class="sourceCode cpp"><span class="dt">char</span><span class="op">*</span></code> into <code class="sourceCode cpp"><span class="dt">char</span> <span class="kw">const</span><span class="op">*</span></code> if <code class="sourceCode cpp">S</code> satisfies <code class="sourceCode cpp">sentinel_for<span class="op">&lt;</span><span class="dt">char</span> <span class="kw">const</span><span class="op">*&gt;</span></code>, and otherwise turn <code class="sourceCode cpp"><span class="dt">char</span><span class="op">*</span></code> into <code class="sourceCode cpp">const_iterator<span class="op">&lt;</span><span class="dt">char</span><span class="op">*&gt;</span></code>. We could make this more specific and say that we turn <code class="sourceCode cpp"><span class="dt">char</span><span class="op">*</span></code>into <code class="sourceCode cpp"><span class="dt">char</span> <span class="kw">const</span><span class="op">*</span></code> only if <em>both</em> the <code class="sourceCode cpp">iterator</code> and <code class="sourceCode cpp">sentinel</code> types are <code class="sourceCode cpp"><span class="dt">char</span><span class="op">*</span></code>, but I don’t think the generalization that <code class="sourceCode cpp">sentinel_for<span class="op">&lt;</span><span class="dt">char</span> <span class="kw">const</span><span class="op">*&gt;</span></code> is sufficient.</p>
<p>This direction can be made to work and I think, overall, has fewer problems with the other direction. That is, something like this:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> S, std<span class="op">::</span>input_iterator It<span class="op">&gt;</span></span>
<span id="cb22-2"><a href="#cb22-2"></a>    <span class="kw">requires</span> std<span class="op">::</span>sentinel_for<span class="op">&lt;</span>S, I<span class="op">&gt;</span></span>
<span id="cb22-3"><a href="#cb22-3"></a><span class="kw">constexpr</span> <span class="kw">auto</span> make_const_iterator<span class="op">(</span>It it<span class="op">)</span> <span class="op">{</span></span>
<span id="cb22-4"><a href="#cb22-4"></a>    <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span>ConstantIterator<span class="op">&lt;</span>It<span class="op">&gt;)</span> <span class="op">{</span></span>
<span id="cb22-5"><a href="#cb22-5"></a>        <span class="cf">return</span> it;</span>
<span id="cb22-6"><a href="#cb22-6"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span>std<span class="op">::</span>is_pointer_v<span class="op">&lt;</span>It<span class="op">&gt;</span></span>
<span id="cb22-7"><a href="#cb22-7"></a>                     <span class="kw">and</span> std<span class="op">::</span>sentinel_for<span class="op">&lt;</span>S, std<span class="op">::</span>remove_pointer_t<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="kw">const</span><span class="op">*&gt;)</span> <span class="op">{</span></span>
<span id="cb22-8"><a href="#cb22-8"></a>        <span class="cf">return</span> <span class="kw">static_cast</span><span class="op">&lt;</span>std<span class="op">::</span>remove_pointer_t<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="kw">const</span><span class="op">*&gt;(</span>it<span class="op">)</span>;</span>
<span id="cb22-9"><a href="#cb22-9"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb22-10"><a href="#cb22-10"></a>        <span class="cf">return</span> basic_const_iterator<span class="op">&lt;</span>It<span class="op">&gt;(</span>it<span class="op">)</span>;</span>
<span id="cb22-11"><a href="#cb22-11"></a>    <span class="op">}</span></span>
<span id="cb22-12"><a href="#cb22-12"></a><span class="op">}</span></span></code></pre></div>
<p>But is it worth it?</p>
<p>A benefit might be that for a simple implementation of <code class="sourceCode cpp">span</code>, we could have this:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="kw">struct</span> simple_span <span class="op">{</span></span>
<span id="cb23-3"><a href="#cb23-3"></a>    <span class="kw">auto</span> begin<span class="op">()</span> <span class="kw">const</span> <span class="op">-&gt;</span> T<span class="op">*</span>;</span>
<span id="cb23-4"><a href="#cb23-4"></a>    <span class="kw">auto</span> end<span class="op">()</span> <span class="kw">const</span> <span class="op">-&gt;</span> T<span class="op">*</span>;</span>
<span id="cb23-5"><a href="#cb23-5"></a></span>
<span id="cb23-6"><a href="#cb23-6"></a>    <span class="kw">auto</span> cbegin<span class="op">()</span> <span class="kw">const</span> <span class="op">-&gt;</span> T <span class="kw">const</span><span class="op">*</span>;</span>
<span id="cb23-7"><a href="#cb23-7"></a>    <span class="kw">auto</span> cend<span class="op">()</span> <span class="kw">const</span> <span class="op">-&gt;</span> T <span class="kw">const</span><span class="op">*</span>;</span>
<span id="cb23-8"><a href="#cb23-8"></a><span class="op">}</span>;</span></code></pre></div>
<p>Which out of the box satisfies that <code class="sourceCode cpp">simple_span<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>cbegin<span class="op">()</span></code> and <code class="sourceCode cpp">cbegin<span class="op">(</span>simple_span<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;)</span></code> both give you an <code class="sourceCode cpp"><span class="dt">int</span> <span class="kw">const</span><span class="op">*</span></code>. Whereas, with the design presented up until now, member <code class="sourceCode cpp">cbegin</code> and <code class="sourceCode cpp">cend</code> would have to return <code class="sourceCode cpp">const_iterator<span class="op">&lt;</span>T<span class="op">*&gt;</span></code> instead.</p>
<p>I’m not sure it’s worth it. The simpler design is easier to understand. There’s something nice about <code class="sourceCode cpp">make_const_iterator</code> being able to act on an iterator in a vacuum, and being able to define <code class="sourceCode cpp">cbegin</code> simply as:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1"></a>make_const_iterator<span class="op">(</span>std<span class="op">::</span>ranges<span class="op">::</span>begin<span class="op">(</span>possibly_const<span class="op">(</span>r<span class="op">)))</span></span></code></pre></div>
<p>As opposed to:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1"></a><span class="kw">auto</span><span class="op">&amp;</span> cr <span class="op">=</span> possibly_const<span class="op">(</span>r<span class="op">)</span>;</span>
<span id="cb25-2"><a href="#cb25-2"></a>make_const_iterator<span class="op">&lt;</span>std<span class="op">::</span>ranges<span class="op">::</span>sentinel_t<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>cr<span class="op">)&gt;&gt;(</span>std<span class="op">::</span>ranges<span class="op">::</span>begin<span class="op">(</span>cr<span class="op">))</span></span></code></pre></div>
<p>and having to extend the alias template to:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1"></a><span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>input_iterator I, std<span class="op">::</span>sentinel_for<span class="op">&lt;</span>I<span class="op">&gt;</span> S <span class="op">=</span> I<span class="op">&gt;</span></span>
<span id="cb26-2"><a href="#cb26-2"></a><span class="kw">using</span> const_iterator <span class="op">=</span> <span class="kw">decltype</span><span class="op">(</span>make_const_iterator<span class="op">&lt;</span>S<span class="op">&gt;(</span>std<span class="op">::</span>declval<span class="op">&lt;</span>I<span class="op">&gt;()))</span>;</span></code></pre></div>
<p>which still allows <code class="sourceCode cpp">std<span class="op">::</span>const_iterator<span class="op">&lt;</span><span class="dt">int</span> <span class="kw">const</span><span class="op">*&gt;</span></code> to be <code class="sourceCode cpp"><span class="dt">int</span> <span class="kw">const</span><span class="op">*</span></code>. But I’m not sure it’s worth it for <em>just</em> the pointer case for <em>just</em> being able to define <code class="sourceCode cpp">simple_span</code>. In this model, <code class="sourceCode cpp">simple_span</code> wouldn’t even need to define member <code class="sourceCode cpp">cbegin</code>/<code class="sourceCode cpp">cend</code>, so why would it do so, and provide something different?</p>
<p>I could be convinced otherwise though.</p>
<h2 data-number="3.9" id="what-does-this-mean-for-spant"><span class="header-section-number">3.9</span> What does this mean for <code class="sourceCode cpp">span<span class="op">&lt;</span>T<span class="op">&gt;</span></code>?<a href="#what-does-this-mean-for-spant" class="self-link"></a></h2>
<p>There has been desire expressed to provide member <code class="sourceCode cpp">cbegin</code> for <code class="sourceCode cpp">span<span class="op">&lt;</span>T<span class="op">&gt;</span></code>. This paper allows a meaningful path to get there:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb27-2"><a href="#cb27-2"></a><span class="kw">struct</span> span <span class="op">{</span></span>
<span id="cb27-3"><a href="#cb27-3"></a>    <span class="kw">using</span> iterator <span class="op">=</span> <em>implementation-defined</em>;</span>
<span id="cb27-4"><a href="#cb27-4"></a>    <span class="kw">using</span> const_iterator <span class="op">=</span> std<span class="op">::</span>const_iterator<span class="op">&lt;</span>iterator<span class="op">&gt;</span>;</span>
<span id="cb27-5"><a href="#cb27-5"></a>    <span class="kw">using</span> reverse_iterator <span class="op">=</span> std<span class="op">::</span>reverse_iterator<span class="op">&lt;</span>iterator<span class="op">&gt;</span>;</span>
<span id="cb27-6"><a href="#cb27-6"></a>    <span class="kw">using</span> const_reverse_iterator <span class="op">=</span> std<span class="op">::</span>const_iterator<span class="op">&lt;</span>reverse_iterator<span class="op">&gt;</span>;</span>
<span id="cb27-7"><a href="#cb27-7"></a></span>
<span id="cb27-8"><a href="#cb27-8"></a>    <span class="kw">auto</span> begin<span class="op">()</span>   <span class="kw">const</span> <span class="kw">noexcept</span> <span class="op">-&gt;</span> iterator;</span>
<span id="cb27-9"><a href="#cb27-9"></a>    <span class="kw">auto</span> cbegin<span class="op">()</span>  <span class="kw">const</span> <span class="kw">noexcept</span> <span class="op">-&gt;</span> const_iterator;</span>
<span id="cb27-10"><a href="#cb27-10"></a>    <span class="kw">auto</span> rbegin<span class="op">()</span>  <span class="kw">const</span> <span class="kw">noexcept</span> <span class="op">-&gt;</span> reverse_iterator;</span>
<span id="cb27-11"><a href="#cb27-11"></a>    <span class="kw">auto</span> crbegin<span class="op">()</span> <span class="kw">const</span> <span class="kw">noexcept</span> <span class="op">-&gt;</span> const_reverse_iterator;</span>
<span id="cb27-12"><a href="#cb27-12"></a></span>
<span id="cb27-13"><a href="#cb27-13"></a>    <span class="co">// similar for end</span></span>
<span id="cb27-14"><a href="#cb27-14"></a><span class="op">}</span>;</span></code></pre></div>
<p>The above design ensures that given a <code class="sourceCode cpp">span<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> s</code> (or really, for any <code class="sourceCode cpp">T</code> that is non-<code class="sourceCode cpp"><span class="kw">const</span></code>):</p>
<ol type="1">
<li><code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>begin<span class="op">(</span>s<span class="op">)</span></code> and <code class="sourceCode cpp">s<span class="op">.</span>begin<span class="op">()</span></code> have the same type</li>
<li><code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin<span class="op">(</span>s<span class="op">)</span></code> and <code class="sourceCode cpp">s<span class="op">.</span>cbegin<span class="op">()</span></code> have the same type</li>
<li><code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>rbegin<span class="op">(</span>s<span class="op">)</span></code> and <code class="sourceCode cpp">s<span class="op">.</span>rbegin<span class="op">()</span></code> have the same type</li>
<li><code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>crbegin<span class="op">(</span>s<span class="op">)</span></code> and <code class="sourceCode cpp">s<span class="op">.</span>crbegin<span class="op">()</span></code> have the same type</li>
</ol>
<p>All without having to add new customization points to the standard library. Notably, <code class="sourceCode cpp">span<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>const_iterator</code> and <code class="sourceCode cpp">span<span class="op">&lt;</span><span class="dt">int</span> <span class="kw">const</span><span class="op">&gt;::</span>iterator</code> will not be the same type (which arguably a good thing). But <code class="sourceCode cpp">span<span class="op">&lt;</span><span class="dt">int</span> <span class="kw">const</span><span class="op">&gt;::</span>iterator</code> and <code class="sourceCode cpp">span<span class="op">&lt;</span><span class="dt">int</span> <span class="kw">const</span><span class="op">&gt;::</span>const_iterator</code> will be the same type (which is important).</p>
<p>The one tricky part here is <code class="sourceCode cpp">const_reverse_iterator</code>. For all the containers currently in the standard library, we define <code class="sourceCode cpp">const_reverse_iterator</code> as <code class="sourceCode cpp">std<span class="op">::</span>reverse_iterator<span class="op">&lt;</span>const_iterator<span class="op">&gt;</span></code>, but if we did that here, we’d end up with a mismatch in (4): <code class="sourceCode cpp">crbegin<span class="op">(</span>s<span class="op">)</span></code> would return a <code class="sourceCode cpp">const_iterator<span class="op">&lt;</span>reverse_iterator<span class="op">&lt;</span>iterator<span class="op">&gt;&gt;</span></code> while <code class="sourceCode cpp">s<span class="op">.</span>crbegin<span class="op">()</span></code> would return a <code class="sourceCode cpp">reverse_iterator<span class="op">&lt;</span>const_iterator<span class="op">&lt;</span>iterator<span class="op">&gt;&gt;</span></code>. We end up applying the layers in a different order.</p>
<p>But this is fine. None of these member functions are even strictly necessary, and there isn’t any need for future shallow-const views to provide them. If we want to duplicate already-existing functionality, we should just make sure that we duplicate it consistently, rather than inconsistently.</p>
<h1 data-number="4" style="border-bottom:1px solid #cccccc" id="act-v-a-concluding-proposal"><span class="header-section-number">4</span> Act V: A Concluding Proposal<a href="#act-v-a-concluding-proposal" class="self-link"></a></h1>
<p>The status quo is that we have an algorithm named <code class="sourceCode cpp">cbegin</code> whose job is to provide a constant iterator, but it does not always do that, and sometimes it doesn’t even provide a mutable iterator. This is an unfortunate situation.</p>
<p>We can resolve this by extending <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cend</code> to conditionally wrap their provided range’s <code class="sourceCode cpp">iterator</code>/<code class="sourceCode cpp">sentinel</code> pairs to ensure that the result is a constant iterator, and use these tools to build up a <code class="sourceCode cpp">views<span class="op">::</span>all_const</code> range adapter. This completely solves the problem without any imposed boilerplate per range.</p>
<p>However, <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>cend</code> are harder to extend. If we changed them at all, we would probably punt on handling C++17 input iterators and non-<code class="sourceCode cpp"><span class="kw">const</span></code>-iterable ranges. This means that <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin</code> do different things, but <code class="sourceCode cpp">std<span class="op">::</span>rbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>rbegin</code> <em>already</em> do different things. <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>rbegin</code> is already a superior <code class="sourceCode cpp">std<span class="op">::</span>rbegin</code>, so having <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin</code> be a superior <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> only follows from that. In other words, <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> is constrained to not deviate too much from its current behavior, whereas <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin</code> is new and Can Do Better.</p>
<p>Would it be worth making such a change to <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code>? I don’t think so, and this paper doesn’t propose any.</p>
<p>This paper also proposes adding member <code class="sourceCode cpp">c<span class="op">{</span>,r<span class="op">}{</span>begin,end<span class="op">}</span></code> to <code class="sourceCode cpp">span</code> and member <code class="sourceCode cpp">c<span class="op">{</span>begin,end<span class="op">}</span></code> (but not <code class="sourceCode cpp">cr<span class="op">{</span>begin,end<span class="op">}</span></code>) to <code class="sourceCode cpp">ranges<span class="op">::</span>view_interface</code> so that all the range adaptors the standard library (and user-defined range adaptors) pick those up as well.</p>
<h2 data-number="4.1" id="wording"><span class="header-section-number">4.1</span> Wording<a href="#wording" class="self-link"></a></h2>
<h3 data-number="4.1.1" id="span"><span class="header-section-number">4.1.1</span> Span<a href="#span" class="self-link"></a></h3>
<p>Assuming we want to add member <code class="sourceCode cpp">cmeow</code> to span, the following would ensure that <code class="sourceCode cpp">ranges<span class="op">::</span>cmeow<span class="op">(</span>s<span class="op">)</span></code> and <code class="sourceCode cpp">s<span class="op">.</span>cmeow<span class="op">()</span></code> all return the same thing. This effectively reverts <span class="citation" data-cites="LWG3320">[<a href="#ref-LWG3320" role="doc-biblioref">LWG3320</a>]</span>. <span class="draftnote" style="color: #01796F">[ Drafting note: While typically in the standard library, <code class="sourceCode cpp">const_reverse_iterator</code> is an alias for <code class="sourceCode cpp">std<span class="op">::</span>reverse_iterator<span class="op">&lt;</span>const_iterator<span class="op">&gt;</span></code>, here it is flipped, because <code class="sourceCode cpp">ranges<span class="op">::</span>rbegin</code> will attempt to call member <code class="sourceCode cpp">rbegin</code> but <code class="sourceCode cpp">ranges<span class="op">::</span>cbegin</code> will not. So this ensures that the algorithms and members reutrn the same thing ]</span></p>
<p>Add to the synopsis in <span>22.7.3.1 <a href="https://wg21.link/span.overview">[span.overview]</a></span>:</p>
<blockquote>
<div>
<div class="sourceCode" id="cb28"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb28-1"><a href="#cb28-1"></a>namespace std {</span>
<span id="cb28-2"><a href="#cb28-2"></a>  template&lt;class ElementType, size_t Extent = dynamic_extent&gt;</span>
<span id="cb28-3"><a href="#cb28-3"></a>  class span {</span>
<span id="cb28-4"><a href="#cb28-4"></a>  public:</span>
<span id="cb28-5"><a href="#cb28-5"></a>    // constants and types</span>
<span id="cb28-6"><a href="#cb28-6"></a>    using element_type = ElementType;</span>
<span id="cb28-7"><a href="#cb28-7"></a>    using value_type = remove_cv_t&lt;ElementType&gt;;</span>
<span id="cb28-8"><a href="#cb28-8"></a>    using size_type = size_t;</span>
<span id="cb28-9"><a href="#cb28-9"></a>    using difference_type = ptrdiff_t;</span>
<span id="cb28-10"><a href="#cb28-10"></a>    using pointer = element_type*;</span>
<span id="cb28-11"><a href="#cb28-11"></a>    using const_pointer = const element_type*;</span>
<span id="cb28-12"><a href="#cb28-12"></a>    using reference = element_type&amp;;</span>
<span id="cb28-13"><a href="#cb28-13"></a>    using const_reference = const element_type&amp;;</span>
<span id="cb28-14"><a href="#cb28-14"></a>    using iterator = <em>implementation-defined</em>;        // see [span.iterators]</span>
<span id="cb28-15"><a href="#cb28-15"></a><span class="va">+   using const_iterator = std::const_iterator&lt;iterator&gt;;</span></span>
<span id="cb28-16"><a href="#cb28-16"></a>    using reverse_iterator = std::reverse_iterator&lt;iterator&gt;;</span>
<span id="cb28-17"><a href="#cb28-17"></a><span class="va">+   using const_reverse_iterator = std::const_iterator&lt;reverse_iterator&gt;;</span></span>
<span id="cb28-18"><a href="#cb28-18"></a>    static constexpr size_type extent = Extent;</span>
<span id="cb28-19"><a href="#cb28-19"></a></span>
<span id="cb28-20"><a href="#cb28-20"></a>    // ...</span>
<span id="cb28-21"><a href="#cb28-21"></a></span>
<span id="cb28-22"><a href="#cb28-22"></a>    // [span.iterators], iterator support</span>
<span id="cb28-23"><a href="#cb28-23"></a>    constexpr iterator begin() const noexcept;</span>
<span id="cb28-24"><a href="#cb28-24"></a>    constexpr iterator end() const noexcept;</span>
<span id="cb28-25"><a href="#cb28-25"></a><span class="va">+   constexpr const_iterator cbegin() const noexcept { return const_iterator(begin()); }</span></span>
<span id="cb28-26"><a href="#cb28-26"></a><span class="va">+   constexpr const_iterator cend() const noexcept { return const_iterator(end()); }</span></span>
<span id="cb28-27"><a href="#cb28-27"></a>    constexpr reverse_iterator rbegin() const noexcept;</span>
<span id="cb28-28"><a href="#cb28-28"></a>    constexpr reverse_iterator rend() const noexcept;</span>
<span id="cb28-29"><a href="#cb28-29"></a><span class="va">+   constexpr const_reverse_iterator crbegin() const noexcept { return const_reverse_iterator(rbegin()); }</span></span>
<span id="cb28-30"><a href="#cb28-30"></a><span class="va">+   constexpr const_reverse_iterator crend() const noexcept { return const_reverse_iterator(rend()); }</span></span>
<span id="cb28-31"><a href="#cb28-31"></a></span>
<span id="cb28-32"><a href="#cb28-32"></a>  private:</span>
<span id="cb28-33"><a href="#cb28-33"></a>    pointer data_;              // exposition only</span>
<span id="cb28-34"><a href="#cb28-34"></a>    size_type size_;            // exposition only</span>
<span id="cb28-35"><a href="#cb28-35"></a>  };</span>
<span id="cb28-36"><a href="#cb28-36"></a></span>
<span id="cb28-37"><a href="#cb28-37"></a>  // ...</span>
<span id="cb28-38"><a href="#cb28-38"></a>}</span></code></pre></div>
</div>
</blockquote>
<h3 data-number="4.1.2" id="iterators"><span class="header-section-number">4.1.2</span> Iterators<a href="#iterators" class="self-link"></a></h3>
<p>Add to <span>23.2 <a href="https://wg21.link/iterator.synopsis">[iterator.synopsis]</a></span>:</p>
<blockquote>
<div>
<div class="sourceCode" id="cb29"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb29-1"><a href="#cb29-1"></a>#include &lt;compare&gt;              // see [compare.syn]</span>
<span id="cb29-2"><a href="#cb29-2"></a>#include &lt;concepts&gt;             // see [concepts.syn]</span>
<span id="cb29-3"><a href="#cb29-3"></a></span>
<span id="cb29-4"><a href="#cb29-4"></a>namespace std {</span>
<span id="cb29-5"><a href="#cb29-5"></a>  // ...</span>
<span id="cb29-6"><a href="#cb29-6"></a>  // [insert.iterators], insert iterators</span>
<span id="cb29-7"><a href="#cb29-7"></a>  template&lt;class Container&gt; class back_insert_iterator;</span>
<span id="cb29-8"><a href="#cb29-8"></a>  template&lt;class Container&gt;</span>
<span id="cb29-9"><a href="#cb29-9"></a>    constexpr back_insert_iterator&lt;Container&gt; back_inserter(Container&amp; x);</span>
<span id="cb29-10"><a href="#cb29-10"></a></span>
<span id="cb29-11"><a href="#cb29-11"></a>  template&lt;class Container&gt; class front_insert_iterator;</span>
<span id="cb29-12"><a href="#cb29-12"></a>  template&lt;class Container&gt;</span>
<span id="cb29-13"><a href="#cb29-13"></a>    constexpr front_insert_iterator&lt;Container&gt; front_inserter(Container&amp; x);</span>
<span id="cb29-14"><a href="#cb29-14"></a></span>
<span id="cb29-15"><a href="#cb29-15"></a>  template&lt;class Container&gt; class insert_iterator;</span>
<span id="cb29-16"><a href="#cb29-16"></a>  template&lt;class Container&gt;</span>
<span id="cb29-17"><a href="#cb29-17"></a>    constexpr insert_iterator&lt;Container&gt;</span>
<span id="cb29-18"><a href="#cb29-18"></a>      inserter(Container&amp; x, ranges::iterator_t&lt;Container&gt; i);</span>
<span id="cb29-19"><a href="#cb29-19"></a></span>
<span id="cb29-20"><a href="#cb29-20"></a><span class="va">+ // [const.iterators], constant iterators and sentinels</span></span>
<span id="cb29-21"><a href="#cb29-21"></a><span class="va">+ template &lt;indirectly_readable I&gt;</span></span>
<span id="cb29-22"><a href="#cb29-22"></a><span class="va">+   using iter_const_reference_t = <em>see below</em>;</span></span>
<span id="cb29-23"><a href="#cb29-23"></a><span class="va">+ template&lt;class Iterator&gt;</span></span>
<span id="cb29-24"><a href="#cb29-24"></a><span class="va">+   concept <em>constant-iterator</em> = <em>see below</em>; // exposition only</span></span>
<span id="cb29-25"><a href="#cb29-25"></a><span class="va">+</span></span>
<span id="cb29-26"><a href="#cb29-26"></a><span class="va">+ template&lt;class Iterator&gt;</span></span>
<span id="cb29-27"><a href="#cb29-27"></a><span class="va">+   class basic_const_iterator;</span></span>
<span id="cb29-28"><a href="#cb29-28"></a><span class="va">+</span></span>
<span id="cb29-29"><a href="#cb29-29"></a><span class="va">+ template&lt;typename T, common_with&lt;T&gt; U&gt;</span></span>
<span id="cb29-30"><a href="#cb29-30"></a><span class="va">+ struct common_type&lt;basic_const_iterator&lt;T&gt;, U&gt; {</span></span>
<span id="cb29-31"><a href="#cb29-31"></a><span class="va">+   using type = basic_const_iterator&lt;common_type_t&lt;T, U&gt;&gt;;</span></span>
<span id="cb29-32"><a href="#cb29-32"></a><span class="va">+ };</span></span>
<span id="cb29-33"><a href="#cb29-33"></a><span class="va">+ template&lt;typename T, common_with&lt;T&gt; U&gt;</span></span>
<span id="cb29-34"><a href="#cb29-34"></a><span class="va">+ struct common_type&lt;U, basic_const_iterator&lt;T&gt;&gt; {</span></span>
<span id="cb29-35"><a href="#cb29-35"></a><span class="va">+   using type = basic_const_iterator&lt;common_type_t&lt;T, U&gt;&gt;;</span></span>
<span id="cb29-36"><a href="#cb29-36"></a><span class="va">+ };</span></span>
<span id="cb29-37"><a href="#cb29-37"></a><span class="va">+ template&lt;typename T, common_with&lt;T&gt; U&gt;</span></span>
<span id="cb29-38"><a href="#cb29-38"></a><span class="va">+ struct common_type&lt;basic_const_iterator&lt;T&gt;, basic_const_iterator&lt;U&gt;&gt; {</span></span>
<span id="cb29-39"><a href="#cb29-39"></a><span class="va">+   using type = basic_const_iterator&lt;common_type_t&lt;T, U&gt;&gt;;</span></span>
<span id="cb29-40"><a href="#cb29-40"></a><span class="va">+ };</span></span>
<span id="cb29-41"><a href="#cb29-41"></a><span class="va">+</span></span>
<span id="cb29-42"><a href="#cb29-42"></a><span class="va">+ template&lt;input_iterator I&gt;</span></span>
<span id="cb29-43"><a href="#cb29-43"></a><span class="va">+ constexpr auto make_const_iterator(I it);</span></span>
<span id="cb29-44"><a href="#cb29-44"></a><span class="va">+</span></span>
<span id="cb29-45"><a href="#cb29-45"></a><span class="va">+ template&lt;typename S&gt;</span></span>
<span id="cb29-46"><a href="#cb29-46"></a><span class="va">+ constexpr auto make_const_sentinel(S s);</span></span>
<span id="cb29-47"><a href="#cb29-47"></a><span class="va">+</span></span>
<span id="cb29-48"><a href="#cb29-48"></a><span class="va">+ template&lt;class I&gt;</span></span>
<span id="cb29-49"><a href="#cb29-49"></a><span class="va">+   using const_iterator = decltype(make_const_iterator(declval&lt;I&gt;()));</span></span>
<span id="cb29-50"><a href="#cb29-50"></a></span>
<span id="cb29-51"><a href="#cb29-51"></a>  // [move.iterators], move iterators and sentinels</span>
<span id="cb29-52"><a href="#cb29-52"></a>  template&lt;class Iterator&gt; class move_iterator;</span>
<span id="cb29-53"><a href="#cb29-53"></a>  // ...</span>
<span id="cb29-54"><a href="#cb29-54"></a>}</span></code></pre></div>
</div>
</blockquote>
<p>Add definitions for all this stuff in the new clause [const.iterators], ahead of [move.iterators]:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_1" id="pnum_1">1</a></span> Class template <code class="sourceCode cpp">basic_const_iterator</code> is an iterator adaptor with the same behavior as the underlying iterator except that its indirection operator implicitly converts the value returned by the underlying iterator’s indirection operator to a type such that the adapted iterator is a constant iterator ([iterator.requirements]). Some generic algorithms can be called with constant iterators to avoid mutation.</p>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_2" id="pnum_2">2</a></span> The type <code class="sourceCode cpp">const_iterator<span class="op">&lt;</span>I<span class="op">&gt;</span></code>, for an underlying iterator <code class="sourceCode cpp">I</code>, is a constant iterator.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1"></a><span class="kw">template</span> <span class="op">&lt;</span>indirectly_readable It<span class="op">&gt;</span></span>
<span id="cb30-2"><a href="#cb30-2"></a>  <span class="kw">using</span> iter_const_reference_t <span class="op">=</span> common_reference_t<span class="op">&lt;</span>iter_value_t<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;&amp;</span>, iter_reference_t<span class="op">&lt;</span>It<span class="op">&gt;&gt;</span>;</span>
<span id="cb30-3"><a href="#cb30-3"></a></span>
<span id="cb30-4"><a href="#cb30-4"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> It<span class="op">&gt;</span></span>
<span id="cb30-5"><a href="#cb30-5"></a><span class="kw">concept</span> <em>constant-iterator</em> <span class="op">=</span> input_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span></span>
<span id="cb30-6"><a href="#cb30-6"></a>                         <span class="op">&amp;&amp;</span> same_as<span class="op">&lt;</span>iter_const_reference_t<span class="op">&lt;</span>It<span class="op">&gt;</span>, iter_reference_t<span class="op">&lt;</span>It<span class="op">&gt;&gt;</span>;</span>
<span id="cb30-7"><a href="#cb30-7"></a></span>
<span id="cb30-8"><a href="#cb30-8"></a><span class="kw">template</span><span class="op">&lt;</span>input_iterator I<span class="op">&gt;</span></span>
<span id="cb30-9"><a href="#cb30-9"></a><span class="kw">constexpr</span> <span class="kw">auto</span> make_const_iterator<span class="op">(</span>I it<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_3" id="pnum_3">3</a></span> <em>Returns</em>: If <code class="sourceCode cpp">I</code> satisfies <code class="sourceCode cpp"><em>constant-iterator</em></code>, <code class="sourceCode cpp">it</code>. Otherwise, <code class="sourceCode cpp">basic_const_iterator<span class="op">&lt;</span>I<span class="op">&gt;(</span>std<span class="op">::</span>move<span class="op">(</span>it<span class="op">))</span></code>.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> S<span class="op">&gt;</span></span>
<span id="cb31-2"><a href="#cb31-2"></a><span class="kw">constexpr</span> <span class="kw">auto</span> make_const_sentinel<span class="op">(</span>S s<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_4" id="pnum_4">4</a></span> <em>Returns</em>: If <code class="sourceCode cpp">S</code> satisfies <code class="sourceCode cpp">input_iterator</code>, <code class="sourceCode cpp">make_const_iterator<span class="op">(</span>std<span class="op">::</span>move<span class="op">(</span>s<span class="op">))</span></code>. Otherwise, <code class="sourceCode cpp">s</code>.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1"></a><span class="kw">template</span> <span class="op">&lt;</span>input_iterator Iterator<span class="op">&gt;</span></span>
<span id="cb32-2"><a href="#cb32-2"></a><span class="kw">class</span> basic_const_iterator</span>
<span id="cb32-3"><a href="#cb32-3"></a><span class="op">{</span></span>
<span id="cb32-4"><a href="#cb32-4"></a>    Iterator <em>current_</em> <span class="op">=</span> Iterator<span class="op">()</span>;</span>
<span id="cb32-5"><a href="#cb32-5"></a></span>
<span id="cb32-6"><a href="#cb32-6"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb32-7"><a href="#cb32-7"></a>    <span class="kw">using</span> iterator_concept <span class="op">=</span> <em>see below</em>;</span>
<span id="cb32-8"><a href="#cb32-8"></a>    <span class="kw">using</span> iterator_category <span class="op">=</span> <em>see below</em>; <span class="co">// not always present</span></span>
<span id="cb32-9"><a href="#cb32-9"></a>    <span class="kw">using</span> value_type <span class="op">=</span> iter_value_t<span class="op">&lt;</span>Iterator<span class="op">&gt;</span>;</span>
<span id="cb32-10"><a href="#cb32-10"></a>    <span class="kw">using</span> difference_type <span class="op">=</span> iter_difference_t<span class="op">&lt;</span>Iterator<span class="op">&gt;</span>;</span>
<span id="cb32-11"><a href="#cb32-11"></a></span>
<span id="cb32-12"><a href="#cb32-12"></a>    basic_const_iterator<span class="op">()</span> <span class="kw">requires</span> default_initializeable<span class="op">&lt;</span>Iterator<span class="op">&gt;</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb32-13"><a href="#cb32-13"></a>    <span class="kw">constexpr</span> basic_const_iterator<span class="op">(</span>Iterator current<span class="op">)</span>;</span>
<span id="cb32-14"><a href="#cb32-14"></a>    <span class="kw">template</span> <span class="op">&lt;</span>convertible_to<span class="op">&lt;</span>It<span class="op">&gt;</span> U<span class="op">&gt;</span></span>
<span id="cb32-15"><a href="#cb32-15"></a>      <span class="kw">constexpr</span> basic_const_iterator<span class="op">(</span>basic_const_iterator<span class="op">&lt;</span>U<span class="op">&gt;</span> current<span class="op">)</span>;</span>
<span id="cb32-16"><a href="#cb32-16"></a>    <span class="kw">template</span> <span class="op">&lt;</span>convertible_to<span class="op">&lt;</span>It<span class="op">&gt;</span> T<span class="op">&gt;</span></span>
<span id="cb32-17"><a href="#cb32-17"></a>      <span class="kw">constexpr</span> basic_const_iterator<span class="op">(</span>T<span class="op">&amp;&amp;</span> current<span class="op">)</span>;</span>
<span id="cb32-18"><a href="#cb32-18"></a></span>
<span id="cb32-19"><a href="#cb32-19"></a>    <span class="kw">constexpr</span> <span class="kw">const</span> Iterator<span class="op">&amp;</span> base<span class="op">()</span> <span class="kw">const</span><span class="op">&amp;</span> <span class="kw">noexcept</span>;</span>
<span id="cb32-20"><a href="#cb32-20"></a>    <span class="kw">constexpr</span> Iterator base<span class="op">()</span> <span class="op">&amp;&amp;</span>;</span>
<span id="cb32-21"><a href="#cb32-21"></a></span>
<span id="cb32-22"><a href="#cb32-22"></a>    <span class="kw">constexpr</span> <span class="kw">decltype</span><span class="op">(</span><span class="kw">auto</span><span class="op">)</span> <span class="kw">operator</span><span class="op">*()</span> <span class="kw">const</span>;</span>
<span id="cb32-23"><a href="#cb32-23"></a>    <span class="kw">constexpr</span> <span class="kw">const</span> value_type<span class="op">*</span> <span class="kw">operator</span><span class="op">-&gt;()</span> <span class="kw">const</span> <span class="kw">requires</span> contiguous_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span>;</span>
<span id="cb32-24"><a href="#cb32-24"></a></span>
<span id="cb32-25"><a href="#cb32-25"></a>    <span class="kw">constexpr</span> basic_const_iterator<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">++()</span>;</span>
<span id="cb32-26"><a href="#cb32-26"></a>    <span class="kw">constexpr</span> <span class="dt">void</span> <span class="kw">operator</span><span class="op">++(</span><span class="dt">int</span><span class="op">)</span>;</span>
<span id="cb32-27"><a href="#cb32-27"></a>    <span class="kw">constexpr</span> basic_const_iterator <span class="kw">operator</span><span class="op">++(</span><span class="dt">int</span><span class="op">)</span> <span class="kw">requires</span> forward_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span>;</span>
<span id="cb32-28"><a href="#cb32-28"></a></span>
<span id="cb32-29"><a href="#cb32-29"></a>    <span class="kw">constexpr</span> basic_const_iterator<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">--()</span> <span class="kw">requires</span> bidirectional_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span>;</span>
<span id="cb32-30"><a href="#cb32-30"></a>    <span class="kw">constexpr</span> basic_const_iterator <span class="kw">operator</span><span class="op">--(</span><span class="dt">int</span><span class="op">)</span> <span class="kw">requires</span> bidirectional_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span>;</span>
<span id="cb32-31"><a href="#cb32-31"></a></span>
<span id="cb32-32"><a href="#cb32-32"></a>    <span class="kw">constexpr</span> basic_const_iterator<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">+=(</span>difference_type n<span class="op">)</span> <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span>;</span>
<span id="cb32-33"><a href="#cb32-33"></a>    <span class="kw">constexpr</span> basic_const_iterator<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">-=(</span>difference_type n<span class="op">)</span> <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span>;</span>
<span id="cb32-34"><a href="#cb32-34"></a></span>
<span id="cb32-35"><a href="#cb32-35"></a>    <span class="kw">constexpr</span> <span class="kw">decltype</span><span class="op">(</span><span class="kw">auto</span><span class="op">)</span> <span class="kw">operator</span><span class="op">[](</span>difference_type n<span class="op">)</span> <span class="kw">const</span> <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span>;</span>
<span id="cb32-36"><a href="#cb32-36"></a></span>
<span id="cb32-37"><a href="#cb32-37"></a>    <span class="kw">template</span> <span class="op">&lt;</span>sentinel_for<span class="op">&lt;</span>Iterator<span class="op">&gt;</span> S<span class="op">&gt;</span></span>
<span id="cb32-38"><a href="#cb32-38"></a>    <span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> x, <span class="kw">const</span> S<span class="op">&amp;</span> s<span class="op">)</span>;</span>
<span id="cb32-39"><a href="#cb32-39"></a></span>
<span id="cb32-40"><a href="#cb32-40"></a>    <span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;(</span><span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> x, <span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb32-41"><a href="#cb32-41"></a>      <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span>;</span>
<span id="cb32-42"><a href="#cb32-42"></a>    <span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;(</span><span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> x, <span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb32-43"><a href="#cb32-43"></a>      <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span>;</span>
<span id="cb32-44"><a href="#cb32-44"></a>    <span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;=(</span><span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> x, <span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb32-45"><a href="#cb32-45"></a>      <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span>;</span>
<span id="cb32-46"><a href="#cb32-46"></a>    <span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;=(</span><span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> x, <span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb32-47"><a href="#cb32-47"></a>      <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span>;</span>
<span id="cb32-48"><a href="#cb32-48"></a>    <span class="kw">friend</span> <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">&lt;=&gt;(</span><span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> x, <span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb32-49"><a href="#cb32-49"></a>      <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> three_way_comparable<span class="op">&lt;</span>Iterator<span class="op">&gt;</span>;</span>
<span id="cb32-50"><a href="#cb32-50"></a></span>
<span id="cb32-51"><a href="#cb32-51"></a>    <span class="kw">template</span> <span class="op">&lt;</span><em>not-same-as</em><span class="op">&lt;</span>basic_const_iterator<span class="op">&gt;</span> I<span class="op">&gt;</span></span>
<span id="cb32-52"><a href="#cb32-52"></a>      <span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;(</span><span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> x, <span class="kw">const</span> I<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb32-53"><a href="#cb32-53"></a>        <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> totally_ordered_with<span class="op">&lt;</span>Iterator, I<span class="op">&gt;</span>;</span>
<span id="cb32-54"><a href="#cb32-54"></a>    <span class="kw">template</span> <span class="op">&lt;</span><em>not-same-as</em><span class="op">&lt;</span>basic_const_iterator<span class="op">&gt;</span> I<span class="op">&gt;</span></span>
<span id="cb32-55"><a href="#cb32-55"></a>      <span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;(</span><span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> x, <span class="kw">const</span> I<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb32-56"><a href="#cb32-56"></a>        <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> totally_ordered_with<span class="op">&lt;</span>Iterator, I<span class="op">&gt;</span>;</span>
<span id="cb32-57"><a href="#cb32-57"></a>    <span class="kw">template</span> <span class="op">&lt;</span><em>not-same-as</em><span class="op">&lt;</span>basic_const_iterator<span class="op">&gt;</span> I<span class="op">&gt;</span></span>
<span id="cb32-58"><a href="#cb32-58"></a>      <span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;=(</span><span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> x, <span class="kw">const</span> I<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb32-59"><a href="#cb32-59"></a>        <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> totally_ordered_with<span class="op">&lt;</span>Iterator, I<span class="op">&gt;</span>;</span>
<span id="cb32-60"><a href="#cb32-60"></a>    <span class="kw">template</span> <span class="op">&lt;</span><em>not-same-as</em><span class="op">&lt;</span>basic_const_iterator<span class="op">&gt;</span> I<span class="op">&gt;</span></span>
<span id="cb32-61"><a href="#cb32-61"></a>      <span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;=(</span><span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> x, <span class="kw">const</span> I<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb32-62"><a href="#cb32-62"></a>        <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> totally_ordered_with<span class="op">&lt;</span>Iterator, I<span class="op">&gt;</span>;</span>
<span id="cb32-63"><a href="#cb32-63"></a>    <span class="kw">template</span> <span class="op">&lt;</span><em>not-same-as</em><span class="op">&lt;</span>basic_const_iterator<span class="op">&gt;</span> I<span class="op">&gt;</span></span>
<span id="cb32-64"><a href="#cb32-64"></a>      <span class="kw">friend</span> <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">&lt;=&gt;(</span><span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> x, <span class="kw">const</span> I<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb32-65"><a href="#cb32-65"></a>        <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span></span>
<span id="cb32-66"><a href="#cb32-66"></a>              <span class="op">&amp;&amp;</span> totally_ordered_with<span class="op">&lt;</span>Iterator, I<span class="op">&gt;</span></span>
<span id="cb32-67"><a href="#cb32-67"></a>              <span class="op">&amp;&amp;</span> three_way_comparable_with<span class="op">&lt;</span>Iterator, I<span class="op">&gt;</span>;</span>
<span id="cb32-68"><a href="#cb32-68"></a></span>
<span id="cb32-69"><a href="#cb32-69"></a>    <span class="kw">friend</span> <span class="kw">constexpr</span> basic_const_iterator <span class="kw">operator</span><span class="op">+(</span><span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> i, difference_type n<span class="op">)</span></span>
<span id="cb32-70"><a href="#cb32-70"></a>      <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span>;</span>
<span id="cb32-71"><a href="#cb32-71"></a>    <span class="kw">friend</span> <span class="kw">constexpr</span> basic_const_iterator <span class="kw">operator</span><span class="op">+(</span>difference_type n, <span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> i<span class="op">)</span></span>
<span id="cb32-72"><a href="#cb32-72"></a>      <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span>;</span>
<span id="cb32-73"><a href="#cb32-73"></a>    <span class="kw">friend</span> <span class="kw">constexpr</span> basic_const_iterator <span class="kw">operator</span><span class="op">-(</span><span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> i, difference_type n<span class="op">)</span></span>
<span id="cb32-74"><a href="#cb32-74"></a>      <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span>;</span>
<span id="cb32-75"><a href="#cb32-75"></a>    <span class="kw">friend</span> <span class="kw">constexpr</span> difference_type <span class="kw">operator</span><span class="op">-(</span><span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> x, basic_const_iterator<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb32-76"><a href="#cb32-76"></a>      <span class="kw">requires</span> sized_sentinel_for<span class="op">&lt;</span>Iterator, Iterator<span class="op">&gt;</span>;</span>
<span id="cb32-77"><a href="#cb32-77"></a><span class="op">}</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_5" id="pnum_5">5</a></span> <code class="sourceCode cpp">basic_const_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;::</span>iterator_concept</code> is defined as follows:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_6" id="pnum_6">(5.1)</a></span> If <code class="sourceCode cpp">Iterator</code> models <code class="sourceCode cpp">contiguous_iterator</code>, then <code class="sourceCode cpp">iterator_concept</code> denotes <code class="sourceCode cpp">contiguous_iterator_tag</code>.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_7" id="pnum_7">(5.2)</a></span> Otherwise, if <code class="sourceCode cpp">Iterator</code> models <code class="sourceCode cpp">random_access_iterator</code>, then <code class="sourceCode cpp">iterator_concept</code> denotes <code class="sourceCode cpp">random_access_iterator_tag</code>.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_8" id="pnum_8">(5.3)</a></span> Otherwise, if <code class="sourceCode cpp">Iterator</code> models <code class="sourceCode cpp">bidirectional_iterator</code>, then <code class="sourceCode cpp">iterator_concept</code> denotes <code class="sourceCode cpp">bidirectional_iterator_tag</code>.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_9" id="pnum_9">(5.4)</a></span> Otherwise, if <code class="sourceCode cpp">Iterator</code> models <code class="sourceCode cpp">forward_iterator</code>, then <code class="sourceCode cpp">iterator_concept</code> denotes <code class="sourceCode cpp">forward_iterator_tag</code>.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_10" id="pnum_10">(5.5)</a></span> Otherwise, <code class="sourceCode cpp">iterator_concept</code> denotes <code class="sourceCode cpp">input_iterator_tag</code>.</li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_11" id="pnum_11">6</a></span> The member <em>typedef-name</em> <code class="sourceCode cpp">iterator_category</code> is defined if and only if <code class="sourceCode cpp">Iterator</code> models <code class="sourceCode cpp">forward_iterator</code>. In that case, <code class="sourceCode cpp">basic_const_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;::</span>iterator_category</code> denotes the type <code class="sourceCode cpp">iterator_traits<span class="op">&lt;</span>Iterator<span class="op">&gt;::</span>iterator_category</code>.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1"></a><span class="kw">constexpr</span> basic_const_iterator<span class="op">(</span>Iterator current<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_12" id="pnum_12">7</a></span> <em>Effects</em>: Initializes <code class="sourceCode cpp"><em>current_</em></code> with <code class="sourceCode cpp">std<span class="op">::</span>move<span class="op">(</span>current<span class="op">)</span></code>.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1"></a><span class="kw">template</span> <span class="op">&lt;</span>convertible_to<span class="op">&lt;</span>It<span class="op">&gt;</span> U<span class="op">&gt;</span></span>
<span id="cb34-2"><a href="#cb34-2"></a>  <span class="kw">constexpr</span> basic_const_iterator<span class="op">(</span>basic_const_iterator<span class="op">&lt;</span>U<span class="op">&gt;</span> current<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_13" id="pnum_13">8</a></span> <em>Effects</em>: Initializes <code class="sourceCode cpp"><em>current_</em></code> with <code class="sourceCode cpp">std<span class="op">::</span>move<span class="op">(</span>current<span class="op">.</span><em>current_</em><span class="op">)</span></code>.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1"></a><span class="kw">template</span> <span class="op">&lt;</span>convertible_to<span class="op">&lt;</span>It<span class="op">&gt;</span> T<span class="op">&gt;</span></span>
<span id="cb35-2"><a href="#cb35-2"></a>  <span class="kw">constexpr</span> basic_const_iterator<span class="op">(</span>T<span class="op">&amp;&amp;</span> current<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_14" id="pnum_14">9</a></span> <em>Effects</em>: Initializes <code class="sourceCode cpp"><em>current_</em></code> with <code class="sourceCode cpp">std<span class="op">::</span>forward<span class="op">&lt;</span>T<span class="op">&gt;(</span>current<span class="op">)</span></code>.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1"></a><span class="kw">constexpr</span> <span class="kw">const</span> Iterator<span class="op">&amp;</span> base<span class="op">()</span> <span class="kw">const</span><span class="op">&amp;</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_15" id="pnum_15">10</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> <em>current_</em>;</code></p>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1"></a><span class="kw">constexpr</span> Iterator base<span class="op">()</span> <span class="op">&amp;&amp;</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_16" id="pnum_16">11</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> std<span class="op">::</span>move<span class="op">(</span><em>current_</em><span class="op">)</span>;</code></p>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1"></a><span class="kw">constexpr</span> <span class="kw">decltype</span><span class="op">(</span><span class="kw">auto</span><span class="op">)</span> <span class="kw">operator</span><span class="op">*()</span> <span class="kw">const</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_17" id="pnum_17">12</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> <span class="op">*</span><em>current_</em>;</code></p>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1"></a><span class="kw">constexpr</span> <span class="kw">const</span> value_type<span class="op">*</span> <span class="kw">operator</span><span class="op">-&gt;()</span> <span class="kw">const</span> <span class="kw">requires</span> contiguous_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_18" id="pnum_18">13</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> to_address<span class="op">(</span><em>current_</em><span class="op">)</span>;</code></p>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1"></a><span class="kw">constexpr</span> basic_const_iterator<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">++()</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_19" id="pnum_19">14</a></span> <em>Effects</em>: Equivalent to:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1"></a><span class="op">++</span><em>current_</em>;</span>
<span id="cb41-2"><a href="#cb41-2"></a><span class="cf">return</span> <span class="op">*</span><span class="kw">this</span>;</span></code></pre></div>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1"></a><span class="kw">constexpr</span> <span class="dt">void</span> <span class="kw">operator</span><span class="op">++(</span><span class="dt">int</span><span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_20" id="pnum_20">15</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="op">++</span><em>current_</em>;</code></p>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1"></a><span class="kw">constexpr</span> basic_const_iterator <span class="kw">operator</span><span class="op">++(</span><span class="dt">int</span><span class="op">)</span> <span class="kw">requires</span> forward_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_21" id="pnum_21">16</a></span> <em>Effects</em>: Equivalent to:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1"></a><span class="kw">auto</span> tmp <span class="op">=</span> <span class="op">*</span><span class="kw">this</span>;</span>
<span id="cb44-2"><a href="#cb44-2"></a><span class="op">++*</span><span class="kw">this</span>;</span>
<span id="cb44-3"><a href="#cb44-3"></a><span class="cf">return</span> tmp;</span></code></pre></div>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1"></a><span class="kw">constexpr</span> basic_const_iterator<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">--()</span> <span class="kw">requires</span> bidirectional_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_22" id="pnum_22">17</a></span> <em>Effects</em>: Equivalent to:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1"></a><span class="op">--</span><em>current_</em>;</span>
<span id="cb46-2"><a href="#cb46-2"></a><span class="cf">return</span> <span class="op">*</span><span class="kw">this</span>;</span></code></pre></div>
<div class="sourceCode" id="cb47"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1"></a><span class="kw">constexpr</span> basic_const_iterator <span class="kw">operator</span><span class="op">--(</span><span class="dt">int</span><span class="op">)</span> <span class="kw">requires</span> bidirectional_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_23" id="pnum_23">18</a></span> <em>Effects</em>: Equivalent to:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1"></a><span class="kw">auto</span> tmp <span class="op">=</span> <span class="op">*</span><span class="kw">this</span>;</span>
<span id="cb48-2"><a href="#cb48-2"></a><span class="op">--*</span><span class="kw">this</span>;</span>
<span id="cb48-3"><a href="#cb48-3"></a><span class="cf">return</span> tmp;</span></code></pre></div>
<div class="sourceCode" id="cb49"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1"></a><span class="kw">constexpr</span> basic_const_iterator<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">+=(</span>difference_type n<span class="op">)</span> <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span>;</span>
<span id="cb49-2"><a href="#cb49-2"></a><span class="kw">constexpr</span> basic_const_iterator<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">-=(</span>difference_type n<span class="op">)</span> <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_24" id="pnum_24">19</a></span> Let <code class="sourceCode cpp"><em>op</em></code> be the operator.</p>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_25" id="pnum_25">20</a></span> <em>Effects</em>: Equivalent to:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb50-1"><a href="#cb50-1"></a><em>current_</em> <em>op</em> n;</span>
<span id="cb50-2"><a href="#cb50-2"></a>return *this;</span></code></pre></div>
<div class="sourceCode" id="cb51"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1"></a><span class="kw">constexpr</span> <span class="kw">decltype</span><span class="op">(</span><span class="kw">auto</span><span class="op">)</span> <span class="kw">operator</span><span class="op">[](</span>difference_type n<span class="op">)</span> <span class="kw">const</span> <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span></span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_26" id="pnum_26">21</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> <em>current_</em><span class="op">[</span>n<span class="op">]</span>;</code></p>
<div class="sourceCode" id="cb52"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1"></a><span class="kw">template</span> <span class="op">&lt;</span>sentinel_for<span class="op">&lt;</span>Iterator<span class="op">&gt;</span> S<span class="op">&gt;</span></span>
<span id="cb52-2"><a href="#cb52-2"></a><span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> x, <span class="kw">const</span> S<span class="op">&amp;</span> s<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_27" id="pnum_27">22</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> x<span class="op">.</span><em>current_</em> <span class="op">==</span> s;</code></p>
<div class="sourceCode" id="cb53"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1"></a><span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;(</span><span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> x, <span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb53-2"><a href="#cb53-2"></a>  <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span>;</span>
<span id="cb53-3"><a href="#cb53-3"></a><span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;(</span><span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> x, <span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb53-4"><a href="#cb53-4"></a>  <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span>;</span>
<span id="cb53-5"><a href="#cb53-5"></a><span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;=(</span><span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> x, <span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb53-6"><a href="#cb53-6"></a>  <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span>;</span>
<span id="cb53-7"><a href="#cb53-7"></a><span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;=(</span><span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> x, <span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb53-8"><a href="#cb53-8"></a>  <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span>;</span>
<span id="cb53-9"><a href="#cb53-9"></a><span class="kw">friend</span> <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">&lt;=&gt;(</span><span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> x, <span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb53-10"><a href="#cb53-10"></a>  <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> three_way_comparable<span class="op">&lt;</span>Iterator<span class="op">&gt;</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_28" id="pnum_28">23</a></span> Let <code class="sourceCode cpp"><em>op</em></code> be the operator.</p>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_29" id="pnum_29">24</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> x<span class="op">.</span><em>current_</em> <em>op</em> y<span class="op">.</span><em>current_</em>;</code></p>
<div class="sourceCode" id="cb54"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1"></a><span class="kw">template</span> <span class="op">&lt;</span><em>not-same-as</em><span class="op">&lt;</span>basic_const_iterator<span class="op">&gt;</span> I<span class="op">&gt;</span></span>
<span id="cb54-2"><a href="#cb54-2"></a>  <span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;(</span><span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> x, <span class="kw">const</span> I<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb54-3"><a href="#cb54-3"></a>    <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> totally_ordered_with<span class="op">&lt;</span>Iterator, I<span class="op">&gt;</span>;</span>
<span id="cb54-4"><a href="#cb54-4"></a><span class="kw">template</span> <span class="op">&lt;</span><em>not-same-as</em><span class="op">&lt;</span>basic_const_iterator<span class="op">&gt;</span> I<span class="op">&gt;</span></span>
<span id="cb54-5"><a href="#cb54-5"></a>  <span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;(</span><span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> x, <span class="kw">const</span> I<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb54-6"><a href="#cb54-6"></a>    <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> totally_ordered_with<span class="op">&lt;</span>Iterator, I<span class="op">&gt;</span>;</span>
<span id="cb54-7"><a href="#cb54-7"></a><span class="kw">template</span> <span class="op">&lt;</span><em>not-same-as</em><span class="op">&lt;</span>basic_const_iterator<span class="op">&gt;</span> I<span class="op">&gt;</span></span>
<span id="cb54-8"><a href="#cb54-8"></a>  <span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;=(</span><span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> x, <span class="kw">const</span> I<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb54-9"><a href="#cb54-9"></a>    <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> totally_ordered_with<span class="op">&lt;</span>Iterator, I<span class="op">&gt;</span>;</span>
<span id="cb54-10"><a href="#cb54-10"></a><span class="kw">template</span> <span class="op">&lt;</span><em>not-same-as</em><span class="op">&lt;</span>basic_const_iterator<span class="op">&gt;</span> I<span class="op">&gt;</span></span>
<span id="cb54-11"><a href="#cb54-11"></a>  <span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;=(</span><span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> x, <span class="kw">const</span> I<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb54-12"><a href="#cb54-12"></a>    <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> totally_ordered_with<span class="op">&lt;</span>Iterator, I<span class="op">&gt;</span>;</span>
<span id="cb54-13"><a href="#cb54-13"></a><span class="kw">template</span> <span class="op">&lt;</span><em>not-same-as</em><span class="op">&lt;</span>basic_const_iterator<span class="op">&gt;</span> I<span class="op">&gt;</span></span>
<span id="cb54-14"><a href="#cb54-14"></a>  <span class="kw">friend</span> <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">&lt;=&gt;(</span><span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> x, <span class="kw">const</span> I<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb54-15"><a href="#cb54-15"></a>    <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span></span>
<span id="cb54-16"><a href="#cb54-16"></a>          <span class="op">&amp;&amp;</span> totally_ordered_with<span class="op">&lt;</span>Iterator, I<span class="op">&gt;</span></span>
<span id="cb54-17"><a href="#cb54-17"></a>          <span class="op">&amp;&amp;</span> three_way_comparable_with<span class="op">&lt;</span>Iterator, I<span class="op">&gt;</span></span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_30" id="pnum_30">25</a></span> Let <code class="sourceCode cpp"><em>op</em></code> be the operator.</p>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_31" id="pnum_31">26</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> x<span class="op">.</span><em>current_</em> <em>op</em> y;</code></p>
<div class="sourceCode" id="cb55"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1"></a><span class="kw">friend</span> <span class="kw">constexpr</span> basic_const_iterator <span class="kw">operator</span><span class="op">+(</span><span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> i, difference_type n<span class="op">)</span></span>
<span id="cb55-2"><a href="#cb55-2"></a>  <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span>;</span>
<span id="cb55-3"><a href="#cb55-3"></a><span class="kw">friend</span> <span class="kw">constexpr</span> basic_const_iterator <span class="kw">operator</span><span class="op">+(</span>difference_type n, <span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> i<span class="op">)</span></span>
<span id="cb55-4"><a href="#cb55-4"></a>  <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_32" id="pnum_32">27</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> basic_const_iterator<span class="op">(</span>i<span class="op">.</span><em>current_</em> <span class="op">+</span> n<span class="op">)</span>;</code></p>
<div class="sourceCode" id="cb56"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb56-1"><a href="#cb56-1"></a><span class="kw">friend</span> <span class="kw">constexpr</span> basic_const_iterator <span class="kw">operator</span><span class="op">-(</span><span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> i, difference_type n<span class="op">)</span></span>
<span id="cb56-2"><a href="#cb56-2"></a>  <span class="kw">requires</span> random_access_iterator<span class="op">&lt;</span>Iterator<span class="op">&gt;</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_33" id="pnum_33">28</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> basic_const_iterator<span class="op">(</span>i<span class="op">.</span><em>current_</em> <span class="op">-</span> n<span class="op">)</span>;</code></p>
<div class="sourceCode" id="cb57"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1"></a><span class="kw">friend</span> <span class="kw">constexpr</span> difference_type <span class="kw">operator</span><span class="op">-(</span><span class="kw">const</span> basic_const_iterator<span class="op">&amp;</span> x, basic_const_iterator<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb57-2"><a href="#cb57-2"></a>  <span class="kw">requires</span> sized_sentinel_for<span class="op">&lt;</span>Iterator, Iterator<span class="op">&gt;</span></span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_34" id="pnum_34">29</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> x<span class="op">.</span><em>current_</em> <span class="op">-</span> y<span class="op">.</span><em>current_</em>;</code></p>
</blockquote>
<h3 data-number="4.1.3" id="ranges"><span class="header-section-number">4.1.3</span> Ranges<a href="#ranges" class="self-link"></a></h3>
<p><span class="draftnote" style="color: #01796F">[ Drafting note: <code class="sourceCode cpp"><em>constant-iterator</em></code> is exposition-only while <code class="sourceCode cpp">constant_range</code> is not, largely on the basis that I’m aware of use-cases for the latter <span class="citation" data-cites="coerce-const">[<a href="#ref-coerce-const" role="doc-biblioref">coerce-const</a>]</span> but not the former. ]</span></p>
<p>Add to <span>24.2 <a href="https://wg21.link/ranges.syn">[ranges.syn]</a></span>:</p>
<blockquote>
<div>
<div class="sourceCode" id="cb58"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb58-1"><a href="#cb58-1"></a>#include &lt;compare&gt;              // see [compare.syn]</span>
<span id="cb58-2"><a href="#cb58-2"></a>#include &lt;initializer_list&gt;     // see [initializer.list.syn]</span>
<span id="cb58-3"><a href="#cb58-3"></a>#include &lt;iterator&gt;             // see [iterator.synopsis]</span>
<span id="cb58-4"><a href="#cb58-4"></a></span>
<span id="cb58-5"><a href="#cb58-5"></a>namespace std::ranges {</span>
<span id="cb58-6"><a href="#cb58-6"></a>  // ...</span>
<span id="cb58-7"><a href="#cb58-7"></a></span>
<span id="cb58-8"><a href="#cb58-8"></a></span>
<span id="cb58-9"><a href="#cb58-9"></a>  // [range.range], ranges</span>
<span id="cb58-10"><a href="#cb58-10"></a>  template&lt;class T&gt;</span>
<span id="cb58-11"><a href="#cb58-11"></a>    concept range = see below;</span>
<span id="cb58-12"><a href="#cb58-12"></a></span>
<span id="cb58-13"><a href="#cb58-13"></a>  template&lt;class T&gt;</span>
<span id="cb58-14"><a href="#cb58-14"></a>    inline constexpr bool enable_borrowed_range = false;</span>
<span id="cb58-15"><a href="#cb58-15"></a></span>
<span id="cb58-16"><a href="#cb58-16"></a>  template&lt;class T&gt;</span>
<span id="cb58-17"><a href="#cb58-17"></a>    concept borrowed_range = see below;</span>
<span id="cb58-18"><a href="#cb58-18"></a></span>
<span id="cb58-19"><a href="#cb58-19"></a>  template&lt;class T&gt;</span>
<span id="cb58-20"><a href="#cb58-20"></a>    using iterator_t = decltype(ranges::begin(declval&lt;T&amp;&gt;()));</span>
<span id="cb58-21"><a href="#cb58-21"></a>  template&lt;range R&gt;</span>
<span id="cb58-22"><a href="#cb58-22"></a>    using sentinel_t = decltype(ranges::end(declval&lt;R&amp;&gt;()));</span>
<span id="cb58-23"><a href="#cb58-23"></a><span class="va">+ template&lt;range R&gt;</span></span>
<span id="cb58-24"><a href="#cb58-24"></a><span class="va">+   using const_iterator_t = const_iterator&lt;iterator_t&lt;R&gt;&gt;;</span></span>
<span id="cb58-25"><a href="#cb58-25"></a>  template&lt;range R&gt;</span>
<span id="cb58-26"><a href="#cb58-26"></a>    using range_difference_t = iter_difference_t&lt;iterator_t&lt;R&gt;&gt;;</span>
<span id="cb58-27"><a href="#cb58-27"></a>  template&lt;sized_­range R&gt;</span>
<span id="cb58-28"><a href="#cb58-28"></a>    using range_size_t = decltype(ranges::size(declval&lt;R&amp;&gt;()));</span>
<span id="cb58-29"><a href="#cb58-29"></a>  template&lt;range R&gt;</span>
<span id="cb58-30"><a href="#cb58-30"></a>    using range_value_t = iter_value_t&lt;iterator_t&lt;R&gt;&gt;;</span>
<span id="cb58-31"><a href="#cb58-31"></a>  template&lt;range R&gt;</span>
<span id="cb58-32"><a href="#cb58-32"></a>    using range_reference_t = iter_reference_t&lt;iterator_t&lt;R&gt;&gt;;</span>
<span id="cb58-33"><a href="#cb58-33"></a><span class="va">+ template&lt;range R&gt;</span></span>
<span id="cb58-34"><a href="#cb58-34"></a><span class="va">+   using range_const_reference_t = iter_const_reference_t&lt;iterator_t&lt;R&gt;&gt;;</span></span>
<span id="cb58-35"><a href="#cb58-35"></a>  template&lt;range R&gt;</span>
<span id="cb58-36"><a href="#cb58-36"></a>    using range_rvalue_reference_t = iter_rvalue_reference_t&lt;iterator_t&lt;R&gt;&gt;;</span>
<span id="cb58-37"><a href="#cb58-37"></a></span>
<span id="cb58-38"><a href="#cb58-38"></a>  // ...</span>
<span id="cb58-39"><a href="#cb58-39"></a></span>
<span id="cb58-40"><a href="#cb58-40"></a>  // [range.refinements], other range refinements</span>
<span id="cb58-41"><a href="#cb58-41"></a>  template&lt;class R, class T&gt;</span>
<span id="cb58-42"><a href="#cb58-42"></a>    concept output_range = see below;</span>
<span id="cb58-43"><a href="#cb58-43"></a></span>
<span id="cb58-44"><a href="#cb58-44"></a>  template&lt;class T&gt;</span>
<span id="cb58-45"><a href="#cb58-45"></a>    concept input_range = see below;</span>
<span id="cb58-46"><a href="#cb58-46"></a></span>
<span id="cb58-47"><a href="#cb58-47"></a>  template&lt;class T&gt;</span>
<span id="cb58-48"><a href="#cb58-48"></a>    concept forward_range = see below;</span>
<span id="cb58-49"><a href="#cb58-49"></a></span>
<span id="cb58-50"><a href="#cb58-50"></a>  template&lt;class T&gt;</span>
<span id="cb58-51"><a href="#cb58-51"></a>    concept bidirectional_range = see below;</span>
<span id="cb58-52"><a href="#cb58-52"></a></span>
<span id="cb58-53"><a href="#cb58-53"></a>  template&lt;class T&gt;</span>
<span id="cb58-54"><a href="#cb58-54"></a>    concept random_access_range = see below;</span>
<span id="cb58-55"><a href="#cb58-55"></a></span>
<span id="cb58-56"><a href="#cb58-56"></a>  template&lt;class T&gt;</span>
<span id="cb58-57"><a href="#cb58-57"></a>    concept contiguous_range = see below;</span>
<span id="cb58-58"><a href="#cb58-58"></a></span>
<span id="cb58-59"><a href="#cb58-59"></a>  template&lt;class T&gt;</span>
<span id="cb58-60"><a href="#cb58-60"></a>    concept common_range = see below;</span>
<span id="cb58-61"><a href="#cb58-61"></a></span>
<span id="cb58-62"><a href="#cb58-62"></a>  template&lt;class T&gt;</span>
<span id="cb58-63"><a href="#cb58-63"></a>    concept viewable_range = see below;</span>
<span id="cb58-64"><a href="#cb58-64"></a></span>
<span id="cb58-65"><a href="#cb58-65"></a><span class="va">+ template&lt;class T&gt;</span></span>
<span id="cb58-66"><a href="#cb58-66"></a><span class="va">+   concept constant_range = <em>see below</em>;</span></span>
<span id="cb58-67"><a href="#cb58-67"></a></span>
<span id="cb58-68"><a href="#cb58-68"></a>  // [view.interface], class template view_interface</span>
<span id="cb58-69"><a href="#cb58-69"></a>  // ...</span>
<span id="cb58-70"><a href="#cb58-70"></a></span>
<span id="cb58-71"><a href="#cb58-71"></a>  // [range.reverse], reverse view</span>
<span id="cb58-72"><a href="#cb58-72"></a>  template&lt;view V&gt;</span>
<span id="cb58-73"><a href="#cb58-73"></a>    requires bidirectional_range&lt;V&gt;</span>
<span id="cb58-74"><a href="#cb58-74"></a>  class reverse_view;</span>
<span id="cb58-75"><a href="#cb58-75"></a></span>
<span id="cb58-76"><a href="#cb58-76"></a>  template&lt;class T&gt;</span>
<span id="cb58-77"><a href="#cb58-77"></a>    inline constexpr bool enable_borrowed_range&lt;reverse_view&lt;T&gt;&gt; = enable_borrowed_range&lt;T&gt;;</span>
<span id="cb58-78"><a href="#cb58-78"></a></span>
<span id="cb58-79"><a href="#cb58-79"></a>  namespace views { inline constexpr <em>unspecified</em> reverse = <em>unspecified</em>; }</span>
<span id="cb58-80"><a href="#cb58-80"></a></span>
<span id="cb58-81"><a href="#cb58-81"></a><span class="va">+ // [range.const], constant view</span></span>
<span id="cb58-82"><a href="#cb58-82"></a><span class="va">+ template &lt;range R&gt;</span></span>
<span id="cb58-83"><a href="#cb58-83"></a><span class="va">+   constexpr auto&amp; <em>possibly-const</em>(R&amp; r) { // exposition only</span></span>
<span id="cb58-84"><a href="#cb58-84"></a><span class="va">+     if constexpr (constant_range&lt;const R&gt; &amp;&amp; !constant_range&lt;R&gt;) {</span></span>
<span id="cb58-85"><a href="#cb58-85"></a><span class="va">+       return const_cast&lt;const R&amp;&gt;(r);</span></span>
<span id="cb58-86"><a href="#cb58-86"></a><span class="va">+     } else {</span></span>
<span id="cb58-87"><a href="#cb58-87"></a><span class="va">+       return r;</span></span>
<span id="cb58-88"><a href="#cb58-88"></a><span class="va">+     }</span></span>
<span id="cb58-89"><a href="#cb58-89"></a><span class="va">+   }</span></span>
<span id="cb58-90"><a href="#cb58-90"></a><span class="va">+</span></span>
<span id="cb58-91"><a href="#cb58-91"></a><span class="va">+ template&lt;view V&gt;</span></span>
<span id="cb58-92"><a href="#cb58-92"></a><span class="va">+   requires input_range&lt;V&gt;</span></span>
<span id="cb58-93"><a href="#cb58-93"></a><span class="va">+ class all_const_view;</span></span>
<span id="cb58-94"><a href="#cb58-94"></a><span class="va">+</span></span>
<span id="cb58-95"><a href="#cb58-95"></a><span class="va">+ template&lt;class T&gt;</span></span>
<span id="cb58-96"><a href="#cb58-96"></a><span class="va">+   inline constexpr bool enable_borrowed_range&lt;all_const_view&lt;T&gt;&gt; = enable_borrowed_range&lt;T&gt;;</span></span>
<span id="cb58-97"><a href="#cb58-97"></a><span class="va">+</span></span>
<span id="cb58-98"><a href="#cb58-98"></a><span class="va">+ namespace views { inline constexpr <em>unspecified</em> all_const = <em>unspecified</em>; }</span></span>
<span id="cb58-99"><a href="#cb58-99"></a></span>
<span id="cb58-100"><a href="#cb58-100"></a>  // ...</span>
<span id="cb58-101"><a href="#cb58-101"></a>}</span></code></pre></div>
</div>
</blockquote>
<p>Update <code class="sourceCode cpp">ranges<span class="op">::</span>cbegin</code> in <span>24.3.4 <a href="https://wg21.link/range.access.cbegin">[range.access.cbegin]</a></span>:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_35" id="pnum_35">1</a></span> The name <code class="sourceCode cpp">ranges​<span class="op">::</span>​cbegin</code> denotes a customization point object ([customization.point.object]). <span class="rm" style="color: #bf0303"><del>The expression <span><code class="sourceCode default">ranges​::​​cbegin(E)</code></span> for a subexpression <span><code class="sourceCode default">E</code></span> of type <span><code class="sourceCode default">T</code></span> is expression-equivalent to</del></span> <span class="addu">Given a subexpression <code class="sourceCode cpp">E</code> with type <code class="sourceCode cpp">T</code>, let <code class="sourceCode cpp">t</code> be an lvalue that denotes the reified object for <code class="sourceCode cpp">E</code>. Then:</span></p>
<div class="rm" style="color: #bf0303">

<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_36" id="pnum_36">(1.1)</a></span> <code class="sourceCode default">ranges​::​begin(static_cast&lt;const T&amp;&gt;(E))</code> if <code class="sourceCode default">E</code> is an lvalue.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_37" id="pnum_37">(1.2)</a></span> Otherwise, <code class="sourceCode default">ranges​::​begin(static_cast&lt;const T&amp;&amp;&gt;(E))</code>.</li>
</ul>

</div>
<div class="addu">
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_38" id="pnum_38">(1.1)</a></span> If <code class="sourceCode cpp">E</code> is an rvalue and <code class="sourceCode cpp">enable_borrowed_range<span class="op">&lt;</span>remove_cv_t<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span></code> is <code class="sourceCode cpp"><span class="kw">false</span></code>, <code class="sourceCode cpp">ranges​<span class="op">::</span>c​begin<span class="op">(</span>E<span class="op">)</span></code> is ill-formed.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_39" id="pnum_39">(1.2)</a></span> Otherwise, <code class="sourceCode cpp">ranges<span class="op">::</span>cbegin<span class="op">(</span>E<span class="op">)</span></code> is expression-equivalent to <code class="sourceCode cpp">make_const_iterator<span class="op">(</span>ranges<span class="op">::</span>begin<span class="op">(</span><em>possibly-const</em><span class="op">(</span>t<span class="op">)))</span></code>.</li>
</ul>
</div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_40" id="pnum_40">2</a></span> [<em>Note 1</em>: Whenever <code class="sourceCode cpp">ranges​<span class="op">::</span>​cbegin<span class="op">(</span>E<span class="op">)</span></code> is a valid expression, its type models <code class="sourceCode cpp">input_or_output_iterator</code> <span class="addu">and <code class="sourceCode cpp"><em>constant-iterator</em></code></span>. — <em>end note</em>]</p>
</blockquote>
<p>Update <code class="sourceCode cpp">ranges<span class="op">::</span>cend</code> in <span>24.3.5 <a href="https://wg21.link/range.access.cend">[range.access.cend]</a></span>:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_41" id="pnum_41">1</a></span> The name <code class="sourceCode cpp">ranges​<span class="op">::</span>​cend</code> denotes a customization point object ([customization.point.object]). <span class="rm" style="color: #bf0303"><del>The expression <span><code class="sourceCode default">ranges​::​​cend(E)</code></span> for a subexpression <span><code class="sourceCode default">E</code></span> of type <span><code class="sourceCode default">T</code></span> is expression-equivalent to</del></span> <span class="addu">Given a subexpression <code class="sourceCode cpp">E</code> with type <code class="sourceCode cpp">T</code>, let <code class="sourceCode cpp">t</code> be an lvalue that denotes the reified object for <code class="sourceCode cpp">E</code>. Then:</span></p>
<div class="rm" style="color: #bf0303">

<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_42" id="pnum_42">(1.1)</a></span> <code class="sourceCode default">ranges​::​cend(static_cast&lt;const T&amp;&gt;(E))</code> if <code class="sourceCode default">E</code> is an lvalue.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_43" id="pnum_43">(1.2)</a></span> Otherwise, <code class="sourceCode default">ranges​::​cend(static_cast&lt;const T&amp;&amp;&gt;(E))</code>.</li>
</ul>

</div>
<div class="addu">
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_44" id="pnum_44">(1.1)</a></span> If <code class="sourceCode cpp">E</code> is an rvalue and <code class="sourceCode cpp">enable_borrowed_range<span class="op">&lt;</span>remove_cv_t<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span></code> is <code class="sourceCode cpp"><span class="kw">false</span></code>, <code class="sourceCode cpp">ranges​<span class="op">::</span>cend<span class="op">(</span>E<span class="op">)</span></code> is ill-formed.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_45" id="pnum_45">(1.2)</a></span> Otherwise, <code class="sourceCode cpp">ranges<span class="op">::</span>cend<span class="op">(</span>E<span class="op">)</span></code> is expression-equivalent to <code class="sourceCode cpp">make_const_sentinel<span class="op">(</span>ranges<span class="op">::</span>end<span class="op">(</span><em>possibly-const</em><span class="op">(</span>t<span class="op">)))</span></code>.</li>
</ul>
</div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_46" id="pnum_46">2</a></span> [<em>Note 1</em>: Whenever <code class="sourceCode cpp">ranges​<span class="op">::</span>​cend<span class="op">(</span>E<span class="op">)</span></code> is a valid expression, the types <code class="sourceCode cpp">S</code> and <code class="sourceCode cpp">I</code> of the expressions <code class="sourceCode cpp">ranges<span class="op">::</span>cend<span class="op">(</span>E<span class="op">)</span></code> and <code class="sourceCode cpp">ranges<span class="op">::</span>cbegin<span class="op">(</span>E<span class="op">)</span></code> model <code class="sourceCode cpp">sentinel_for<span class="op">&lt;</span>S, I<span class="op">&gt;</span></code>. <span class="addu">If <code class="sourceCode cpp">S</code> models <code class="sourceCode cpp">input_iterator</code>, then <code class="sourceCode cpp">S</code> also models <code class="sourceCode cpp"><em>constant-iterator</em></code>.</span> — <em>end note</em>]</p>
</blockquote>
<p>Update <code class="sourceCode cpp">ranges<span class="op">::</span>crbegin</code> in <span>24.3.8 <a href="https://wg21.link/range.access.crbegin">[range.access.crbegin]</a></span>:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_47" id="pnum_47">1</a></span> The name <code class="sourceCode cpp">ranges​<span class="op">::</span>​crbegin</code> denotes a customization point object ([customization.point.object]). <span class="rm" style="color: #bf0303"><del>The expression <span><code class="sourceCode default">ranges​::​​crbegin(E)</code></span> for a subexpression <span><code class="sourceCode default">E</code></span> of type <span><code class="sourceCode default">T</code></span> is expression-equivalent to</del></span> <span class="addu">Given a subexpression <code class="sourceCode cpp">E</code> with type <code class="sourceCode cpp">T</code>, let <code class="sourceCode cpp">t</code> be an lvalue that denotes the reified object for <code class="sourceCode cpp">E</code>. Then:</span></p>
<div class="rm" style="color: #bf0303">

<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_48" id="pnum_48">(1.1)</a></span> <code class="sourceCode default">ranges​::​rbegin(static_cast&lt;const T&amp;&gt;(E))</code> if <code class="sourceCode default">E</code> is an lvalue.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_49" id="pnum_49">(1.2)</a></span> Otherwise, <code class="sourceCode default">ranges​::​rbegin(static_cast&lt;const T&amp;&amp;&gt;(E))</code>.</li>
</ul>

</div>
<div class="addu">
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_50" id="pnum_50">(1.1)</a></span> If <code class="sourceCode cpp">E</code> is an rvalue and <code class="sourceCode cpp">enable_borrowed_range<span class="op">&lt;</span>remove_cv_t<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span></code> is <code class="sourceCode cpp"><span class="kw">false</span></code>, <code class="sourceCode cpp">ranges​<span class="op">::</span>cr​begin<span class="op">(</span>E<span class="op">)</span></code> is ill-formed.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_51" id="pnum_51">(1.2)</a></span> Otherwise, <code class="sourceCode cpp">ranges<span class="op">::</span>crbegin<span class="op">(</span>E<span class="op">)</span></code> is expression-equivalent to <code class="sourceCode cpp">make_const_iterator<span class="op">(</span>ranges<span class="op">::</span>rbegin<span class="op">(</span><em>possibly-const</em><span class="op">(</span>t<span class="op">)))</span></code>.</li>
</ul>
</div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_52" id="pnum_52">2</a></span> [<em>Note 1</em>: Whenever <code class="sourceCode cpp">ranges​<span class="op">::</span>​crbegin<span class="op">(</span>E<span class="op">)</span></code> is a valid expression, its type models <code class="sourceCode cpp">input_or_output_iterator</code> <span class="addu">and <code class="sourceCode cpp"><em>constant-iterator</em></code></span>. — <em>end note</em>]</p>
</blockquote>
<p>Update <code class="sourceCode cpp">ranges<span class="op">::</span>crend</code> in <span>24.3.9 <a href="https://wg21.link/range.access.crend">[range.access.crend]</a></span>:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_53" id="pnum_53">1</a></span> The name <code class="sourceCode cpp">ranges​<span class="op">::</span>​crend</code> denotes a customization point object ([customization.point.object]). <span class="rm" style="color: #bf0303"><del>The expression <span><code class="sourceCode default">ranges​::​​crend(E)</code></span> for a subexpression <span><code class="sourceCode default">E</code></span> of type <span><code class="sourceCode default">T</code></span> is expression-equivalent to</del></span> <span class="addu">Given a subexpression <code class="sourceCode cpp">E</code> with type <code class="sourceCode cpp">T</code>, let <code class="sourceCode cpp">t</code> be an lvalue that denotes the reified object for <code class="sourceCode cpp">E</code>. Then:</span></p>
<div class="rm" style="color: #bf0303">

<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_54" id="pnum_54">(1.1)</a></span> <code class="sourceCode default">ranges​::​rend(static_cast&lt;const T&amp;&gt;(E))</code> if <code class="sourceCode default">E</code> is an lvalue.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_55" id="pnum_55">(1.2)</a></span> Otherwise, <code class="sourceCode default">ranges​::​rend(static_cast&lt;const T&amp;&amp;&gt;(E))</code>.</li>
</ul>

</div>
<div class="addu">
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_56" id="pnum_56">(1.1)</a></span> If <code class="sourceCode cpp">E</code> is an rvalue and <code class="sourceCode cpp">enable_borrowed_range<span class="op">&lt;</span>remove_cv_t<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span></code> is <code class="sourceCode cpp"><span class="kw">false</span></code>, <code class="sourceCode cpp">ranges​<span class="op">::</span>c​rend<span class="op">(</span>E<span class="op">)</span></code> is ill-formed.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_57" id="pnum_57">(1.2)</a></span> Otherwise, <code class="sourceCode cpp">ranges<span class="op">::</span>crend<span class="op">(</span>E<span class="op">)</span></code> is expression-equivalent to <code class="sourceCode cpp">make_const_sentinel<span class="op">(</span>ranges<span class="op">::</span>rend<span class="op">(</span><em>possibly-const</em><span class="op">(</span>t<span class="op">)))</span></code>.</li>
</ul>
</div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_58" id="pnum_58">2</a></span> [<em>Note 1</em>: Whenever <code class="sourceCode cpp">ranges​<span class="op">::</span>​cend<span class="op">(</span>E<span class="op">)</span></code> is a valid expression, the types <code class="sourceCode cpp">S</code> and <code class="sourceCode cpp">I</code> of the expressions <code class="sourceCode cpp">ranges<span class="op">::</span>crend<span class="op">(</span>E<span class="op">)</span></code> and <code class="sourceCode cpp">ranges<span class="op">::</span>crbegin<span class="op">(</span>E<span class="op">)</span></code> model <code class="sourceCode cpp">sentinel_for<span class="op">&lt;</span>S, I<span class="op">&gt;</span></code>. <span class="addu">If <code class="sourceCode cpp">S</code> models <code class="sourceCode cpp">input_iterator</code>, then <code class="sourceCode cpp">S</code> also models <code class="sourceCode cpp"><em>constant-iterator</em></code>.</span> — <em>end note</em>]</p>
</blockquote>
<p>Update <code class="sourceCode cpp">ranges<span class="op">::</span>cdata</code> in <span>24.3.14 <a href="https://wg21.link/range.prim.cdata">[range.prim.cdata]</a></span>:</p>
<blockquote>
<div class="addu">
<div class="sourceCode" id="cb59"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb59-1"><a href="#cb59-1"></a>template&lt;typename T&gt;</span>
<span id="cb59-2"><a href="#cb59-2"></a>constexpr auto <em>as-const-pointer</em>(const T* p) { return p; } // exposition only</span></code></pre></div>
</div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_59" id="pnum_59">1</a></span> The name <code class="sourceCode cpp">ranges​<span class="op">::</span>​cdata</code> denotes a customization point object ([customization.point.object]). <span class="rm" style="color: #bf0303"><del>The expression <span><code class="sourceCode default">ranges​::​​cdata(E)</code></span> for a subexpression <span><code class="sourceCode default">E</code></span> of type <span><code class="sourceCode default">T</code></span> is expression-equivalent to:</del></span> <span class="addu">Given a subexpression <code class="sourceCode cpp">E</code> with type <code class="sourceCode cpp">T</code>, let <code class="sourceCode cpp">t</code> be an lvalue that denotes the reified object for <code class="sourceCode cpp">E</code>. Then:</span></p>
<div class="rm" style="color: #bf0303">

<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_60" id="pnum_60">(1.1)</a></span> <code class="sourceCode default">ranges​::​data(static_cast&lt;const T&amp;&gt;(E))</code> if <code class="sourceCode default">E</code> is an lvalue.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_61" id="pnum_61">(1.2)</a></span> Otherwise, <code class="sourceCode default">ranges​::​data(static_cast&lt;const T&amp;&amp;&gt;(E))</code>.</li>
</ul>

</div>
<div class="addu">
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_62" id="pnum_62">(1.1)</a></span> If <code class="sourceCode cpp">E</code> is an rvalue and <code class="sourceCode cpp">enable_borrowed_range<span class="op">&lt;</span>remove_cv_t<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span></code> is <code class="sourceCode cpp"><span class="kw">false</span></code>, <code class="sourceCode cpp">ranges​<span class="op">::</span>c​data<span class="op">(</span>E<span class="op">)</span></code> is ill-formed.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_63" id="pnum_63">(1.2)</a></span> Otherwise, <code class="sourceCode cpp">ranges<span class="op">::</span>cdata<span class="op">(</span>E<span class="op">)</span></code> is expression-equivalent to <code class="sourceCode cpp"><em>as-const-pointer</em><span class="op">(</span>ranges<span class="op">::</span>data<span class="op">(</span><em>possibly-const</em><span class="op">(</span>t<span class="op">)))</span></code>.</li>
</ul>
</div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_64" id="pnum_64">2</a></span> [<em>Note 1</em>: Whenever <code class="sourceCode cpp">ranges​<span class="op">::</span>​cdata<span class="op">(</span>E<span class="op">)</span></code> is a valid expression, it has pointer to <span class="addu">constant</span> object type. — end note]</p>
</blockquote>
<p>Add <code class="sourceCode cpp">cbegin</code> and <code class="sourceCode cpp">cend</code> to <code class="sourceCode cpp">view_interface</code> in <span>24.5.3.1 <a href="https://wg21.link/view.interface.general">[view.interface.general]</a></span>:</p>
<blockquote>
<div>
<div class="sourceCode" id="cb60"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb60-1"><a href="#cb60-1"></a>namespace std::ranges {</span>
<span id="cb60-2"><a href="#cb60-2"></a>  template&lt;class D&gt;</span>
<span id="cb60-3"><a href="#cb60-3"></a>    requires is_class_v&lt;D&gt; &amp;&amp; same_as&lt;D, remove_cv_t&lt;D&gt;&gt;</span>
<span id="cb60-4"><a href="#cb60-4"></a>  class view_interface {</span>
<span id="cb60-5"><a href="#cb60-5"></a>  private:</span>
<span id="cb60-6"><a href="#cb60-6"></a>    constexpr D&amp; <em>derived</em>() noexcept {               // exposition only</span>
<span id="cb60-7"><a href="#cb60-7"></a>      return static_cast&lt;D&amp;&gt;(*this);</span>
<span id="cb60-8"><a href="#cb60-8"></a>    }</span>
<span id="cb60-9"><a href="#cb60-9"></a>    constexpr const D&amp; <em>derived</em>() const noexcept {   // exposition only</span>
<span id="cb60-10"><a href="#cb60-10"></a>      return static_cast&lt;const D&amp;&gt;(*this);</span>
<span id="cb60-11"><a href="#cb60-11"></a>    }</span>
<span id="cb60-12"><a href="#cb60-12"></a></span>
<span id="cb60-13"><a href="#cb60-13"></a>  public:</span>
<span id="cb60-14"><a href="#cb60-14"></a>    constexpr bool empty() requires forward_range&lt;D&gt; {</span>
<span id="cb60-15"><a href="#cb60-15"></a>      return ranges::begin(<em>derived</em>()) == ranges::end(<em>derived</em>());</span>
<span id="cb60-16"><a href="#cb60-16"></a>    }</span>
<span id="cb60-17"><a href="#cb60-17"></a>    constexpr bool empty() const requires forward_range&lt;const D&gt; {</span>
<span id="cb60-18"><a href="#cb60-18"></a>      return ranges::begin(<em>derived</em>()) == ranges::end(<em>derived</em>());</span>
<span id="cb60-19"><a href="#cb60-19"></a>    }</span>
<span id="cb60-20"><a href="#cb60-20"></a></span>
<span id="cb60-21"><a href="#cb60-21"></a><span class="va">+   constexpr auto cbegin() {</span></span>
<span id="cb60-22"><a href="#cb60-22"></a><span class="va">+       return ranges::cbegin(<em>derived</em>());</span></span>
<span id="cb60-23"><a href="#cb60-23"></a><span class="va">+   }</span></span>
<span id="cb60-24"><a href="#cb60-24"></a><span class="va">+   constexpr auto cbegin() const requires range&lt;const D&gt; {</span></span>
<span id="cb60-25"><a href="#cb60-25"></a><span class="va">+       return ranges::cbegin(<em>derived</em>());</span></span>
<span id="cb60-26"><a href="#cb60-26"></a><span class="va">+   }</span></span>
<span id="cb60-27"><a href="#cb60-27"></a><span class="va">+   constexpr auto cend() {</span></span>
<span id="cb60-28"><a href="#cb60-28"></a><span class="va">+       return ranges::cend(<em>derived</em>());</span></span>
<span id="cb60-29"><a href="#cb60-29"></a><span class="va">+   }</span></span>
<span id="cb60-30"><a href="#cb60-30"></a><span class="va">+   constexpr auto cend() const requires range&lt;const D&gt; {</span></span>
<span id="cb60-31"><a href="#cb60-31"></a><span class="va">+       return ranges::cend(<em>derived</em>());</span></span>
<span id="cb60-32"><a href="#cb60-32"></a><span class="va">+   }</span></span>
<span id="cb60-33"><a href="#cb60-33"></a></span>
<span id="cb60-34"><a href="#cb60-34"></a>    // ...</span>
<span id="cb60-35"><a href="#cb60-35"></a>  };</span>
<span id="cb60-36"><a href="#cb60-36"></a>}</span></code></pre></div>
</div>
</blockquote>
<h3 class="unnumbered" data-number id="all-const-view-range.all.const">24.7.? All const view [range.all.const]<a href="#all-const-view-range.all.const" class="self-link"></a></h3>
<h4 class="unnumbered" data-number id="overview-range.all.const.overview">24.7.?.1 Overview [range.all.const.overview]<a href="#overview-range.all.const.overview" class="self-link"></a></h4>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_65" id="pnum_65">1</a></span> <code class="sourceCode cpp">all_const_view</code> presents a <code class="sourceCode cpp">view</code> of an underlying sequence as constant. That is, the elements of a <code class="sourceCode cpp">all_const_view</code> cannot be modified.</p>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_66" id="pnum_66">2</a></span> The name <code class="sourceCode cpp">views<span class="op">::</span>all_const</code> denotes a range adaptor object ([range.adaptor.object]). Let <code class="sourceCode cpp">E</code> be an expression, let <code class="sourceCode cpp">T</code> be <code class="sourceCode cpp"><span class="kw">decltype</span><span class="op">((</span>E<span class="op">))</span></code>, and let <code class="sourceCode cpp">U</code> be <code class="sourceCode cpp">remove_cvref_t<span class="op">&lt;</span>T<span class="op">&gt;</span></code>. The expression <code class="sourceCode cpp">views<span class="op">::</span>all_const<span class="op">(</span>E<span class="op">)</span></code> is expression-equivalent to:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_67" id="pnum_67">(2.1)</a></span> If <code class="sourceCode cpp">views<span class="op">::</span>all_t<span class="op">&lt;</span>T<span class="op">&gt;</span></code> models <code class="sourceCode cpp">constant_range</code>, then <code class="sourceCode cpp">views<span class="op">::</span>all<span class="op">(</span>E<span class="op">)</span></code> .</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_68" id="pnum_68">(2.2)</a></span> Otherwise, if <code class="sourceCode cpp">E</code> is an lvalue, <code class="sourceCode cpp"><span class="kw">const</span> U</code> models <code class="sourceCode cpp">constant_range</code>, and <code class="sourceCode cpp">U</code> does not model <code class="sourceCode cpp">view</code>, then <code class="sourceCode cpp">views<span class="op">::</span>all<span class="op">(</span><span class="kw">static_cast</span><span class="op">&lt;</span><span class="kw">const</span> U<span class="op">&amp;&gt;(</span>E<span class="op">))</span></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_69" id="pnum_69">(2.3)</a></span> Otherwise, <code class="sourceCode cpp">ranges<span class="op">::</span>all_const_view<span class="op">{</span>E<span class="op">}</span></code>.</li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_70" id="pnum_70">3</a></span> [<em>Example</em>:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb61-1"><a href="#cb61-1"></a><span class="kw">template</span><span class="op">&lt;</span>constant_range R<span class="op">&gt;</span></span>
<span id="cb61-2"><a href="#cb61-2"></a><span class="dt">void</span> cant_touch_this<span class="op">(</span>R<span class="op">&amp;&amp;)</span>;</span>
<span id="cb61-3"><a href="#cb61-3"></a></span>
<span id="cb61-4"><a href="#cb61-4"></a>std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> beat <span class="op">=</span> <span class="op">{</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span><span class="op">}</span>;</span>
<span id="cb61-5"><a href="#cb61-5"></a>cant_touch_this<span class="op">(</span>views<span class="op">::</span>all_const<span class="op">(</span>beat<span class="op">))</span>; <span class="co">// will not modify the elements of beat</span></span></code></pre></div>
<p>-<em>end example</em>]</p>
</blockquote>
<h4 class="unnumbered" data-number id="class-template-all_const_view-range.all.const.view">24.7.?.2 Class template <code class="sourceCode cpp">all_const_view</code> [range.all.const.view]<a href="#class-template-all_const_view-range.all.const.view" class="self-link"></a></h4>
<blockquote>
<div class="sourceCode" id="cb62"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb62-1"><a href="#cb62-1"></a><span class="kw">namespace</span> std<span class="op">::</span>ranges <span class="op">{</span></span>
<span id="cb62-2"><a href="#cb62-2"></a>  <span class="kw">template</span><span class="op">&lt;</span>input_range V<span class="op">&gt;</span></span>
<span id="cb62-3"><a href="#cb62-3"></a>    <span class="kw">requires</span> view<span class="op">&lt;</span>V<span class="op">&gt;</span></span>
<span id="cb62-4"><a href="#cb62-4"></a>  <span class="kw">class</span> all_const_view <span class="op">:</span> <span class="kw">public</span> view_interface<span class="op">&lt;</span>all_const_view<span class="op">&lt;</span>V<span class="op">&gt;&gt;</span></span>
<span id="cb62-5"><a href="#cb62-5"></a>  <span class="op">{</span></span>
<span id="cb62-6"><a href="#cb62-6"></a>    V <em>base_</em> <span class="op">=</span> V<span class="op">()</span>; <span class="co">// exposition only</span></span>
<span id="cb62-7"><a href="#cb62-7"></a></span>
<span id="cb62-8"><a href="#cb62-8"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="cb62-9"><a href="#cb62-9"></a>    all_const_view<span class="op">()</span> <span class="kw">requires</span> default_initializable<span class="op">&lt;</span>V<span class="op">&gt;</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb62-10"><a href="#cb62-10"></a>    <span class="kw">constexpr</span> <span class="kw">explicit</span> all_const_view<span class="op">(</span>V base<span class="op">)</span>;</span>
<span id="cb62-11"><a href="#cb62-11"></a></span>
<span id="cb62-12"><a href="#cb62-12"></a>    <span class="kw">constexpr</span> V base<span class="op">()</span> <span class="kw">const</span><span class="op">&amp;</span> <span class="kw">requires</span> copy_constructible<span class="op">&lt;</span>V<span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> base_; <span class="op">}</span></span>
<span id="cb62-13"><a href="#cb62-13"></a>    <span class="kw">constexpr</span> V base<span class="op">()</span> <span class="op">&amp;&amp;</span> <span class="op">{</span> <span class="cf">return</span> std<span class="op">::</span>move<span class="op">(</span>base_<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb62-14"><a href="#cb62-14"></a></span>
<span id="cb62-15"><a href="#cb62-15"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> begin<span class="op">()</span> <span class="kw">requires</span> <span class="op">(!</span><em>simple-view</em><span class="op">&lt;</span>V<span class="op">&gt;)</span> <span class="op">{</span> <span class="cf">return</span> ranges<span class="op">::</span>cbegin<span class="op">(</span><em>base_</em><span class="op">)</span>; <span class="op">}</span></span>
<span id="cb62-16"><a href="#cb62-16"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> begin<span class="op">()</span> <span class="kw">const</span> <span class="kw">requires</span> range<span class="op">&lt;</span><span class="kw">const</span> V<span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> ranges<span class="op">::</span>cbegin<span class="op">(</span><em>base_</em><span class="op">)</span>; <span class="op">}</span></span>
<span id="cb62-17"><a href="#cb62-17"></a></span>
<span id="cb62-18"><a href="#cb62-18"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> end<span class="op">()</span> <span class="kw">requires</span> <span class="op">(!</span><em>simple-view</em><span class="op">&lt;</span>V<span class="op">&gt;)</span> <span class="op">{</span> <span class="cf">return</span> ranges<span class="op">::</span>cend<span class="op">(</span><em>base_</em><span class="op">)</span>; <span class="op">}</span></span>
<span id="cb62-19"><a href="#cb62-19"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> end<span class="op">()</span> <span class="kw">const</span> <span class="kw">requires</span> range<span class="op">&lt;</span><span class="kw">const</span> V<span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> ranges<span class="op">::</span>cend<span class="op">(</span><em>base_</em><span class="op">)</span>; <span class="op">}</span></span>
<span id="cb62-20"><a href="#cb62-20"></a></span>
<span id="cb62-21"><a href="#cb62-21"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> size<span class="op">()</span> <span class="kw">requires</span> sized_range<span class="op">&lt;</span>V<span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> ranges<span class="op">::</span>size<span class="op">(</span><em>base_</em><span class="op">)</span>; <span class="op">}</span></span>
<span id="cb62-22"><a href="#cb62-22"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> size<span class="op">()</span> <span class="kw">const</span> <span class="kw">requires</span> sized_range<span class="op">&lt;</span><span class="kw">const</span> V<span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> ranges<span class="op">::</span>size<span class="op">(</span><em>base_</em><span class="op">)</span>; <span class="op">}</span></span>
<span id="cb62-23"><a href="#cb62-23"></a>  <span class="op">}</span>;</span>
<span id="cb62-24"><a href="#cb62-24"></a></span>
<span id="cb62-25"><a href="#cb62-25"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> R<span class="op">&gt;</span></span>
<span id="cb62-26"><a href="#cb62-26"></a>    all_const_view<span class="op">(</span>R<span class="op">&amp;&amp;)</span> <span class="op">-&gt;</span> all_const_view<span class="op">&lt;</span>views<span class="op">::</span>all_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;</span>;</span>
<span id="cb62-27"><a href="#cb62-27"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb63"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb63-1"><a href="#cb63-1"></a><span class="kw">constexpr</span> <span class="kw">explicit</span> all_const_view<span class="op">(</span>V base<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_71" id="pnum_71">1</a></span> <em>Effects</em>: Initializes <code class="sourceCode cpp"><em>base_</em></code> with <code class="sourceCode cpp">std<span class="op">::</span>move<span class="op">(</span>base<span class="op">)</span></code>.</p>
</blockquote>
<h3 data-number="4.1.4" id="feature-test-macro"><span class="header-section-number">4.1.4</span> Feature-test macro<a href="#feature-test-macro" class="self-link"></a></h3>
<p>Add the following macro definition to <span>17.3.2 <a href="https://wg21.link/version.syn">[version.syn]</a></span>, with the value selected by the editor to reflect the date of adoption of this paper:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb64-1"><a href="#cb64-1"></a><span class="pp">#define __cpp_lib_ranges_all_const </span><span class="dv">20</span><span class="er">XXXXL</span><span class="pp"> </span><span class="co">// also in &lt;ranges&gt;</span></span></code></pre></div>
<h1 data-number="5" style="border-bottom:1px solid #cccccc" id="epilogue"><span class="header-section-number">5</span> Epilogue<a href="#epilogue" class="self-link"></a></h1>
<p>Thanks to Tim Song for helping me work through the design and implementation details of this paper. Thanks to Peter Dimov and Tomasz Kamiński for insisting on design sanity (even as they insisted on different designs) and providing feedback. Thanks to Eric Niebler for having already solved the problem of how to come up with the right reference type for a <code class="sourceCode cpp">const_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span></code> in range-v3.</p>
<h1 data-number="6" style="border-bottom:1px solid #cccccc" id="bibliography"><span class="header-section-number">6</span> References<a href="#bibliography" class="self-link"></a></h1>
<div id="refs" class="references hanging-indent" role="doc-bibliography">
<div id="ref-coerce-const">
<p>[coerce-const] Barry Revzin. 2021. Coercing deep const-ness. <br />
<a href="https://brevzin.github.io/c++/2021/09/10/deep-const/">https://brevzin.github.io/c++/2021/09/10/deep-const/</a></p>
</div>
<div id="ref-const-impl">
<p>[const-impl] Barry Revzin. 2020. Implementing <code class="sourceCode cpp">cbegin</code>, <code class="sourceCode cpp">cend</code>, and <code class="sourceCode cpp">const_view</code>. <br />
<a href="https://godbolt.org/z/x7o5dvM36">https://godbolt.org/z/x7o5dvM36</a></p>
</div>
<div id="ref-LWG2128">
<p>[LWG2128] Dmitry Polukhin. Absence of global functions cbegin/cend. <br />
<a href="https://wg21.link/lwg2128">https://wg21.link/lwg2128</a></p>
</div>
<div id="ref-LWG3320">
<p>[LWG3320] Poland. span::cbegin/cend methods produce different results than std::[ranges::]cbegin/cend. <br />
<a href="https://wg21.link/lwg3320">https://wg21.link/lwg3320</a></p>
</div>
<div id="ref-LWG3386">
<p>[LWG3386] Tim Song. elements_view needs its own sentinel type. <br />
<a href="https://wg21.link/lwg3386">https://wg21.link/lwg3386</a></p>
</div>
<div id="ref-N1674">
<p>[N1674] Walter E. Brown. 2004-08-31. A Proposal to Improve const_iterator Use from C++0X Containers. <br />
<a href="https://wg21.link/n1674">https://wg21.link/n1674</a></p>
</div>
<div id="ref-N1913">
<p>[N1913] Walter E. Brown. 2005-10-20. A Proposal to Improve const_iterator Use (version 3). <br />
<a href="https://wg21.link/n1913">https://wg21.link/n1913</a></p>
</div>
<div id="ref-N4380">
<p>[N4380] ADAM David Alan Martin, Alisdair Meredith. 2015-02-05. Constant View: A proposal for a std::as_const helper function template. <br />
<a href="https://wg21.link/n4380">https://wg21.link/n4380</a></p>
</div>
<div id="ref-P0122R7">
<p>[P0122R7] Neil MacIntosh, Stephan T. Lavavej. 2018-03-16. span: bounds-safe views for sequences of objects. <br />
<a href="https://wg21.link/p0122r7">https://wg21.link/p0122r7</a></p>
</div>
<div id="ref-P0896R4">
<p>[P0896R4] Eric Niebler, Casey Carter, Christopher Di Bella. 2018-11-09. The One Ranges Proposal. <br />
<a href="https://wg21.link/p0896r4">https://wg21.link/p0896r4</a></p>
</div>
<div id="ref-P1035R7">
<p>[P1035R7] Christopher Di Bella, Casey Carter, Corentin Jabot. 2019-08-02. Input Range Adaptors. <br />
<a href="https://wg21.link/p1035r7">https://wg21.link/p1035r7</a></p>
</div>
<div id="ref-P1255R6">
<p>[P1255R6] Steve Downey. 2020-04-05. A view of 0 or 1 elements: views::maybe. <br />
<a href="https://wg21.link/p1255r6">https://wg21.link/p1255r6</a></p>
</div>
<div id="ref-P2210R0">
<p>[P2210R0] Barry Revzin. 2020-08-14. Superior String Splitting. <br />
<a href="https://wg21.link/p2210r0">https://wg21.link/p2210r0</a></p>
</div>
<div id="ref-P2259R0">
<p>[P2259R0] Tim Song. 2020-11-20. Repairing input range adaptors and counted_iterator. <br />
<a href="https://wg21.link/p2259r0">https://wg21.link/p2259r0</a></p>
</div>
<div id="ref-p2278-minutes">
<p>[p2278-minutes] LEWG. 2021. LEWG minutes for P2278. <br />
<a href="https://wiki.edg.com/bin/view/Wg21telecons2021/P2278#Library-Evolution-2021-11-09">https://wiki.edg.com/bin/view/Wg21telecons2021/P2278#Library-Evolution-2021-11-09</a></p>
</div>
<div id="ref-P2278R0">
<p>[P2278R0] Barry Revzin. 2021-01-10. cbegin should always return a constant iterator. <br />
<a href="https://wg21.link/p2278r0">https://wg21.link/p2278r0</a></p>
</div>
<div id="ref-P2278R1">
<p>[P2278R1] Barry Revzin. 2021-09-15. cbegin should always return a constant iterator. <br />
<a href="https://wg21.link/p2278r1">https://wg21.link/p2278r1</a></p>
</div>
<div id="ref-P2287R1">
<p>[P2287R1] Barry Revzin. 2021-02-15. Designated-initializers for base classes. <br />
<a href="https://wg21.link/p2287r1">https://wg21.link/p2287r1</a></p>
</div>
<div id="ref-P2321R2">
<p>[P2321R2] Tim Song. 2021-06-11. zip. <br />
<a href="https://wg21.link/p2321r2">https://wg21.link/p2321r2</a></p>
</div>
<div id="ref-P2415R2">
<p>[P2415R2] Barry Revzin, Tim Song. 2021-10-15. What is a view? <br />
<a href="https://wg21.link/p2415r2">https://wg21.link/p2415r2</a></p>
</div>
</div>
</div>
</div>
</body>
</html>
