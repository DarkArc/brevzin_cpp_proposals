<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="mpark/wg21" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Scalable Reflection in C++</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
      div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
      ul.task-list{list-style: none;}
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode
        {  background-color: #f6f8fa; }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span. { } /* Normal */
      code span.al { color: #ff0000; } /* Alert */
      code span.an { } /* Annotation */
      code span.at { } /* Attribute */
      code span.bn { color: #9f6807; } /* BaseN */
      code span.bu { color: #9f6807; } /* BuiltIn */
      code span.cf { color: #00607c; } /* ControlFlow */
      code span.ch { color: #9f6807; } /* Char */
      code span.cn { } /* Constant */
      code span.co { color: #008000; font-style: italic; } /* Comment */
      code span.cv { color: #008000; font-style: italic; } /* CommentVar */
      code span.do { color: #008000; } /* Documentation */
      code span.dt { color: #00607c; } /* DataType */
      code span.dv { color: #9f6807; } /* DecVal */
      code span.er { color: #ff0000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #9f6807; } /* Float */
      code span.fu { } /* Function */
      code span.im { } /* Import */
      code span.in { color: #008000; } /* Information */
      code span.kw { color: #00607c; } /* Keyword */
      code span.op { color: #af1915; } /* Operator */
      code span.ot { } /* Other */
      code span.pp { color: #6f4e37; } /* Preprocessor */
      code span.re { } /* RegionMarker */
      code span.sc { color: #9f6807; } /* SpecialChar */
      code span.ss { color: #9f6807; } /* SpecialString */
      code span.st { color: #9f6807; } /* String */
      code span.va { } /* Variable */
      code span.vs { color: #9f6807; } /* VerbatimString */
      code span.wa { color: #008000; font-weight: bold; } /* Warning */
      code.diff {color: #898887}
      code.diff span.va {color: #006e28}
      code.diff span.st {color: #bf0303}
  </style>
  <style type="text/css">
body {
margin: 5em;
font-family: serif;

hyphens: auto;
line-height: 1.35;
}
div.wrapper {
max-width: 60em;
margin: auto;
}
ul {
list-style-type: none;
padding-left: 2em;
margin-top: -0.2em;
margin-bottom: -0.2em;
}
a {
text-decoration: none;
color: #4183C4;
}
a.hidden_link {
text-decoration: none;
color: inherit;
}
li {
margin-top: 0.6em;
margin-bottom: 0.6em;
}
h1, h2, h3, h4 {
position: relative;
line-height: 1;
}
a.self-link {
position: absolute;
top: 0;
left: calc(-1 * (3.5rem - 26px));
width: calc(3.5rem - 26px);
height: 2em;
text-align: center;
border: none;
transition: opacity .2s;
opacity: .5;
font-family: sans-serif;
font-weight: normal;
font-size: 83%;
}
a.self-link:hover { opacity: 1; }
a.self-link::before { content: "§"; }
ul > li:before {
content: "\2014";
position: absolute;
margin-left: -1.5em;
}
:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }
.abbr_ref { float: right; }
.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }
:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }
.secnum { display: inline-block; min-width: 35pt; }
.header-section-number { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }
div.sourceLinkParent {
float: right;
}
a.sourceLink {
position: absolute;
opacity: 0;
margin-left: 10pt;
}
a.sourceLink:hover {
opacity: 1;
}
a.itemDeclLink {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
opacity: 0;
}
a.itemDeclLink:hover { opacity: 1; }
span.marginalizedparent {
position: relative;
left: -5em;
}
li span.marginalizedparent { left: -7em; }
li ul > li span.marginalizedparent { left: -9em; }
li ul > li ul > li span.marginalizedparent { left: -11em; }
li ul > li ul > li ul > li span.marginalizedparent { left: -13em; }
div.footnoteNumberParent {
position: relative;
left: -4.7em;
}
a.marginalized {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
}
a.enumerated_item_num {
position: relative;
left: -3.5em;
display: inline-block;
margin-right: -3em;
text-align: right;
width: 3em;
}
div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }
span.indexparent {
display: inline;
position: relative;
float: right;
right: -1em;
}
a.index {
position: absolute;
display: none;
}
a.index:before { content: "⟵"; }

a.index:target {
display: inline;
}
.indexitems {
margin-left: 2em;
text-indent: -2em;
}
div.itemdescr {
margin-left: 3em;
}
.bnf {
font-family: serif;
margin-left: 40pt;
margin-top: 0.5em;
margin-bottom: 0.5em;
}
.ncbnf {
font-family: serif;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
}
.ncsimplebnf {
font-family: serif;
font-style: italic;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
background: inherit; 
}
span.textnormal {
font-style: normal;
font-family: serif;
white-space: normal;
display: inline-block;
}
span.rlap {
display: inline-block;
width: 0px;
}
span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }
span.phantom { color: white; }

span.math { font-style: normal; }
span.mathblock {
display: block;
margin-left: auto;
margin-right: auto;
margin-top: 1.2em;
margin-bottom: 1.2em;
text-align: center;
}
span.mathalpha {
font-style: italic;
}
span.synopsis {
font-weight: bold;
margin-top: 0.5em;
display: block;
}
span.definition {
font-weight: bold;
display: block;
}
.codeblock {
margin-left: 1.2em;
line-height: 127%;
}
.outputblock {
margin-left: 1.2em;
line-height: 127%;
}
div.itemdecl {
margin-top: 2ex;
}
code.itemdeclcode {
white-space: pre;
display: block;
}
span.textsuperscript {
vertical-align: super;
font-size: smaller;
line-height: 0;
}
.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }
.footnote {
font-size: small;
margin-left: 2em;
margin-right: 2em;
margin-top: 0.6em;
margin-bottom: 0.6em;
}
div.minipage {
display: inline-block;
margin-right: 3em;
}
div.numberedTable {
text-align: center;
margin: 2em;
}
div.figure {
text-align: center;
margin: 2em;
}
table {
border: 1px solid black;
border-collapse: collapse;
margin-left: auto;
margin-right: auto;
margin-top: 0.8em;
text-align: left;
hyphens: none; 
}
td, th {
padding-left: 1em;
padding-right: 1em;
vertical-align: top;
}
td.empty {
padding: 0px;
padding-left: 1px;
}
td.left {
text-align: left;
}
td.right {
text-align: right;
}
td.center {
text-align: center;
}
td.justify {
text-align: justify;
}
td.border {
border-left: 1px solid black;
}
tr.rowsep, td.cline {
border-top: 1px solid black;
}
tr.even, tr.odd {
border-bottom: 1px solid black;
}
tr.capsep {
border-top: 3px solid black;
border-top-style: double;
}
tr.header {
border-bottom: 3px solid black;
border-bottom-style: double;
}
th {
border-bottom: 1px solid black;
}
span.centry {
font-weight: bold;
}
div.table {
display: block;
margin-left: auto;
margin-right: auto;
text-align: center;
width: 90%;
}
span.indented {
display: block;
margin-left: 2em;
margin-bottom: 1em;
margin-top: 1em;
}
ol.enumeratea { list-style-type: none; background: inherit; }
ol.enumerate { list-style-type: none; background: inherit; }

code.sourceCode > span { display: inline; }
</style>
  <style type="text/css">a {
color : #4183C4;
text-decoration: underline;
}
a.marginalized {
text-decoration: none;
}
a.self-link {
text-decoration: none;
}
h1#toctitle {
border-bottom: 1px solid #cccccc;
}
#TOC li {
margin-top: 1px;
margin-bottom: 1px;
}
#TOC ul>li:before { display: none; }
h3.subtitle { margin-top: -15px; }
h1:target { background-color: transparent; }
h2:target { background-color: transparent; }
h3:target { background-color: transparent; }
h4:target { background-color: transparent; }
h5:target { background-color: transparent; }
h6:target { background-color: transparent; }
code span.co { font-family: monospace; }
table tr {
background-color: white;
}
table tr:nth-child(2n) {
background-color: #f6f8fa;
}
#title-block-header > table tr:nth-child(2n) {
background-color: white;
}
td > div.sourceCode {
background-color: inherit;
}
table {
border-collapse: collapse;
}
table td, table th {
border: 1px solid #cccccc;
}
table th {
border-bottom: 1px solid black;
text-align: center;
}
table tr:first-child th {
border-top: 0;
}
table tr:last-child td {
border-bottom: 0;
}
table tr td:first-child,
table tr th:first-child {
border-left: 0;
}
table tr td:last-child,
table tr th:last-child {
border-right: 0;
}
table tbody tr:first-child td {
border-top: 1px solid black;
}
#title-block-header td { border: 0; }
@media all {
body {
margin: 2em;
}
}
@media screen and (min-width: 480px) {
body {
margin: 5em;
}
}
#refs code{padding-left: 0px; text-indent: 0px;}
:root {
--diff-ins: #e6ffed;
--diff-strongins: #acf2bd;
--diff-del: #ffdddd;
--diff-strongdel: #ff8888;
}
span.diffins {
background-color: var(--diff-strongins);
}
span.diffdel {
background-color: var(--diff-strongdel);
}
div.rm { text-decoration: line-through; }
div.rm code.sourceCode { text-decoration: line-through; }
div.addu, span.addu {
color: #006e28;
background-color: var(--diff-ins);
}

div.rm pre, div.add pre { background-color: #f6f8fa; }
div.addu pre { background-color: var(--diff-ins); }
div.add, div.add pre { background-color: var(--diff-ins); }
div.addu blockquote {
border-left: 4px solid #00a000;
padding: 0 15px;
color: #006e28;
text-decoration: none;
}
div.addu blockquote code.sourceCode { text-decoration: none; }
div.addu blockquote pre { text-decoration: none; }
div.addu blockquote pre code { text-decoration: none; }
div.quote {
border-left: 7px solid #ccc;
background: #f9f9f9;
margin: 1.5em 10px;
padding-left: 20px;
}
code.diff span.va { color: #000000; background-color: var(--diff-ins); }
code.diff span.st { color: #000000; background-color: var(--diff-del); }
</style>
  <link href="data:image/x-icon;base64,AAABAAIAEBAAAAEAIABoBAAAJgAAACAgAAABACAAqBAAAI4EAAAoAAAAEAAAACAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAVoJEAN6CRADegkQAWIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wCCRAAAgkQAAIJEAACCRAAsgkQAvoJEAP+CRAD/gkQA/4JEAP+CRADAgkQALoJEAACCRAAAgkQAAP///wD///8AgkQAAIJEABSCRACSgkQA/IJEAP99PQD/dzMA/3czAP99PQD/gkQA/4JEAPyCRACUgkQAFIJEAAD///8A////AHw+AFiBQwDqgkQA/4BBAP9/PxP/uZd6/9rJtf/bybX/upd7/39AFP+AQQD/gkQA/4FDAOqAQgBc////AP///wDKklv4jlEa/3o7AP+PWC//8+3o///////////////////////z7un/kFox/35AAP+GRwD/mVYA+v///wD///8A0Zpk+NmibP+0d0T/8evj///////+/fv/1sKz/9bCs//9/fr//////+/m2/+NRwL/nloA/5xYAPj///8A////ANKaZPjRmGH/5cKh////////////k149/3UwAP91MQD/lmQ//86rhv+USg3/m1YA/5hSAP+bVgD4////AP///wDSmmT4zpJY/+/bx///////8+TV/8mLT/+TVx//gkIA/5lVAP+VTAD/x6B//7aEVv/JpH7/s39J+P///wD///8A0ppk+M6SWP/u2sf///////Pj1f/Nj1T/2KFs/8mOUv+eWhD/lEsA/8aee/+0glT/x6F7/7J8Rvj///8A////ANKaZPjRmGH/48Cf///////+/v7/2qt//82PVP/OkFX/37KJ/86siv+USg7/mVQA/5hRAP+bVgD4////AP///wDSmmT40ppk/9CVXP/69O////////7+/v/x4M//8d/P//7+/f//////9u7n/6tnJf+XUgD/nFgA+P///wD///8A0ppk+NKaZP/RmWL/1qNy//r07///////////////////////+vXw/9akdP/Wnmn/y5FY/6JfFvj///8A////ANKaZFTSmmTo0ppk/9GYYv/Ql1//5cWm//Hg0P/x4ND/5cWm/9GXYP/RmGH/0ppk/9KaZOjVnmpY////AP///wDSmmQA0ppkEtKaZI7SmmT60ppk/9CWX//OkVb/zpFW/9CWX//SmmT/0ppk/NKaZJDSmmQS0ppkAP///wD///8A0ppkANKaZADSmmQA0ppkKtKaZLrSmmT/0ppk/9KaZP/SmmT/0ppkvNKaZCrSmmQA0ppkANKaZAD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkUtKaZNzSmmTc0ppkVNKaZADSmmQA0ppkANKaZADSmmQA////AP5/AAD4HwAA4AcAAMADAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAMADAADgBwAA+B8AAP5/AAAoAAAAIAAAAEAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAyCRACMgkQA6oJEAOqCRACQgkQAEIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRABigkQA5oJEAP+CRAD/gkQA/4JEAP+CRADqgkQAZoJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAA4gkQAwoJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQAxIJEADyCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAP///wD///8A////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAWgkQAmIJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAJyCRAAYgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAdIJEAPCCRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAPSCRAB4gkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQASoJEANKCRAD/gkQA/4JEAP+CRAD/g0YA/39AAP9zLgD/bSQA/2shAP9rIQD/bSQA/3MuAP9/PwD/g0YA/4JEAP+CRAD/gkQA/4JEAP+CRADUgkQAToJEAACCRAAAgkQAAP///wD///8A////AP///wB+PwAAgkUAIoJEAKiCRAD/gkQA/4JEAP+CRAD/hEcA/4BBAP9sIwD/dTAA/5RfKv+viF7/vp56/76ee/+wiF7/lWAr/3YxAP9sIwD/f0AA/4RHAP+CRAD/gkQA/4JEAP+CRAD/gkQArIJEACaBQwAA////AP///wD///8A////AIBCAEBzNAD6f0EA/4NFAP+CRAD/gkQA/4VIAP92MwD/bSUA/6N1Tv/ezsL/////////////////////////////////38/D/6V3Uv9uJgD/dTEA/4VJAP+CRAD/gkQA/4JEAP+BQwD/fUAA/4FDAEj///8A////AP///wD///8AzJRd5qBlKf91NgD/dDUA/4JEAP+FSQD/cy4A/3YyAP/PuKP//////////////////////////////////////////////////////9K7qP94NQD/ciwA/4VJAP+CRAD/fkEA/35BAP+LSwD/mlYA6v///wD///8A////AP///wDdpnL/4qx3/8KJUv+PUhf/cTMA/3AsAP90LgD/4dK+/////////////////////////////////////////////////////////////////+TYxf91MAD/dTIA/31CAP+GRwD/llQA/6FcAP+gWwD8////AP///wD///8A////ANGZY/LSm2X/4ap3/92mcP+wdT3/byQA/8mwj////////////////////////////////////////////////////////////////////////////+LYxv9zLgP/jUoA/59bAP+hXAD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/RmWL/1p9q/9ubXv/XqXj////////////////////////////7+fD/vZyG/6BxS/+gcUr/vJuE//r37f//////////////////////3MOr/5dQBf+dVQD/nVkA/5xYAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmWP/yohJ//jo2P//////////////////////4NTG/4JDFf9lGAD/bSQA/20kAP9kGAD/fz8S/+Xb0f//////5NG9/6txN/+LOgD/m1QA/51aAP+cWAD/m1cA/5xYAP+cWADy////AP///wD///8A////ANKaZPLSmmT/0ppk/8+TWf/Unmv//v37//////////////////////+TWRr/VwsA/35AAP+ERgD/g0UA/4JGAP9lHgD/kFga/8KXX/+TRwD/jT4A/49CAP+VTQD/n10A/5xYAP+OQQD/lk4A/55cAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/y4tO/92yiP//////////////////////8NnE/8eCQP+rcTT/ez0A/3IyAP98PgD/gEMA/5FSAP+USwD/jj8A/5lUAP+JNwD/yqV2/694Mf+HNQD/jkAA/82rf/+laBj/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/LiUr/4byY///////////////////////gupX/0I5P/+Wuev/Lklz/l1sj/308AP+QSwD/ol0A/59aAP+aVQD/k0oA/8yoh///////+fXv/6pwO//Lp3v///////Pr4f+oay7y////AP///wD///8A////ANKaZPLSmmT/0ppk/8uJSv/hvJj//////////////////////+G7l//Jhkb/0ppk/96nc//fqXX/x4xO/6dkFP+QSQD/llEA/5xXAP+USgD/yaOA///////38uv/qG05/8ijdv//////8efb/6ZpLPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/zIxO/9yxh///////////////////////7dbA/8iEQf/Sm2X/0Zlj/9ScZv/eqHf/2KJv/7yAQf+XTgD/iToA/5lSAP+JNgD/yKFv/611LP+HNQD/jT8A/8qmeP+kZRT/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/Pk1n/1J5q//78+//////////////////+/fv/1aFv/8iEQv/Tm2b/0ppl/9GZY//Wn2z/1pZc/9eldf/Bl2b/kUcA/4w9AP+OQAD/lUwA/59eAP+cWQD/jT8A/5ZOAP+eXADy////AP///wD///8A////ANKaZPLSmmT/0ppk/9KZY//KiEn/8d/P///////////////////////47+f/05tm/8iCP//KiEj/yohJ/8eCP//RmGH//vfy///////n1sP/rXQ7/4k4AP+TTAD/nVoA/5xYAP+cVwD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/0ptl/8uLTf/aq37////////////////////////////+/fz/6c2y/961jv/etY7/6Myx//78+v//////////////////////3MWv/5xXD/+ORAD/mFQA/51ZAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmmT/0ppk/8mFRP/s1b//////////////////////////////////////////////////////////////////////////////+PD/0JFU/7NzMv+WUQD/kUsA/5tXAP+dWQDy////AP///wD///8A////ANKaZP/SmmT/0ppk/9KaZP/Sm2X/z5NZ/8yMT//z5NX/////////////////////////////////////////////////////////////////9Ofa/8yNUP/UmGH/36p5/8yTWv+qaSD/kksA/5ROAPz///8A////AP///wD///8A0ppk5NKaZP/SmmT/0ppk/9KaZP/TnGf/zY9T/82OUv/t1sD//////////////////////////////////////////////////////+7Yw//OkFX/zI5R/9OcZ//SmmP/26V0/9ymdf/BhUf/ol8R6P///wD///8A////AP///wDSmmQ80ppk9tKaZP/SmmT/0ppk/9KaZP/TnGj/zpFW/8qJSv/dson/8uHS//////////////////////////////////Lj0//etIv/y4lL/86QVf/TnGj/0ppk/9KaZP/RmWP/05xn/9ymdfjUnWdC////AP///wD///8A////ANKaZADSmmQc0ppkotKaZP/SmmT/0ppk/9KaZP/Tm2b/0Zli/8qJSf/NjlH/16Z3/+G8mP/myKr/5siq/+G8mP/Xp3f/zY5S/8qISf/RmGH/05tm/9KaZP/SmmT/0ppk/9KaZP/SmmSm0pljINWdaQD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkQtKaZMrSmmT/0ppk/9KaZP/SmmT/0ptl/9GYYf/Nj1P/y4lL/8qISP/KiEj/y4lK/82PU//RmGH/0ptl/9KaZP/SmmT/0ppk/9KaZP/SmmTO0ppkRtKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZGzSmmTu0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmTw0ppkcNKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZBLSmmSQ0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppklNKaZBTSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQy0ppkutKaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppkvtKaZDbSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkXNKaZODSmmT/0ppk/9KaZP/SmmT/0ppk5NKaZGDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkBtKaZIbSmmTo0ppk6tKaZIrSmmQK0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP/8P///+B///+AH//+AAf//AAD//AAAP/AAAA/gAAAHwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA+AAAAfwAAAP/AAAP/8AAP//gAH//+AH///4H////D//" rel="icon" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
</head>
<body>
<div class="wrapper">
<header id="title-block-header">
<h1 class="title" style="text-align:center">Scalable Reflection in C++</h1>

<table style="border:none;float:right">
  <tr>
    <td>Document #:</td>
    <td>P1240R2</td>
  </tr>
  <tr>
    <td>Date:</td>
    <td>01-15-2022</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Project:</td>
    <td>Programming Language C++</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Audience:</td>
    <td>
      SG7<br>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top">Reply-to:</td>
    <td>
      Wyatt Childers<br>&lt;<a href="mailto:wcc@edg.com" class="email">wcc@edg.com</a>&gt;<br>
      Andrew Sutton<br>&lt;<a href="mailto:Andrew.sutton@beyondidentity.com" class="email">Andrew.sutton@beyondidentity.com</a>&gt;<br>
      Faisal Vali<br>&lt;<a href="mailto:faisalv@yahoo.com" class="email">faisalv@yahoo.com</a>&gt;<br>
      Daveed Vandevoorde<br>&lt;<a href="mailto:daveed@edg.com" class="email">daveed@edg.com</a>&gt;<br>
    </td>
  </tr>
</table>

</header>
<div style="clear:both">
<div id="TOC" role="doc-toc">
<h1 id="toctitle">Contents</h1>
<ul>
<li><a href="#revision-history"><span class="toc-section-number">1</span> Revision history<span></span></a></li>
<li><a href="#acknowledgments"><span class="toc-section-number">2</span> Acknowledgments<span></span></a></li>
<li><a href="#introduction"><span class="toc-section-number">3</span> Introduction<span></span></a>
<ul>
<li><a href="#a-simple-example"><span class="toc-section-number">3.1</span> A simple example<span></span></a></li>
<li><a href="#implementation-status"><span class="toc-section-number">3.2</span> Implementation status<span></span></a></li>
</ul></li>
<li><a href="#reflections"><span class="toc-section-number">4</span> Reflections<span></span></a>
<ul>
<li><a href="#the-operator"><span class="toc-section-number">4.1</span> The <code class="sourceCode cpp"><span class="op">^</span></code> operator<span></span></a></li>
<li><a href="#reflection-type"><span class="toc-section-number">4.2</span> Reflection type<span></span></a></li>
<li><a href="#reflection-categories"><span class="toc-section-number">4.3</span> Reflection categories<span></span></a></li>
<li><a href="#equality-and-equivalence"><span class="toc-section-number">4.4</span> Equality and equivalence<span></span></a></li>
<li><a href="#a-note-about-linkage"><span class="toc-section-number">4.5</span> A Note About Linkage<span></span></a></li>
<li><a href="#invalid-reflections"><span class="toc-section-number">4.6</span> Invalid reflections<span></span></a></li>
<li><a href="#initialization-of-reflections"><span class="toc-section-number">4.7</span> Initialization of reflections<span></span></a></li>
<li><a href="#conversions-on-reflections"><span class="toc-section-number">4.8</span> Conversions on reflections<span></span></a></li>
<li><a href="#hashing-reflections"><span class="toc-section-number">4.9</span> Hashing reflections<span></span></a></li>
</ul></li>
<li><a href="#splicing"><span class="toc-section-number">5</span> Splicing<span></span></a>
<ul>
<li><a href="#splicing-identifiers"><span class="toc-section-number">5.1</span> Splicing identifiers<span></span></a></li>
<li><a href="#access-checking"><span class="toc-section-number">5.2</span> Access checking<span></span></a></li>
</ul></li>
<li><a href="#templates-and-reflection"><span class="toc-section-number">6</span> Templates and reflection<span></span></a>
<ul>
<li><a href="#template-arguments"><span class="toc-section-number">6.1</span> Template arguments<span></span></a></li>
<li><a href="#template-substitution"><span class="toc-section-number">6.2</span> Template substitution<span></span></a></li>
<li><a href="#template-parameters"><span class="toc-section-number">6.3</span> Template parameters<span></span></a></li>
</ul></li>
<li><a href="#the-standard-metaprogramming-library"><span class="toc-section-number">7</span> The standard metaprogramming library<span></span></a>
<ul>
<li><a href="#sequence-and-string-values"><span class="toc-section-number">7.1</span> Sequence and string values<span></span></a></li>
<li><a href="#transcribing-the-standard-librarys-meta-section"><span class="toc-section-number">7.2</span> Transcribing the standard library’s [meta] section<span></span></a></li>
<li><a href="#adapting-the-reflection-ts-reflect-section"><span class="toc-section-number">7.3</span> Adapting the Reflection TS’ [reflect] section<span></span></a>
<ul>
<li><a href="#predicates"><span class="toc-section-number">7.3.1</span> Predicates<span></span></a></li>
<li><a href="#singular-properties"><span class="toc-section-number">7.3.2</span> Singular Properties<span></span></a></li>
<li><a href="#plural-properties"><span class="toc-section-number">7.3.3</span> Plural properties<span></span></a></li>
</ul></li>
<li><a href="#anonymous-unions"><span class="toc-section-number">7.4</span> Anonymous unions<span></span></a></li>
<li><a href="#other-facilities"><span class="toc-section-number">7.5</span> Other Facilities<span></span></a>
<ul>
<li><a href="#reflecting-values"><span class="toc-section-number">7.5.1</span> Reflecting values<span></span></a></li>
</ul></li>
</ul></li>
<li><a href="#metaprogramming-examples"><span class="toc-section-number">8</span> Metaprogramming Examples<span></span></a>
<ul>
<li><a href="#hashing"><span class="toc-section-number">8.1</span> Hashing<span></span></a></li>
<li><a href="#schema-generation"><span class="toc-section-number">8.2</span> Schema generation<span></span></a></li>
<li><a href="#schema-generation-take-two"><span class="toc-section-number">8.3</span> Schema generation (take two)<span></span></a></li>
<li><a href="#template-argument-list-assignment"><span class="toc-section-number">8.4</span> Template argument list assignment<span></span></a></li>
<li><a href="#dealing-more-efficiently-with-parameter-packs"><span class="toc-section-number">8.5</span> Dealing more efficiently with parameter packs<span></span></a></li>
<li><a href="#applying-functions-to-all-members"><span class="toc-section-number">8.6</span> Applying functions to all members<span></span></a></li>
</ul></li>
<li><a href="#appendix-meta-library-synopsis"><span class="toc-section-number">9</span> Appendix: Meta-library synopsis<span></span></a></li>
<li><a href="#bibliography"><span class="toc-section-number">10</span> References<span></span></a></li>
</ul>
</div>
<h1 data-number="1" style="border-bottom:1px solid #cccccc" id="revision-history"><span class="header-section-number">1</span> Revision history<a href="#revision-history" class="self-link"></a></h1>
<p><span class="citation" data-cites="P1240R0">[<a href="#ref-P1240R0" role="doc-biblioref">P1240R0</a>]</span> Initial revision introducing scalar reflection model, reifiers (now called splicers), extensive API, and many examples.</p>
<p><span class="citation" data-cites="P1240R1">[<a href="#ref-P1240R1" role="doc-biblioref">P1240R1</a>]</span> Added <code class="sourceCode cpp">reflexpr<span class="op">(...</span> xyz<span class="op">)</span></code>. Revised reifier/splicer syntax somewhat. Report on implementations. Introduce <code class="sourceCode cpp"><span class="op">&lt;</span>meta<span class="op">&gt;</span></code> header. Reorganized presentation slightly.</p>
<p>R2 (this revision) Harmonized with other papers in this area, including the use of the term “splicing” instead of “reifying” and the syntax developed in <span class="citation" data-cites="P2320R0">[<a href="#ref-P2320R0" role="doc-biblioref">P2320R0</a>]</span>. Various fixes and presentation improvements.</p>
<h1 data-number="2" style="border-bottom:1px solid #cccccc" id="acknowledgments"><span class="header-section-number">2</span> Acknowledgments<a href="#acknowledgments" class="self-link"></a></h1>
<p>Many thanks to Nina Ranns and Barry Revzin for significant feedback on a draft of this paper.</p>
<h1 data-number="3" style="border-bottom:1px solid #cccccc" id="introduction"><span class="header-section-number">3</span> Introduction<a href="#introduction" class="self-link"></a></h1>
<p>The first Reflection TS (based on <span class="citation" data-cites="N4766">[<a href="#ref-N4766" role="doc-biblioref">N4766</a>]</span>) exposes reflection information as types (to simplify integration with template metaprogramming techniques). However, SG7 agreed some time ago that the future of reflective constructs in C++ should be value-based (see also <span class="citation" data-cites="P0425R0">[<a href="#ref-P0425R0" role="doc-biblioref">P0425R0</a>]</span>). Specifically, the compile-time computations required for reflective metaprogramming should make use of constant-evaluation, which, unlike template metaprogramming, allows for ephemeral intermediate results (i.e., they don’t persist throughout the compilation process) and for mutable values. This approach was described in <span class="citation" data-cites="P0993R0">[<a href="#ref-P0993R0" role="doc-biblioref">P0993R0</a>]</span>, <em>Value-based Reflection</em>. To support that reflection design, we have passed a number of <code class="sourceCode cpp"><span class="kw">constexpr</span></code> extensions in C++20: consteval functions (<span class="citation" data-cites="P1073R3">[<a href="#ref-P1073R3" role="doc-biblioref">P1073R3</a>]</span>), <code class="sourceCode cpp">std<span class="op">::</span>is_constant_evaluated<span class="op">()</span></code> (<span class="citation" data-cites="P0595R2">[<a href="#ref-P0595R2" role="doc-biblioref">P0595R2</a>]</span>), and constexpr dynamic allocation (<span class="citation" data-cites="P0784R7">[<a href="#ref-P0784R7" role="doc-biblioref">P0784R7</a>]</span>), amongst others. We have also proposed <em>expansion statements</em> (<span class="citation" data-cites="P1306R1">[<a href="#ref-P1306R1" role="doc-biblioref">P1306R1</a>]</span>), which are more broadly useful but especially convenient for reflective metaprogramming: That feature was approved by the evolution working group for C++20, but did not make it to a WG21 vote for lack of time completing the Core wording review. We still hope expansion statements will be added to the language in the relatively near future.</p>
<p>That in itself still leaves plenty of design options for the reflection interface itself. What follows is an extensive document describing:</p>
<ul>
<li>The representation and properties of “reflections” (with argumentation for our specific design and considerations of alternatives).</li>
<li>Mechanisms for <em>splicing</em>: Turning reflections into ordinary C++ source constructs (again, with design discussions).</li>
<li>A brief discussion about templates and their instances.</li>
<li>Principles to translate existing standard template metaprogramming facilities to the reflection domain.</li>
<li>Principles to translate the Reflection TS facilities to the value-based reflection domain.</li>
<li>Some examples to argue that proposals to add additional template metaprogramming facilities are unneeded because the underlying functionality is better handled in the reflection domain.</li>
<li>An appendix listing the meta-functions being worked on one ongoing implementation.</li>
</ul>
<p>This paper doesn’t exist in a vacuum. Related topics have been separately explored in <span class="citation" data-cites="P2320R0">[<a href="#ref-P2320R0" role="doc-biblioref">P2320R0</a>]</span> (“The Syntax of Static Reflection”), <span class="citation" data-cites="P2237R0">[<a href="#ref-P2237R0" role="doc-biblioref">P2237R0</a>]</span> (“Metaprogramming”), <span class="citation" data-cites="P2050R0">[<a href="#ref-P2050R0" role="doc-biblioref">P2050R0</a>]</span> (“Tweaks to the design of source code fragments”), <span class="citation" data-cites="P1717R0">[<a href="#ref-P1717R0" role="doc-biblioref">P1717R0</a>]</span> (“Compile-time Metaprogramming in C++”), and <span class="citation" data-cites="P1306R1">[<a href="#ref-P1306R1" role="doc-biblioref">P1306R1</a>]</span> (“Expansion statements”). Earlier versions of this paper were more exploratory in nature; this version uses experience with implementations based on earlier versions to narrow down a first set of metaprogramming features that are primarily aimed at providing reflection facilities (with splicing and ordinary template instantiation handling generative programming). However, additional facilities (particularly, for code injection) have been explored along with this proposal and we are not confident that they can be added incrementally on top of this proposal.</p>
<h2 data-number="3.1" id="a-simple-example"><span class="header-section-number">3.1</span> A simple example<a href="#a-simple-example" class="self-link"></a></h2>
<p>The following function uses static reflection facilities presented in this paper to compute the string representation of an enumerator value.</p>
<blockquote>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="pp">#include </span><span class="im">&lt;meta&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">template</span><span class="op">&lt;</span>Enum T<span class="op">&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>std<span class="op">::</span>string to_string<span class="op">(</span>T value<span class="op">)</span> <span class="op">{</span> <span class="co">// Could also be marked constexpr</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>  <span class="kw">template</span> <span class="cf">for</span> <span class="op">(</span><span class="kw">constexpr</span> <span class="kw">auto</span> e <span class="op">:</span> std<span class="op">::</span>meta<span class="op">::</span>members_of<span class="op">(^</span>T<span class="op">))</span> <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>    <span class="cf">if</span> <span class="op">([:</span>e<span class="op">:]</span> <span class="op">==</span> value<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>      <span class="cf">return</span> std<span class="op">::</span>string<span class="op">(</span>std<span class="op">::</span>meta<span class="op">::</span>name_of<span class="op">(</span>e<span class="op">))</span>;</span>
<span id="cb1-8"><a href="#cb1-8"></a>    <span class="op">}</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>  <span class="op">}</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>  <span class="cf">return</span> <span class="st">&quot;&lt;unnamed&gt;&quot;</span>;</span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>In broad strokes, the function does the following:</p>
<ol type="1">
<li>Gets the sequence enumerators from the enumeration type <code class="sourceCode cpp">T</code>,</li>
<li>Iterates over those enumerators, searching for the first that matches <code class="sourceCode cpp">value</code>,</li>
<li>Returns the name of that iterator.</li>
</ol>
<p>Each of these operations relies on a feature included in this proposal. In particular, getting the sequence of iterators requires that we first get a queryable representation of the enumeration type <code class="sourceCode cpp">T</code>. This is done using the prefix <code class="sourceCode cpp"><span class="op">^</span></code> operator; it returns a <em>reflection</em>: a handle to an internal representation of type <code class="sourceCode cpp">T</code> maintained by the compiler. The <code class="sourceCode cpp">members_of</code> function (declared in a newly proposed standard header <code class="sourceCode cpp"><span class="op">&lt;</span>meta<span class="op">&gt;</span></code>) returns a compile-time <code class="sourceCode cpp">std<span class="op">::</span>span</code>, whose elements are the reflections of each enumerator in the enum.</p>
<p>To iterate over the span we use an <em>expansion-statement</em> (proposed through a separate paper <span class="citation" data-cites="P1306R1">[<a href="#ref-P1306R1" role="doc-biblioref">P1306R1</a>]</span>, and previously approved by EWG but still in CWG review), spelled <code class="sourceCode cpp"><span class="kw">template</span> <span class="cf">for</span></code>. This isn’t true “iteration”, however. The body of the statement is repeated for each element in the <code class="sourceCode cpp">span</code> so that the loop variable (<code class="sourceCode cpp">e</code> above) is initialized to <code class="sourceCode cpp">s<span class="op">[</span><span class="dv">0</span><span class="op">]</span></code>, <code class="sourceCode cpp">s<span class="op">[</span><span class="dv">1</span><span class="op">]</span></code>, …, <code class="sourceCode cpp">s<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">]</span></code> in each successive repetition. The expansion variable is declared <code class="sourceCode cpp"><span class="kw">constexpr</span></code> and that carries into each repeated body. In other words, each repetition is equivalent to:</p>
<blockquote>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>  <span class="kw">constexpr</span> std<span class="op">::</span>meta<span class="op">::</span>info e <span class="op">=</span> s<span class="op">[</span>I<span class="op">]</span>;</span>
<span id="cb2-3"><a href="#cb2-3"></a>  <span class="cf">if</span> <span class="op">([:</span>e<span class="op">:]</span> <span class="op">==</span> value<span class="op">)</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>    <span class="cf">return</span> std<span class="op">::</span>meta<span class="op">::</span>name_of<span class="op">(</span>e<span class="op">)</span>;</span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>where <code class="sourceCode cpp">I</code> counts the repetitions of the loop’s body.</p>
<p>Within the expansion body, the <code class="sourceCode cpp"><span class="op">[:</span> refl <span class="op">:]</span></code> construct recovers the value of a reflected entity. We call this recovery process <em>splicing</em> and the constructs — like <code class="sourceCode cpp"><span class="op">[:...:]</span></code> — that enable it <em>splicers</em>. This can be compared with the parameter <code class="sourceCode cpp">value</code> to determine if they are the same. Finally, the <code class="sourceCode cpp">name_of</code> function returns a compile-time <code class="sourceCode cpp">string_view</code> for the identifier spelling of the matched enumerator. If none of the enumerators matched (possible, e.g., when bit-ORing together enumerator values), we return a string <code class="sourceCode cpp"><span class="st">&quot;&lt;unnamed&gt;&quot;</span></code> (which won’t collide with a valid identifier).</p>
<p>This is called <em>static reflection</em> because all of the operations used to query types and enumerators are computed at compile time (i.e., statically). There is no additional runtime meta-information that must be generated with such facilities, which reinforces the zero-overhead principle that is so fundamental to C++. There is no runtime representation of the enumeration type and its enumerators. Only information that is ODR-used is present in the final program.</p>
<h2 data-number="3.2" id="implementation-status"><span class="header-section-number">3.2</span> Implementation status<a href="#implementation-status" class="self-link"></a></h2>
<p>Two implementations of this proposal are underway.</p>
<p>The first and most complete is a fork of Clang by Lock3 Software (by, among others, Andrew and Wyatt, authors of this paper). It includes a large portion of the capabilities presented here, albeit not always with the exact syntax or interfaces proposed. In addition to these capabilities, Lock3’s implementation supports expansion statements and injection primitives (including “fragment” support). Lock3 is currently not maintaining this implementation, however.</p>
<p>The second is based on the EDG front end (by Faisal and Daveed) and is less complete: It implements the reflection operator and most single splicers (but not the pack splicers; see below), and a few meta-library interfaces. It does not currently implement features in other proposals like expansion statements or injection primitives.</p>
<h1 data-number="4" style="border-bottom:1px solid #cccccc" id="reflections"><span class="header-section-number">4</span> Reflections<a href="#reflections" class="self-link"></a></h1>
<h2 data-number="4.1" id="the-operator"><span class="header-section-number">4.1</span> The <code class="sourceCode cpp"><span class="op">^</span></code> operator<a href="#the-operator" class="self-link"></a></h2>
<p>The first Reflection TS introduced the <code class="sourceCode cpp">reflexpr</code> operator to obtain reflection values encoded as types. Previous versions of this paper attempted to avoid repeating the considerable bikeshedding that went into selecting the <code class="sourceCode cpp">reflexpr</code> keyword by simply reusing it. Ironically, the spelling is more appropriate for the value-based reflection since the corresponding operation is indeed an “expression” (i.e., a construct that produces a value; in the TS it produces a type).</p>
<p>However, with months of practice with implementations that used <code class="sourceCode cpp">reflexpr<span class="op">(...)</span></code> we experienced consistent feedback that that syntax is too “heavy”. So we went back to the drawing board and found that the <code class="sourceCode cpp"><span class="op">^</span></code> prefix operator — suggesting “lifting” or “raising” representation — is available . This new syntax<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> was agreed to by SG-7 during the discussion of <span class="citation" data-cites="P2320R0">[<a href="#ref-P2320R0" role="doc-biblioref">P2320R0</a>]</span>. Thus, we can write:</p>
<blockquote>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">constexpr</span> std<span class="op">::</span>meta<span class="op">::</span>info reflection <span class="op">=</span> <span class="op">^</span>name_or_postfix_expr;</span></code></pre></div>
</blockquote>
<p>The value of <code class="sourceCode cpp">reflection</code> (i.e. the result of this <em>lifting operator</em>) is a compile-time value that <em>designates</em> some view of the indicated program element by the implementation (specifically, the compiler front end). I.e., it can be thought of as a handle to an internal structure of the compiler. In the rest of this proposal, we refer to the result of <code class="sourceCode cpp"><span class="op">^</span></code> as a <em>reflection</em> or a <em>reflection value</em>.</p>
<p>Note that the lifting operator is the “gateway” into the reflected world, but it is not the only source of reflections (or reflection values): We will further introduce a variety of functions that derive reflections from other reflections (e.g., we’ll present a function that returns reflections for the members of a class given a reflection for that class). Whatever the source of a reflection, we say that it <em>designates</em> language concepts such as entities or value categories. As will be shown later, a reflection can <em>designate</em> multiple notions. For example, <code class="sourceCode cpp"><span class="op">^</span>f<span class="op">(</span>x<span class="op">)</span></code> designates the called function <code class="sourceCode cpp">f</code> (if indeed that is what is called) and the type and value category of the call result.</p>
<p>The operand of <code class="sourceCode cpp"><span class="op">^</span></code> must be one of the following:</p>
<ul>
<li>a <em>type-id</em>, including possibly a <em>simple-type-specifier</em> that designates a <em>template-name</em></li>
<li>a possibly qualified <em>namespace-name</em></li>
<li>the scope-qualifier token <code class="sourceCode cpp"><span class="op">::</span></code> (designating the global namespace)</li>
<li>a <em>postfix-expression</em><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></li>
</ul>
<p>In the case where the <code class="sourceCode cpp">name_or_postfix_expr</code> is an expression, it is unevaluated but <em>potentially constant evaluated</em>. That implies that given <code class="sourceCode cpp"><span class="kw">struct</span> S <span class="op">{</span> <span class="dt">int</span> x; <span class="op">}</span>;</code>, the expression <code class="sourceCode cpp"><span class="op">^</span>S<span class="op">::</span>x</code> is permissible in this context. We will elaborate the available reflected semantics later in this paper. Since <code class="sourceCode cpp"><span class="op">^</span>name_or_postfix_expr</code> is an expression, <code class="sourceCode cpp"><span class="op">^(^</span>name_or_postfix_expr<span class="op">)</span></code> is also valid (generally producing a distinct reflection).</p>
<p>In this paper, we call <em>declared entity</em> any of the following: a namespace (but not a namespace alias), a function or member function (that includes implicit special members, but not inherited constructors), a function or template parameter, a variable, a type (but not a type alias), a data member, a base class, a capture, or a template (including an alias template, but not a deduction guide template). Note that this is slightly different from the standard term entity (which, e.g., includes “values” but not “captures”<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> ). We call <em>alias</em> a namespace alias or a type alias.</p>
<h2 data-number="4.2" id="reflection-type"><span class="header-section-number">4.2</span> Reflection type<a href="#reflection-type" class="self-link"></a></h2>
<p>What should the type of a reflection be? We propose it to be a new scalar type<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>, distinct from all other scalar types, that supports — aside from reading, assigning, and copying — only the scalar operations of equality/inequality and contextual conversion to <code class="sourceCode cpp"><span class="dt">bool</span></code>. In addition we propose specific splicers (that transform a reflection value into a type or a name, see below) and library functions that can operate on constexpr reflections and constexpr sequences of reflections and generate new reflection-values as needed. All other operations on reflection values are then composed from these aforementioned operations. We present our rationale below for this design choice.</p>
<p>It is tempting to organize reflection values as class type values using a hierarchy of class types that try to model the language constructs. For example, one could imagine a base class <code class="sourceCode cpp">Reflection</code>, from which we might derive a class <code class="sourceCode cpp">ReflectedDeclaration</code>, itself the base class of <code class="sourceCode cpp">ReflectedFunction</code> and <code class="sourceCode cpp">ReflectedVariable</code>.</p>
<p>We do not believe that is the best approach for at least the following reasons:</p>
<ul>
<li>Although the relationship between major language concepts is relatively stable, we do occasionally make fundamental changes to our vocabulary (e.g., during the C++11 cycle we changed the definition of “variable”). Such a vocabulary change is more disruptive to a class hierarchy design than it is to certain other kinds of interfaces (we are thinking of function-based interfaces here).</li>
<li>Class hierarchy values aren’t friendly to value-based programming because of slicing; instead, it works better with “reference” programming, which is particularly expensive for constant evaluation (because it requires address computations, which involve additional bookkeeping to check for potential undefined behavior).</li>
<li>Class types are not easily used as nontype template arguments, particularly when we want to restrict effects to compile time (the recently added support for nontype class-type template arguments (<span class="citation" data-cites="P0732R2">[<a href="#ref-P0732R2" role="doc-biblioref">P0732R2</a>]</span> + <span class="citation" data-cites="P1907R1">[<a href="#ref-P1907R1" role="doc-biblioref">P1907R1</a>]</span>) imposes draconian limitations on class types). As it turns out, instantiating templates over reflection values is an important idiom when it comes to generative programming (e.g., through splicers or, eventually, code injection).</li>
<li>Implementations of constant-evaluation usually handle non-pointer scalar values significantly more efficiently than class values.</li>
</ul>
<p>Regarding this last point, the following compile-time test:</p>
<blockquote>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> f<span class="op">()</span> <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>  <span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span>;</span>
<span id="cb4-3"><a href="#cb4-3"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span>; k<span class="op">&lt;</span><span class="dv">10000</span>; <span class="op">++</span>k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>    i <span class="op">+=</span> k;</span>
<span id="cb4-5"><a href="#cb4-5"></a>  <span class="op">}</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>  <span class="cf">return</span> i<span class="op">/</span><span class="dv">10000</span>;</span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="op">}</span></span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="kw">template</span><span class="op">&lt;</span><span class="dt">int</span> N<span class="op">&gt;</span> <span class="kw">struct</span> S <span class="op">{</span></span>
<span id="cb4-9"><a href="#cb4-9"></a>  <span class="kw">static</span> <span class="kw">constexpr</span> <span class="dt">int</span> sm <span class="op">=</span> S<span class="op">&lt;</span>N<span class="op">-</span><span class="dv">1</span><span class="op">&gt;::</span>sm<span class="op">+</span>f<span class="op">()</span>;</span>
<span id="cb4-10"><a href="#cb4-10"></a><span class="op">}</span>;</span>
<span id="cb4-11"><a href="#cb4-11"></a><span class="kw">template</span><span class="op">&lt;&gt;</span> <span class="kw">struct</span> S<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb4-12"><a href="#cb4-12"></a>  <span class="kw">static</span> <span class="kw">constexpr</span> <span class="dt">int</span> sm <span class="op">=</span> <span class="dv">0</span>;</span>
<span id="cb4-13"><a href="#cb4-13"></a><span class="op">}</span>;</span>
<span id="cb4-14"><a href="#cb4-14"></a><span class="kw">constexpr</span> <span class="dt">int</span> r <span class="op">=</span> S<span class="op">&lt;</span><span class="dv">200</span><span class="op">&gt;::</span>sm;</span></code></pre></div>
</blockquote>
<p>compiles in about 0.6 seconds on a compact laptop (2016 MacBook m7), but wrapping the integers as follows:</p>
<blockquote>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">struct</span> Int <span class="op">{</span> <span class="dt">int</span> v; <span class="op">}</span>;</span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="kw">constexpr</span> <span class="dt">int</span> f<span class="op">()</span> <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>  Int i <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">}</span>;</span>
<span id="cb5-4"><a href="#cb5-4"></a>  <span class="cf">for</span> <span class="op">(</span>Int k <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">}</span>; k<span class="op">.</span>v<span class="op">&lt;</span><span class="dv">10000</span>; <span class="op">++</span>k<span class="op">.</span>v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>    i<span class="op">.</span>v <span class="op">+=</span> k<span class="op">.</span>v;</span>
<span id="cb5-6"><a href="#cb5-6"></a>  <span class="op">}</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>  <span class="cf">return</span> i<span class="op">.</span>v<span class="op">/</span><span class="dv">10000</span>;</span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="op">}</span></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="kw">template</span><span class="op">&lt;</span><span class="dt">int</span> N<span class="op">&gt;</span> <span class="kw">struct</span> S <span class="op">{</span></span>
<span id="cb5-10"><a href="#cb5-10"></a>  <span class="kw">static</span> <span class="kw">constexpr</span> <span class="dt">int</span> sm <span class="op">=</span> S<span class="op">&lt;</span>N<span class="op">-</span><span class="dv">1</span><span class="op">&gt;::</span>sm<span class="op">+</span>f<span class="op">()</span>;</span>
<span id="cb5-11"><a href="#cb5-11"></a><span class="op">}</span>;</span>
<span id="cb5-12"><a href="#cb5-12"></a><span class="kw">template</span><span class="op">&lt;&gt;</span> <span class="kw">struct</span> S<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb5-13"><a href="#cb5-13"></a>  <span class="kw">static</span> <span class="kw">constexpr</span> <span class="dt">int</span> sm <span class="op">=</span> <span class="dv">0</span>;</span>
<span id="cb5-14"><a href="#cb5-14"></a><span class="op">}</span>;</span>
<span id="cb5-15"><a href="#cb5-15"></a><span class="kw">constexpr</span> <span class="dt">int</span> r <span class="op">=</span> S<span class="op">&lt;</span><span class="dv">200</span><span class="op">&gt;::</span>sm;</span></code></pre></div>
</blockquote>
<p>doubles the compile time to 1.2 seconds. Adding a derived-class layer would further increase the time. Another increase would result from attempting to access the classes through references (as would be tempting with a class hierarchy) because address computations require some work to guard against undefined behavior.</p>
<p>Because of these various considerations, we therefore propose that the type of a reflection is an unspecified scalar type, distinct from all other scalar types, whose definition is:</p>
<blockquote>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>  <span class="kw">using</span> info <span class="op">=</span> <span class="kw">decltype</span><span class="op">(^</span><span class="dt">void</span><span class="op">)</span>;</span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>Namespace <code class="sourceCode cpp">std<span class="op">::</span>meta</code> is an associated namespace of <code class="sourceCode cpp">std<span class="op">::</span>meta<span class="op">::</span>info</code> for the purposes of argument-dependent lookup (ADL): That makes the use of various other facilities in that namespace considerably more convenient. (In this sense, <code class="sourceCode cpp">std<span class="op">::</span>meta<span class="op">::</span>info</code> is similar to an enumeration type.)</p>
<p>By requiring the type to be scalar, we avoid implementation overheads associated with the compile-time evaluation of class objects, indirection, and inheritance. By making the type unspecified but distinct, we avoid accidental conversions to other scalar types, and we gain the ability to define core language rules that deal specifically with these values. Moreover, no special header is required before using the lifting operator.</p>
<h2 data-number="4.3" id="reflection-categories"><span class="header-section-number">4.3</span> Reflection categories<a href="#reflection-categories" class="self-link"></a></h2>
<p>As noted earlier, reflection values behave as handles to internal structures of the compiler. To reason about the kind of semantic information one can obtain through these reflection values, we categorize the values into one or more of four groups:</p>
<ul>
<li>Declared-entity reflections</li>
<li>Alias reflections</li>
<li>Expression reflections</li>
<li>Invalid reflections</li>
<li>Note, declared-entity-reflections <em>only</em> designate the declared-entity; alias-reflections always designate a declared-entity in addition to providing the name of the alias; and, expression-reflections might or might not designate a declared-entity (e.g., an <em>id-expression</em> might designate a variable), but always designate properties of the expression. <em>Invalid reflections</em> will be discussed in more detail later, but they represent various kinds of failures when creating reflections using means other than the <code class="sourceCode cpp"><span class="op">^</span></code> operator.</li>
</ul>
<p>For the most part, reflections of names (including type-ids) designate the declared entity those names denote: variables, functions, types, namespaces, templates, etc. For example:</p>
<blockquote>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="op">^</span><span class="kw">const</span> <span class="dt">int</span>            <span class="co">// Designates the type const int.</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="op">^</span>std                  <span class="co">// Designates the namespace std.</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="op">^</span>std<span class="op">::</span>pair            <span class="co">// Designates the template pair.</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="op">^</span>std<span class="op">::</span>pair<span class="op">&lt;</span><span class="dt">int</span>, <span class="dt">int</span><span class="op">&gt;</span>  <span class="co">// Designates the specialization.</span></span>
<span id="cb7-5"><a href="#cb7-5"></a></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="dt">int</span><span class="op">*</span> f<span class="op">(</span><span class="dt">int</span><span class="op">)</span>;</span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="op">^</span><span class="kw">decltype</span><span class="op">(</span>f<span class="op">(</span><span class="dv">3</span><span class="op">))</span>       <span class="co">// Designates the type int*.</span></span></code></pre></div>
</blockquote>
<p>Reflections of <em>expressions</em> designate a limited set of characteristics of those expressions, including at least their type and value category. For example:</p>
<blockquote>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="op">^</span><span class="dv">1</span> <span class="co">// Designates the property “prvalue of type int” (but also the constant value 1)</span></span></code></pre></div>
</blockquote>
<p>(Further on we will present facilities to examine and/or splice the designated notions.)</p>
<p>If an expression also names a declared entity (via a possibly-parenthesized <em>id-expression</em>), then it also designates that entity. For example:</p>
<blockquote>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="dt">int</span> x;</span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="op">^(</span>x<span class="op">)</span>        <span class="co">// Designates the declared-entity &#39;x&#39; (variable) as well as the properties of</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>            <span class="co">// the expression &#39;x&#39; (type and value category, in this case).</span></span>
<span id="cb9-4"><a href="#cb9-4"></a></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="op">^(</span>x<span class="op">+</span><span class="dv">1</span><span class="op">)</span>      <span class="co">// Does not designate a declared-entity but does designate the property</span></span>
<span id="cb9-6"><a href="#cb9-6"></a>            <span class="co">// “prvalue of type int” (if ’x+1’ had been constant-valued, it would also</span></span>
<span id="cb9-7"><a href="#cb9-7"></a>            <span class="co">// designate the value it represents).</span></span>
<span id="cb9-8"><a href="#cb9-8"></a></span>
<span id="cb9-9"><a href="#cb9-9"></a><span class="op">^</span>std<span class="op">::</span>cout  <span class="co">// Designates the object named by std::cout as well as the</span></span>
<span id="cb9-10"><a href="#cb9-10"></a>            <span class="co">// type and value category (lvalue) of the expression.</span></span></code></pre></div>
</blockquote>
<p>If an expression is a <em>constant expression</em> it also designates that constant value:</p>
<blockquote>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a><span class="op">^</span><span class="dv">0</span>                      <span class="co">// Designates the value zero and the property “prvalue of</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>                        <span class="co">// type int”. It does not capture that the expression is a</span></span>
<span id="cb10-3"><a href="#cb10-3"></a>                        <span class="co">// is a literal or that it is usable as a null pointer value.</span></span>
<span id="cb10-4"><a href="#cb10-4"></a></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="op">^</span><span class="kw">nullptr</span>                <span class="co">// Designates the null pointer value and the property “prvalue</span></span>
<span id="cb10-6"><a href="#cb10-6"></a>                        <span class="co">// of type decltype(nullptr)”.</span></span>
<span id="cb10-7"><a href="#cb10-7"></a></span>
<span id="cb10-8"><a href="#cb10-8"></a><span class="op">^</span>std<span class="op">::</span>errc<span class="op">::</span>bad_message <span class="co">// Designates the enumerator, its constant value, and the</span></span>
<span id="cb10-9"><a href="#cb10-9"></a>                        <span class="co">// property “prvalue of type std::errc”.</span></span></code></pre></div>
</blockquote>
<p>If an expression represents a call at its top level, it also designates the function being called (but not, e.g., the arguments to that call):</p>
<blockquote>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a><span class="op">^</span>printf<span class="op">(</span>“Hello, “<span class="op">)</span>        <span class="co">// Designates printf and the property “prvalue of type int”.</span></span>
<span id="cb11-2"><a href="#cb11-2"></a></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="op">^(</span>std<span class="op">::</span>cout <span class="op">&lt;&lt;</span> “World<span class="op">!</span>”<span class="op">)</span>  <span class="co">// Designates the applicable operator&lt;&lt;</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>                          <span class="co">// and “lvalue of type std::ostream”.</span></span>
<span id="cb11-5"><a href="#cb11-5"></a></span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="kw">constexpr</span> <span class="dt">int</span> f<span class="op">(</span><span class="dt">int</span> p<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> p<span class="op">+</span><span class="dv">1</span>; <span class="op">}</span>;</span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="op">^</span>f<span class="op">(</span><span class="dv">41</span><span class="op">)</span>                    <span class="co">// Designates f, the (returned) value 42, and</span></span>
<span id="cb11-8"><a href="#cb11-8"></a>                          <span class="co">// “prvalue of type int”.</span></span>
<span id="cb11-9"><a href="#cb11-9"></a></span>
<span id="cb11-10"><a href="#cb11-10"></a><span class="op">^(</span>f<span class="op">(</span><span class="dv">41</span><span class="op">)+</span><span class="dv">1</span><span class="op">)</span>                <span class="co">// Designates the (returned) value 43 and</span></span>
<span id="cb11-11"><a href="#cb11-11"></a>                          <span class="co">// “prvalue of type int”; does not designate f</span></span>
<span id="cb11-12"><a href="#cb11-12"></a>                          <span class="co">// because the call is not “top level”.</span></span></code></pre></div>
</blockquote>
<p>Now consider:</p>
<blockquote>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> <span class="kw">const</span> i <span class="op">=</span> <span class="dv">42</span>;</span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="kw">constexpr</span> <span class="kw">auto</span> r <span class="op">=</span> <span class="op">^</span>i;</span></code></pre></div>
</blockquote>
<p>As mentioned before, reflections can be categorized into four groups: declared-entity, alias, expression, or invalid. In this example, the reflection value <code class="sourceCode cpp">r</code> is an “expression reflection” and thus designates both the <em>expression</em> <code class="sourceCode cpp">i</code> (i.e. you can obtain information about properties of the expression such as its lvalueness) and the <em>variable</em> <code class="sourceCode cpp">i</code>. However, sometimes it is useful to obtain a reflection that designates only the entity (and not the expression). For example, we might want to query the type of the <em>variable</em> <code class="sourceCode cpp">i</code> (<code class="sourceCode cpp"><span class="dt">int</span> <span class="kw">const</span></code>) instead of the type of the <em>expression</em> <code class="sourceCode cpp">i</code> (<code class="sourceCode cpp"><span class="dt">int</span></code>). It also can be useful when comparing if two reflections refer to the same entity, as we will show later. We therefore provide the special function<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<blockquote>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> entity<span class="op">(</span>info reflection<span class="op">)-&gt;</span>info <span class="op">{...}</span>;</span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>which when applied to r produces a reflection designating just the <em>variable</em> (i.e., a “declared-entity reflection”).</p>
<p>More generally, <code class="sourceCode cpp">std<span class="op">::</span>meta<span class="op">::</span>entity</code> extracts the declared-entity from its argument by returning:</p>
<ul>
<li>its argument — if its argument is a declared-entity reflection or an invalid reflection,</li>
<li>a declared-entity reflection designating an entity <code class="sourceCode cpp">E</code> — if the argument is an alias or expression reflection that also designates <code class="sourceCode cpp">E</code>, or</li>
<li>an invalid reflection in all other cases (e.g., <code class="sourceCode cpp">entity<span class="op">(^</span><span class="dv">42</span><span class="op">)</span></code> is an invalid reflection).</li>
</ul>
<p>When the <code class="sourceCode cpp"><span class="op">^</span></code> operand is the name of an <em>alias</em> (type or namespace) the reflection designates the aliased entity indirectly (i.e., properties of the alias can be queried directly). For example:</p>
<blockquote>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">using</span> T0 <span class="op">=</span> <span class="dt">int</span>;</span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="kw">using</span> T1 <span class="op">=</span> <span class="kw">const</span> T0;</span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="kw">constexpr</span> meta<span class="op">::</span>info ref <span class="op">=</span> <span class="op">^</span>T1;</span></code></pre></div>
</blockquote>
<p>Here, ref designates both <code class="sourceCode cpp">T1</code> (directly) and the type <code class="sourceCode cpp"><span class="kw">const</span> <span class="dt">int</span></code> (indirectly). This allows users to work both with the alias and its meaning. However, underlying aliases are not designated: There is no way to find about <code class="sourceCode cpp">T0</code> through <code class="sourceCode cpp">ref</code>.</p>
<p>In a more abstract sense, reflections designate semantic notions (names, types, value categories, etc.) rather than syntax (tokens that comprise an expression and the relation of those tokens to others). This principle helps guide decisions about the design of language and library support for reflection.</p>
<p>The queryable properties of these reflections are determined by the kind of “thing” they reflect. Details are provided below.</p>
<h2 data-number="4.4" id="equality-and-equivalence"><span class="header-section-number">4.4</span> Equality and equivalence<a href="#equality-and-equivalence" class="self-link"></a></h2>
<p>Reflections can be compared using <code class="sourceCode cpp"><span class="op">==</span></code> and <code class="sourceCode cpp"><span class="op">!=</span></code> operators. Intuitively, the rule for these comparisons is that we compare the underlying declared entity, except that we cannot compare the reflections of most expressions nor can we compare invalid reflections. The exact rules are as follows…</p>
<ol type="1">
<li>If two reflections designate declared entities or aliases of such entities and do not designate expression properties of an expression that is not an <em>id-expression</em>, the reflections compare equal if the entities are identical and unequal if the entities are not identical (i.e., the comparison “looks through” aliases).</li>
<li>Any reflection also (obviously) compares equal to itself and to copies of itself.</li>
<li>An invalid reflection compares unequal to a reflection that is not invalid.</li>
<li>A reflection that designates a declared entity or an alias of such an entity and does not designate expression properties of an expression that is not an <em>id-expression</em> (e.g., it is not the reflection of a function call) compares unequal to a reflection that either does not designate an entity or an alias of such entity, or that designates properties of an expression that is not an <em>id-expression</em>.</li>
<li>All other cases are unspecified: That includes comparing reflections of expressions other than <em>id-expressions</em> and invalid reflections. For example:</li>
</ol>
<blockquote>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">typedef</span> <span class="dt">int</span> I1;</span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="kw">typedef</span> <span class="dt">int</span> I2;</span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="kw">static_assert</span><span class="op">(^</span>I1 <span class="op">==</span> <span class="op">^</span>I2<span class="op">)</span>;        <span class="co">// Rule 1: Same underlying declared entity (int).</span></span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="kw">static_assert</span><span class="op">(^</span>I1 <span class="op">==</span> <span class="op">^</span><span class="dt">int</span><span class="op">)</span>;       <span class="co">// Ditto.</span></span>
<span id="cb15-5"><a href="#cb15-5"></a></span>
<span id="cb15-6"><a href="#cb15-6"></a><span class="dt">float</span> f <span class="op">=</span> <span class="fl">3.0</span>, e;</span>
<span id="cb15-7"><a href="#cb15-7"></a><span class="kw">static_assert</span><span class="op">(^</span>f <span class="op">==</span> <span class="op">^(</span>f<span class="op">))</span>;        <span class="co">// Rule 1: Same underlying declared entity (f).</span></span>
<span id="cb15-8"><a href="#cb15-8"></a><span class="kw">static_assert</span><span class="op">(^</span>f <span class="op">==</span> <span class="op">^::</span>f<span class="op">)</span>;        <span class="co">// Ditto.</span></span>
<span id="cb15-9"><a href="#cb15-9"></a><span class="kw">static_assert</span><span class="op">(^</span>f <span class="op">!=</span> <span class="op">^</span>e<span class="op">)</span>;          <span class="co">// Rule 1: Different underlying declared entities.</span></span>
<span id="cb15-10"><a href="#cb15-10"></a><span class="kw">static_assert</span><span class="op">(^</span>I1 <span class="op">!=</span> <span class="op">^</span><span class="dt">float</span><span class="op">)</span>;     <span class="co">// Ditto.</span></span>
<span id="cb15-11"><a href="#cb15-11"></a></span>
<span id="cb15-12"><a href="#cb15-12"></a><span class="dt">void</span> g<span class="op">(</span><span class="dt">int</span><span class="op">)</span>;</span>
<span id="cb15-13"><a href="#cb15-13"></a><span class="kw">constexpr</span> <span class="kw">auto</span> r <span class="op">=</span> <span class="op">^</span>g<span class="op">(</span><span class="dv">1</span><span class="op">)</span>, s <span class="op">=</span> r;</span>
<span id="cb15-14"><a href="#cb15-14"></a><span class="kw">static_assert</span><span class="op">(</span>r <span class="op">==</span> s<span class="op">)</span>;            <span class="co">// Rule 2: One is a copy of the other.</span></span>
<span id="cb15-15"><a href="#cb15-15"></a><span class="kw">static_assert</span><span class="op">(^</span>f <span class="op">!=</span> <span class="op">^</span>g<span class="op">(</span><span class="dv">1</span><span class="op">))</span>;       <span class="co">// Rule 4: f is an id-expression and g(1) is not.</span></span>
<span id="cb15-16"><a href="#cb15-16"></a><span class="kw">static_assert</span><span class="op">(^</span>g <span class="op">!=</span> <span class="op">^</span>g<span class="op">(</span><span class="dv">1</span><span class="op">))</span>;       <span class="co">// Rule 4: One is the reflection of an id-expression</span></span>
<span id="cb15-17"><a href="#cb15-17"></a>                                  <span class="co">// and the other is the reflection of an expression</span></span>
<span id="cb15-18"><a href="#cb15-18"></a>                                  <span class="co">// that is not an id-expression.</span></span>
<span id="cb15-19"><a href="#cb15-19"></a><span class="kw">static_assert</span><span class="op">(^</span>g<span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="op">==</span> <span class="op">^</span>g<span class="op">(</span><span class="dv">1</span><span class="op">))</span>;    <span class="co">// Rule 5: May fail because g(1) is an expression</span></span>
<span id="cb15-20"><a href="#cb15-20"></a>                                  <span class="co">// that is not an id-expression</span></span></code></pre></div>
</blockquote>
<p>Programmers can more precisely specify whether they intend to compare entities or computed values (if possible) using splicers (e.g., <code class="sourceCode cpp"><span class="kw">typename</span><span class="op">[:</span>r<span class="op">:]</span></code> vs. just <code class="sourceCode cpp"><span class="op">[:</span>r<span class="op">:]</span></code>) or library facilities like <code class="sourceCode cpp">std<span class="op">::</span>meta<span class="op">::</span>entity</code> described above. For example:</p>
<blockquote>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1"></a><span class="dt">void</span> f<span class="op">()</span>;   <span class="co">// #1</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="dt">int</span> f<span class="op">(</span><span class="dt">int</span><span class="op">)</span>; <span class="co">// #2</span></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="kw">constexpr</span> <span class="kw">auto</span> r <span class="op">=</span> std<span class="op">::</span>meta<span class="op">::</span>entity<span class="op">(^</span>f<span class="op">(</span><span class="dv">42</span><span class="op">))</span>; <span class="co">// Designates function #2.</span></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="kw">static_assert</span><span class="op">(</span>r <span class="op">!=</span> <span class="op">^</span>f<span class="op">(</span><span class="dv">42</span><span class="op">))</span>;                   <span class="co">// Fails.</span></span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="kw">static_assert</span><span class="op">(</span>r <span class="op">==</span> entity<span class="op">(^</span>f<span class="op">(</span><span class="dv">0</span><span class="op">)))</span>;            <span class="co">// Always succeeds..</span></span></code></pre></div>
</blockquote>
<p>Note that rule 1 above also applies to namespace aliases:</p>
<blockquote>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">namespace</span> N <span class="op">{}</span>;</span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="kw">namespace</span> N1 <span class="op">=</span> N;</span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="kw">namespace</span> N2 <span class="op">=</span> N;</span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="kw">static_assert</span><span class="op">(^</span>N1 <span class="op">==</span> <span class="op">^</span>N2<span class="op">)</span>;</span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="kw">static_assert</span><span class="op">(^</span>N1 <span class="op">==</span> <span class="op">^</span>N<span class="op">)</span>;</span>
<span id="cb17-6"><a href="#cb17-6"></a><span class="kw">namespace</span> M <span class="op">{}</span>;</span>
<span id="cb17-7"><a href="#cb17-7"></a><span class="kw">static_assert</span><span class="op">(^</span>N <span class="op">!=</span> <span class="op">^</span>M<span class="op">)</span>;</span></code></pre></div>
</blockquote>
<p>For reflections obtained from operands that involve template parameters, the result depends on the template arguments used for substitution:</p>
<blockquote>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T, <span class="kw">typename</span> U<span class="op">&gt;</span> <span class="kw">struct</span> Fun <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2"></a>  <span class="kw">static_assert</span><span class="op">(^</span>T <span class="op">==</span> <span class="op">^</span>U<span class="op">)</span>;</span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="op">}</span>;</span>
<span id="cb18-4"><a href="#cb18-4"></a>Fun<span class="op">&lt;</span><span class="dt">int</span>, <span class="dt">int</span><span class="op">&gt;</span> whee;   <span class="co">// Okay.</span></span>
<span id="cb18-5"><a href="#cb18-5"></a>Fun<span class="op">&lt;</span><span class="dt">int</span>, <span class="dt">char</span><span class="op">&gt;</span> oops; <span class="co">// Error: static assertion fails.</span></span></code></pre></div>
</blockquote>
<p>We already mentioned that it is unspecified whether reflections obtained from expressions that do not designate a declared entity compare equal. That also applies to expressions that just consist of a literal. For example:</p>
<blockquote>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1"></a><span class="kw">static_assert</span><span class="op">(^</span><span class="dv">1</span> <span class="op">==</span> <span class="op">^</span><span class="dv">1</span><span class="op">)</span>; <span class="co">// May or may not fail.</span></span></code></pre></div>
</blockquote>
<p>(These rules allow us to avoid having to provide a general definition of “expression equivalence”.) Note that the properties associated with a declared entity may change over various contexts, but that does not change the reflection. For example:</p>
<blockquote>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1"></a><span class="kw">struct</span> S;</span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="kw">constexpr</span> <span class="kw">auto</span> r1 <span class="op">=</span> <span class="op">^</span>S;</span>
<span id="cb20-3"><a href="#cb20-3"></a><span class="kw">struct</span> S <span class="op">{}</span>;</span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="kw">constexpr</span> <span class="kw">auto</span> r2 <span class="op">=</span> <span class="op">^</span>S;</span>
<span id="cb20-5"><a href="#cb20-5"></a><span class="kw">static_assert</span><span class="op">(</span>r1 <span class="op">==</span> r2<span class="op">)</span>;</span></code></pre></div>
</blockquote>
<p>However, queries against the reflection value (e.g., to obtain a list of class members) may change as a consequence of the changes in the underlying entity.</p>
<p>An additional comparison function is proposed:</p>
<blockquote>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb21-2"><a href="#cb21-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> same_reflections<span class="op">(</span>info, info<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span>;</span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>If either <code class="sourceCode cpp">x</code> or <code class="sourceCode cpp">y</code> designate an alias (type or namespace) <code class="sourceCode cpp">same_reflections<span class="op">(</span>x, y<span class="op">)</span></code> returns <code class="sourceCode cpp"><span class="kw">true</span></code> if <code class="sourceCode cpp">x</code> and <code class="sourceCode cpp">y</code> designate the same alias and <code class="sourceCode cpp"><span class="kw">false</span></code> otherwise. Otherwise (i.e., if neither <code class="sourceCode cpp">x</code> nor <code class="sourceCode cpp">y</code> designate an alias), <code class="sourceCode cpp">same_reflections<span class="op">(</span>x, y<span class="op">)</span></code> returns <code class="sourceCode cpp">x <span class="op">==</span> y</code>. In other words, <code class="sourceCode cpp">same_reflections<span class="op">(</span>x, y<span class="op">)</span></code> is like the equality operator except that it doesn’t “look through” aliases. For example, with the namespace aliases <code class="sourceCode cpp">N1</code> and <code class="sourceCode cpp">N2</code> as above:</p>
<blockquote>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1"></a><span class="kw">using</span> std<span class="op">::</span>meta<span class="op">::</span>same_reflections;</span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="kw">static_assert</span><span class="op">(!</span>same_reflections<span class="op">(^</span>N1, <span class="op">^</span>N2<span class="op">))</span>;</span>
<span id="cb22-3"><a href="#cb22-3"></a><span class="kw">static_assert</span><span class="op">(</span>same_reflections<span class="op">(^(^</span>N1<span class="op">)</span>, <span class="op">^(^</span>N1<span class="op">)))</span>;  <span class="co">// May fail.</span></span>
<span id="cb22-4"><a href="#cb22-4"></a><span class="kw">static_assert</span><span class="op">(!</span>same_reflections<span class="op">(^(^</span>N1<span class="op">)</span>, <span class="op">^(^</span>N2<span class="op">)))</span>; <span class="co">// May fail.</span></span></code></pre></div>
</blockquote>
<p>The latter two assertions have unspecified behavior because <code class="sourceCode cpp"><span class="op">^</span>N1</code> (or <code class="sourceCode cpp"><span class="op">^</span>N2</code>) is an expression that is not an <em>id-expression</em> and (as was noted above) the equality of the reflections of such expressions is unspecified.</p>
<p>To compare the values of reflected objects, references, functions, or types, the reflection can first be spliced (see below).</p>
<h2 data-number="4.5" id="a-note-about-linkage"><span class="header-section-number">4.5</span> A Note About Linkage<a href="#a-note-about-linkage" class="self-link"></a></h2>
<p>Although in most respects we propose that <code class="sourceCode cpp">std<span class="op">::</span>meta<span class="op">::</span>info</code> is an ordinary scalar type, we also give it one “magical” property with respect to linkage.</p>
<p>Before explaining this property, consider again what a reflection value represents in practice: It is a handle to internal structures the compiler builds up for the current translation unit. So for code like:</p>
<blockquote>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1"></a><span class="kw">struct</span> S <span class="op">{}</span>;</span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="kw">consteval</span> <span class="kw">auto</span> f<span class="op">()</span> <span class="op">{</span></span>
<span id="cb23-3"><a href="#cb23-3"></a>  <span class="cf">return</span> <span class="op">^</span>S;</span>
<span id="cb23-4"><a href="#cb23-4"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>the compiler will construct an internal representation for struct <code class="sourceCode cpp">S</code> and when it encounters <code class="sourceCode cpp"><span class="op">^</span>S</code> it will update a two-way map between the internal representation of <code class="sourceCode cpp">S</code> and a small structure underlying the std::meta::info value returned by <code class="sourceCode cpp"><span class="op">^</span>S</code>.</p>
<p>Now consider:</p>
<blockquote>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1"></a><span class="co">// Header t.hpp:</span></span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="kw">struct</span> S <span class="op">{}</span>;</span>
<span id="cb24-3"><a href="#cb24-3"></a><span class="kw">template</span><span class="op">&lt;</span>std<span class="op">::</span>meta<span class="op">::</span>info reflection<span class="op">&gt;</span> <span class="kw">struct</span> X <span class="op">{}</span>;</span>
<span id="cb24-4"><a href="#cb24-4"></a></span>
<span id="cb24-5"><a href="#cb24-5"></a><span class="co">// File t1.cpp:</span></span>
<span id="cb24-6"><a href="#cb24-6"></a><span class="pp">#include </span><span class="im">&quot;t.hpp&quot;</span></span>
<span id="cb24-7"><a href="#cb24-7"></a><span class="kw">enum</span> E <span class="op">{}</span>;</span>
<span id="cb24-8"><a href="#cb24-8"></a><span class="kw">consteval</span> <span class="kw">auto</span> d<span class="op">()</span> <span class="op">{</span></span>
<span id="cb24-9"><a href="#cb24-9"></a>  <span class="cf">return</span> <span class="op">^</span>E;</span>
<span id="cb24-10"><a href="#cb24-10"></a><span class="op">}</span></span>
<span id="cb24-11"><a href="#cb24-11"></a>X<span class="op">&lt;^</span>S<span class="op">&gt;</span> g<span class="op">()</span> <span class="op">{</span></span>
<span id="cb24-12"><a href="#cb24-12"></a>  <span class="cf">return</span> X<span class="op">&lt;^</span>S<span class="op">&gt;{}</span>;</span>
<span id="cb24-13"><a href="#cb24-13"></a><span class="op">}</span></span>
<span id="cb24-14"><a href="#cb24-14"></a></span>
<span id="cb24-15"><a href="#cb24-15"></a><span class="co">// File t2.cpp:</span></span>
<span id="cb24-16"><a href="#cb24-16"></a><span class="pp">#include </span><span class="im">&quot;t.hpp&quot;</span></span>
<span id="cb24-17"><a href="#cb24-17"></a><span class="kw">extern</span> X<span class="op">&lt;^</span>S<span class="op">&gt;</span> g<span class="op">()</span>;</span>
<span id="cb24-18"><a href="#cb24-18"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb24-19"><a href="#cb24-19"></a>  g<span class="op">()</span>;</span>
<span id="cb24-20"><a href="#cb24-20"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>The files t1.cpp and t2.cpp are compiled separately. The contexts in which the <code class="sourceCode cpp"><span class="op">^</span>S</code> construct is encountered are therefore different and it is not practical to ensure that the <em>underlying</em> values (“bits”) of the <code class="sourceCode cpp">std<span class="op">::</span>meta<span class="op">::</span>info</code> results are identical. However, it is <em>very</em> desirable that the types <code class="sourceCode cpp">X<span class="op">&lt;^</span>S<span class="op">&gt;</span></code> are the same types in both translation units and that the above example not produce an ODR violation.</p>
<p>We therefore specify “by fiat” that: * <code class="sourceCode cpp"><span class="kw">reinterpret_cast</span></code> to or from <code class="sourceCode cpp">std<span class="op">::</span>meta<span class="op">::</span>info</code> is ill-formed * accessing the byte representation of <code class="sourceCode cpp">std<span class="op">::</span>meta<span class="op">:</span>info</code> lvalues produces unspecified (possibly inconsistent) values * <code class="sourceCode cpp">std<span class="op">::</span>meta<span class="op">::</span>info</code> values <code class="sourceCode cpp">A1</code> and <code class="sourceCode cpp">A2</code> produce equivalent template arguments if <code class="sourceCode cpp">std<span class="op">::</span>meta<span class="op">::</span>same_reflections<span class="op">(</span>A1, A2<span class="op">)</span></code> produces <code class="sourceCode cpp"><span class="kw">true</span></code>.</p>
<p>However, it is unspecified if the following variation of the previous example is valid:</p>
<blockquote>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1"></a><span class="co">// File t1.cpp:</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="kw">enum</span> E <span class="op">{}</span>;</span>
<span id="cb25-3"><a href="#cb25-3"></a><span class="kw">consteval</span> <span class="kw">auto</span> d<span class="op">()</span> <span class="op">{</span></span>
<span id="cb25-4"><a href="#cb25-4"></a>  <span class="cf">return</span> <span class="op">^(^</span>E<span class="op">)</span>;</span>
<span id="cb25-5"><a href="#cb25-5"></a><span class="op">}</span></span>
<span id="cb25-6"><a href="#cb25-6"></a>X<span class="op">&lt;^(^</span>S<span class="op">)&gt;</span> g<span class="op">()</span> <span class="op">{</span></span>
<span id="cb25-7"><a href="#cb25-7"></a>  <span class="cf">return</span> X<span class="op">&lt;^(^</span>S<span class="op">)&gt;{}</span>;</span>
<span id="cb25-8"><a href="#cb25-8"></a><span class="op">}</span></span>
<span id="cb25-9"><a href="#cb25-9"></a></span>
<span id="cb25-10"><a href="#cb25-10"></a><span class="co">// File t2.cpp:</span></span>
<span id="cb25-11"><a href="#cb25-11"></a><span class="kw">extern</span> X<span class="op">&lt;^(^</span>S<span class="op">)&gt;</span> g<span class="op">()</span>;</span>
<span id="cb25-12"><a href="#cb25-12"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb25-13"><a href="#cb25-13"></a>  g<span class="op">()</span>;</span>
<span id="cb25-14"><a href="#cb25-14"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>because it is unspecified if two occurrences of <code class="sourceCode cpp"><span class="op">^(^</span>S<span class="op">)</span></code> are equivalent.</p>
<p>(In practice, this means that reflection values are mangled symbolically, according to what the reflection value actually designates.)</p>
<h2 data-number="4.6" id="invalid-reflections"><span class="header-section-number">4.6</span> Invalid reflections<a href="#invalid-reflections" class="self-link"></a></h2>
<p>In what follows we are going to propose a large collection of standard reflection operations, some of which generate new reflection values. Sometimes, the application of some of these operations will be meaningless. E.g., consider:</p>
<blockquote>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb26-2"><a href="#cb26-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> add_const<span class="op">(</span>info<span class="op">)-&gt;</span>info <span class="op">{...}</span>;</span>
<span id="cb26-3"><a href="#cb26-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>which is meant to take a reflection of a type and add a type qualifier on top. However, what happens with something like:</p>
<blockquote>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> r <span class="op">=</span> add_const<span class="op">(^</span>std<span class="op">)</span>;</span></code></pre></div>
</blockquote>
<p>which suggests the meaningless operation of adding a <code class="sourceCode cpp"><span class="kw">const</span></code> qualifier to namespace <code class="sourceCode cpp">std</code>? Our answer is that an implementation will not immediately trigger an error in that case, but instead create a reflection value that represents an error. Any attempt to splice such a reflection is ill-formed (but subject to SFINAE).</p>
<p>It is useful for user code to also be able to produce invalid reflections. To that end, we propose the following function:</p>
<blockquote>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb28-2"><a href="#cb28-2"></a>  <span class="kw">consteval</span></span>
<span id="cb28-3"><a href="#cb28-3"></a>    <span class="kw">auto</span> invalid_reflection<span class="op">(</span>std<span class="op">::</span>string_view message,</span>
<span id="cb28-4"><a href="#cb28-4"></a>                            std<span class="op">::</span>source_location src_loc <span class="op">=</span> std<span class="op">::</span>source_location<span class="op">::</span>current<span class="op">())</span></span>
<span id="cb28-5"><a href="#cb28-5"></a>      <span class="op">-&gt;</span>info <span class="op">{...}</span>;</span>
<span id="cb28-6"><a href="#cb28-6"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>which constructs a reflection that triggers a diagnostic if it is spliced outside a SFINAE context (ideally, with the given message and source location information). Here, the functions</p>
<p>Invalid reflections can also be used to generate compiler diagnostics during constant evaluation using the <code class="sourceCode cpp">diagnose_error</code> function. This can be a valuable debugging aid for authors of metaprogramming libraries, and when used effectively, should improve the usability of those libraries.</p>
<blockquote>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb29-2"><a href="#cb29-2"></a>  <span class="kw">consteval</span> <span class="dt">void</span> diagnose_error<span class="op">(</span>info invalid_refl<span class="op">)</span> <span class="op">{...}</span>;</span>
<span id="cb29-3"><a href="#cb29-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>This function causes the compiler to emit an error diagnostic (formally: it makes the program ill-formed if it is invoked outside a deduction/SFINAE context), hopefully with the message and location provided by the argument. For example:</p>
<blockquote>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1"></a><span class="kw">auto</span> r <span class="op">=</span> std<span class="op">::</span>meta<span class="op">::</span>invalid_reflection<span class="op">(</span>“Oops<span class="op">!</span>”<span class="op">)</span>;</span>
<span id="cb30-2"><a href="#cb30-2"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb30-3"><a href="#cb30-3"></a>  diagnose_error<span class="op">(</span>r<span class="op">)</span>; <span class="co">// Error.</span></span>
<span id="cb30-4"><a href="#cb30-4"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>That last example is ill-formed and might trigger an error like:</p>
<blockquote>
<div class="sourceCode" id="cb31"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb31-1"><a href="#cb31-1"></a>“Test.cpp”, line 3: error: Invalid reflection</span>
<span id="cb31-2"><a href="#cb31-2"></a>  diagnose_error(r); // Error.</span>
<span id="cb31-3"><a href="#cb31-3"></a>  ^</span>
<span id="cb31-4"><a href="#cb31-4"></a></span>
<span id="cb31-5"><a href="#cb31-5"></a>“Test.cpp”, line 1: note: Oops!</span>
<span id="cb31-6"><a href="#cb31-6"></a>  auto r = std::meta::invalid_reflection(“Oops!”);</span>
<span id="cb31-7"><a href="#cb31-7"></a>           ^</span></code></pre></div>
</blockquote>
<p>Finally, we propose a predicate:</p>
<blockquote>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb32-2"><a href="#cb32-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_invalid<span class="op">(</span>info<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb32-3"><a href="#cb32-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>that can be used to, e.g., filter out invalid reflective operations. We also provide a convenience overload of this function:</p>
<blockquote>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb33-2"><a href="#cb33-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_invalid<span class="op">(</span>std<span class="op">::</span>span<span class="op">&lt;</span>info<span class="op">&gt;)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb33-3"><a href="#cb33-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>which returns <code class="sourceCode cpp"><span class="kw">true</span></code> if any element of the given span is an invalid reflection. This is particularly useful because some important reflection facilities return spans of reflection values that callers are likely to want to check for invalid entries.</p>
<h2 data-number="4.7" id="initialization-of-reflections"><span class="header-section-number">4.7</span> Initialization of reflections<a href="#initialization-of-reflections" class="self-link"></a></h2>
<p>Objects of reflection type are zero-initialized to an invalid reflection value (with unspecified associated information).</p>
<h2 data-number="4.8" id="conversions-on-reflections"><span class="header-section-number">4.8</span> Conversions on reflections<a href="#conversions-on-reflections" class="self-link"></a></h2>
<p>A prvalue of reflection type can be contextually converted to a prvalue of type bool. An invalid reflection converts to false; all other reflections convert to true.</p>
<h2 data-number="4.9" id="hashing-reflections"><span class="header-section-number">4.9</span> Hashing reflections<a href="#hashing-reflections" class="self-link"></a></h2>
<p>We propose that the <code class="sourceCode cpp">std<span class="op">::</span>hash</code> template be specialized for <code class="sourceCode cpp">std<span class="op">::</span>meta<span class="op">::</span>info</code>. We also propose that the resulting hash value be consistent across translation units.</p>
<h1 data-number="5" style="border-bottom:1px solid #cccccc" id="splicing"><span class="header-section-number">5</span> Splicing<a href="#splicing" class="self-link"></a></h1>
<p>In the context of this paper, “splicing” refers to the process of turning a “reflection value” back into a “program source thing”. We propose a basic <em>splice</em> construct to be of the form</p>
<blockquote>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1"></a><span class="op">[:</span> reflection <span class="op">:]</span></span></code></pre></div>
</blockquote>
<p>where <code class="sourceCode cpp"><span class="op">[:</span></code> and <code class="sourceCode cpp"><span class="op">:]</span></code> are each a sequence of two tokens and reflection is a constant-expression of type <code class="sourceCode cpp">std<span class="op">::</span>meta<span class="op">::</span>info</code>. (Prior versions of this paper discuss various alternative syntax options. The choice presented here was first proposed in <span class="citation" data-cites="P2320R0">[<a href="#ref-P2320R0" role="doc-biblioref">P2320R0</a>]</span>, which obtained strong support in SG-7.)</p>
<p>In general, and without qualification, <code class="sourceCode cpp"><span class="op">[:</span> R <span class="op">:]</span></code> splices an expression into the program (assuming <code class="sourceCode cpp">R</code> reflects a variable, function, or a constant expression). If <code class="sourceCode cpp">R</code> reflects both a constant value and a declared entity (e.g., <code class="sourceCode cpp"><span class="op">^</span>f<span class="op">()</span></code> where <code class="sourceCode cpp">f</code> is a <code class="sourceCode cpp"><span class="kw">consteval</span></code> function), <code class="sourceCode cpp"><span class="op">[:</span> R <span class="op">:]</span></code> splices the constant value. Use <code class="sourceCode cpp">std<span class="op">::</span>meta<span class="op">::</span>entity</code> to get the other outcome. If <code class="sourceCode cpp">R</code> reflects a type or template, the splice construct must be qualified with an appropriate <code class="sourceCode cpp"><span class="kw">typename</span></code> or <code class="sourceCode cpp"><span class="kw">template</span></code> keyword, except in some contexts where the meaning is obvious. For example:</p>
<blockquote>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1"></a><span class="kw">struct</span> S <span class="op">{</span> <span class="kw">struct</span> I <span class="op">{</span> <span class="op">}</span>; <span class="op">}</span>;</span>
<span id="cb35-2"><a href="#cb35-2"></a><span class="kw">template</span><span class="op">&lt;</span><span class="dt">int</span> N<span class="op">&gt;</span> <span class="kw">struct</span> X;</span>
<span id="cb35-3"><a href="#cb35-3"></a><span class="kw">auto</span> refl <span class="op">=</span> ˆS;</span>
<span id="cb35-4"><a href="#cb35-4"></a><span class="kw">auto</span> tmpl <span class="op">=</span> ˆX;</span>
<span id="cb35-5"><a href="#cb35-5"></a><span class="dt">void</span> f<span class="op">()</span> <span class="op">{</span></span>
<span id="cb35-6"><a href="#cb35-6"></a>  <span class="kw">typename</span><span class="op">[:</span>refl<span class="op">:]</span> <span class="op">*</span> x;  <span class="co">// Okay: declares x to be a pointer to S.</span></span>
<span id="cb35-7"><a href="#cb35-7"></a>  <span class="op">[:</span>refl<span class="op">:]</span> <span class="op">*</span> x;          <span class="co">// Error: attempt to multiply int by x.</span></span>
<span id="cb35-8"><a href="#cb35-8"></a>  <span class="op">[:</span>refl<span class="op">:]::</span>I i;         <span class="co">// Okay: splice as part of a nested-name-specifier.</span></span>
<span id="cb35-9"><a href="#cb35-9"></a>  <span class="kw">typename</span><span class="op">[:</span>refl<span class="op">:]{}</span>;    <span class="co">// Okay: default-constructs an S temporary.</span></span>
<span id="cb35-10"><a href="#cb35-10"></a>  <span class="kw">using</span> T <span class="op">=</span> <span class="op">[:</span>refl<span class="op">:]</span>;    <span class="co">// Okay: operand must be a type.</span></span>
<span id="cb35-11"><a href="#cb35-11"></a>  <span class="kw">struct</span> C<span class="op">:</span> <span class="op">[:</span>refl<span class="op">:]</span> <span class="op">{}</span>; <span class="co">// Okay: base classes are types.</span></span>
<span id="cb35-12"><a href="#cb35-12"></a>  <span class="kw">template</span><span class="op">[:</span>tmpl<span class="op">:]&lt;</span><span class="dv">0</span><span class="op">&gt;</span>;   <span class="co">// Okay: names the specialization.</span></span>
<span id="cb35-13"><a href="#cb35-13"></a>  <span class="op">[:</span>tmpl<span class="op">:]</span> <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">&gt;</span> x;      <span class="co">// Error: attempt to compare X with 0.</span></span>
<span id="cb35-14"><a href="#cb35-14"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>When a splice construct is used as a template argument, without a disambiguating <code class="sourceCode cpp"><span class="kw">typename</span></code> or <code class="sourceCode cpp"><span class="kw">template</span></code> keyword, is not <em>a priori</em> assumed to be an expression. For example:</p>
<blockquote>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="dt">void</span> f<span class="op">()</span>;</span>
<span id="cb36-2"><a href="#cb36-2"></a><span class="kw">template</span><span class="op">&lt;</span><span class="dt">int</span> N<span class="op">&gt;</span> <span class="dt">void</span> f<span class="op">()</span>;</span>
<span id="cb36-3"><a href="#cb36-3"></a><span class="kw">template</span><span class="op">&lt;</span>meta<span class="op">::</span>info Refl<span class="op">&gt;</span> <span class="dt">void</span> ex1<span class="op">()</span> <span class="op">{</span></span>
<span id="cb36-4"><a href="#cb36-4"></a>  f<span class="op">&lt;[:</span>Refl<span class="op">:]&gt;()</span>; <span class="co">// Could resolve to either function template above.</span></span>
<span id="cb36-5"><a href="#cb36-5"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>To “force” Refl to be spliced as a type or an expression by adding typename or enclosing the splice in parentheses:</p>
<blockquote>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1"></a><span class="kw">template</span><span class="op">&lt;</span>meta<span class="op">::</span>info Refl<span class="op">&gt;</span> <span class="dt">void</span> ex2<span class="op">()</span> <span class="op">{</span></span>
<span id="cb37-2"><a href="#cb37-2"></a>  f<span class="op">&lt;</span><span class="kw">typename</span> <span class="op">[:</span>Refl<span class="op">:]&gt;()</span>; <span class="co">// splices a type</span></span>
<span id="cb37-3"><a href="#cb37-3"></a>  f<span class="op">&lt;([:</span>Refl<span class="op">:])&gt;()</span>; <span class="co">// splices an expression</span></span>
<span id="cb37-4"><a href="#cb37-4"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>Here are some additional examples illustrating various uses of the splicing constructs:</p>
<blockquote>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1"></a><span class="kw">typename</span><span class="op">[:^</span><span class="dt">int</span><span class="op">:]</span> i <span class="op">=</span> <span class="op">[:^</span><span class="dv">42</span><span class="op">:]</span>;     <span class="co">// Same as “int i = 42;”.</span></span>
<span id="cb38-2"><a href="#cb38-2"></a><span class="kw">constexpr</span> <span class="dt">int</span> J <span class="op">=</span> <span class="dv">42</span>;</span>
<span id="cb38-3"><a href="#cb38-3"></a><span class="op">[:^</span>i<span class="op">:]</span> <span class="op">=</span> <span class="op">[:^</span>J<span class="op">:]</span>;                  <span class="co">// Same as “i = J;”.</span></span>
<span id="cb38-4"><a href="#cb38-4"></a><span class="op">[:^</span>i<span class="op">:]</span> <span class="op">=</span> <span class="op">[:^(</span>J<span class="op">+</span><span class="dv">1</span><span class="op">):]</span>;              <span class="co">// Same as “i = 43;”.</span></span>
<span id="cb38-5"><a href="#cb38-5"></a><span class="op">[:^</span>i<span class="op">:]</span> <span class="op">=</span> <span class="op">[:^[]{</span> <span class="cf">return</span> J; <span class="op">}():]</span>;  <span class="co">// Same as “i = 42;”.</span></span>
<span id="cb38-6"><a href="#cb38-6"></a><span class="op">[:^</span>i<span class="op">:]</span> <span class="op">=</span> <span class="op">[:^[=]{</span> <span class="dt">int</span> x <span class="op">=</span> i; <span class="cf">return</span> J; <span class="op">}():]</span>;</span>
<span id="cb38-7"><a href="#cb38-7"></a>                                  <span class="co">// Error: The lambda call is not a constant expression.</span></span>
<span id="cb38-8"><a href="#cb38-8"></a>                                  <span class="co">// (Reflections of arbitrary expressions cannot be spliced.)</span></span>
<span id="cb38-9"><a href="#cb38-9"></a><span class="kw">namespace</span> N <span class="op">{</span> <span class="dt">int</span> f; <span class="op">}</span></span>
<span id="cb38-10"><a href="#cb38-10"></a><span class="dt">void</span> <span class="op">[:</span> <span class="op">^</span>N<span class="op">::</span>f <span class="op">:](</span><span class="dt">int</span><span class="op">)</span>;            <span class="co">// Error: Not an expression context.</span></span>
<span id="cb38-11"><a href="#cb38-11"></a></span>
<span id="cb38-12"><a href="#cb38-12"></a><span class="kw">struct</span> S <span class="op">{</span></span>
<span id="cb38-13"><a href="#cb38-13"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> ri<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">^</span>S<span class="op">::</span>i; <span class="op">}</span>;</span>
<span id="cb38-14"><a href="#cb38-14"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb38-15"><a href="#cb38-15"></a>  <span class="dt">int</span> i<span class="op">:</span><span class="dv">3</span>;                        <span class="co">// Bit field.</span></span>
<span id="cb38-16"><a href="#cb38-16"></a><span class="op">}</span> s;</span>
<span id="cb38-17"><a href="#cb38-17"></a><span class="dt">int</span> i1 <span class="op">=</span> s<span class="op">.[:</span>s<span class="op">.</span>ri<span class="op">():]</span>;            <span class="co">// Okay: Refers to S::i without needing name lookup at this point.</span></span></code></pre></div>
</blockquote>
<p>Furthermore, we propose a sequence-generating splicing construct. Let reflection_range be a constant range such that</p>
<blockquote>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1"></a><span class="cf">for</span> <span class="op">(</span>std<span class="op">::</span>meta<span class="op">::</span>info r <span class="op">:</span> reflection_range<span class="op">)</span> <span class="op">...</span></span></code></pre></div>
</blockquote>
<p>would successively set <code class="sourceCode cpp">r</code> to a sequence of values <code class="sourceCode cpp">r1</code>, <code class="sourceCode cpp">r2</code>, <code class="sourceCode cpp">r3</code>, … <code class="sourceCode cpp">rN</code>. Then</p>
<blockquote>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1"></a><span class="op">...</span> <span class="op">[:</span> reflection_range <span class="op">:]</span> <span class="op">...</span></span></code></pre></div>
</blockquote>
<p>expands like a parameter pack, but unlike a parameter pack it might be a heterogeneous expansion in that some elements of the expansions might be a type, a constant expression, or a template. The prefix <code class="sourceCode cpp"><span class="op">...</span></code> token turns the subsequent splicer into a “pack-like” construct, and the trailing <code class="sourceCode cpp"><span class="op">...</span></code> does the expansion as usual.</p>
<p>Examples:</p>
<blockquote>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1"></a>std<span class="op">::</span>meta<span class="op">::</span>info t_args<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span> <span class="op">^</span><span class="dt">int</span>, <span class="op">^</span><span class="dv">42</span> <span class="op">}</span>;</span>
<span id="cb41-2"><a href="#cb41-2"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T, T<span class="op">&gt;</span> <span class="kw">struct</span> X <span class="op">{}</span>;</span>
<span id="cb41-3"><a href="#cb41-3"></a>X<span class="op">&lt;...[:</span>t_args<span class="op">:]...&gt;</span> x; <span class="co">// Same as &quot;X&lt;int, 42&gt; x;&quot;.</span></span>
<span id="cb41-4"><a href="#cb41-4"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span>, <span class="kw">typename</span><span class="op">&gt;</span> <span class="kw">struct</span> Y <span class="op">{}</span>;</span>
<span id="cb41-5"><a href="#cb41-5"></a>Y<span class="op">&lt;...[:</span>t_args<span class="op">:]...&gt;</span> y; <span class="co">// Error: same as &quot;Y&lt;int, 42&gt; y;&quot;.</span></span></code></pre></div>
</blockquote>
<p>Some observations: * Empty ranges and singleton ranges expand as expected. * If any expansion produces an ill-formed splice, the whole construct is ill-formed but subject to SFINAE.</p>
<p>Splicing a function-local alias or declared entity outside its potential scope is ill-formed. For example:</p>
<blockquote>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1"></a><span class="kw">consteval</span> <span class="kw">auto</span> refl_int_alias<span class="op">()</span> <span class="op">{</span></span>
<span id="cb42-2"><a href="#cb42-2"></a>  <span class="kw">typedef</span> <span class="dt">int</span> Int;</span>
<span id="cb42-3"><a href="#cb42-3"></a>  <span class="cf">return</span> <span class="op">^</span>Int;</span>
<span id="cb42-4"><a href="#cb42-4"></a><span class="op">}</span></span>
<span id="cb42-5"><a href="#cb42-5"></a><span class="kw">typename</span><span class="op">[:</span>refl_int_alias<span class="op">():]</span> x; <span class="co">// Error: Cannot splice local alias here.</span></span></code></pre></div>
</blockquote>
<p>Similarly, a parameter obtained from a function type <code class="sourceCode cpp">F</code> can be spliced as an expression only within the potential scope of the corresponding argument of a function of the same type. For example (<code class="sourceCode cpp">parameters_of</code> will be described later on):</p>
<blockquote>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1"></a><span class="kw">using</span> F <span class="op">=</span> <span class="dt">int</span> <span class="op">(</span><span class="dt">int</span>, <span class="dt">int</span><span class="op">)</span>;</span>
<span id="cb43-2"><a href="#cb43-2"></a><span class="kw">auto</span> params <span class="op">=</span> std<span class="op">::</span>meta<span class="op">::</span>parameters_of<span class="op">(^</span>F<span class="op">)</span>;</span>
<span id="cb43-3"><a href="#cb43-3"></a><span class="dt">int</span> f<span class="op">(</span><span class="dt">int</span> p, <span class="dt">int</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb43-4"><a href="#cb43-4"></a>  <span class="cf">return</span> <span class="op">[:</span>params<span class="op">[</span><span class="dv">0</span><span class="op">]:]</span>; <span class="co">// Okay: Same as “return p;”</span></span>
<span id="cb43-5"><a href="#cb43-5"></a><span class="op">}</span></span>
<span id="cb43-6"><a href="#cb43-6"></a></span>
<span id="cb43-7"><a href="#cb43-7"></a><span class="dt">int</span> g<span class="op">(</span><span class="dt">int</span>, <span class="dt">char</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb43-8"><a href="#cb43-8"></a>  <span class="cf">return</span> <span class="op">[:</span>params<span class="op">[</span><span class="dv">0</span><span class="op">]:]</span>; <span class="co">// Error: params[0] comes from function type</span></span>
<span id="cb43-9"><a href="#cb43-9"></a><span class="op">}</span>                       <span class="co">// “int (int, int)” but this function has</span></span>
<span id="cb43-10"><a href="#cb43-10"></a>                        <span class="co">// type “int (int, char)”.</span></span></code></pre></div>
</blockquote>
<h2 data-number="5.1" id="splicing-identifiers"><span class="header-section-number">5.1</span> Splicing identifiers<a href="#splicing-identifiers" class="self-link"></a></h2>
<p>We anticipate the later addition of an <em>identifier-splice</em> construct (currently we use the <code class="x">[# str #]</code> syntax in discussions among authors). However, that construct operates, in part, at the lexical level and has considerably more subtleties that the authors are exploring (in part through prototype implementations). We therefore do not propose syntax for it here, and we expect that the corresponding functionality will be proposed separately later on. Unlike prior versions of this paper, this revision does not yet propose the addition of such a capability.</p>
<h2 data-number="5.2" id="access-checking"><span class="header-section-number">5.2</span> Access checking<a href="#access-checking" class="self-link"></a></h2>
<p>Splicers provide an alternative way to refer to declarations and therefore we must decide whether they are subject to access control. Access control ordinarily applies to <em>names</em>, but the <code class="sourceCode cpp"><span class="op">[:...:]</span></code> construct does not create a name and is thus not subject to access checking. For example:</p>
<blockquote>
<div class="sourceCode" id="cb44"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1"></a><span class="kw">class</span> C <span class="op">{</span></span>
<span id="cb44-2"><a href="#cb44-2"></a>  <span class="kw">using</span> Int <span class="op">=</span> <span class="dt">int</span>;</span>
<span id="cb44-3"><a href="#cb44-3"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb44-4"><a href="#cb44-4"></a>  <span class="kw">static</span> <span class="kw">consteval</span> <span class="kw">auto</span> r<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">^</span>Int; <span class="op">}</span>;</span>
<span id="cb44-5"><a href="#cb44-5"></a><span class="op">}</span> c;</span>
<span id="cb44-6"><a href="#cb44-6"></a><span class="kw">typename</span><span class="op">[:</span>C<span class="op">::</span>r<span class="op">():]</span> x; <span class="co">// Okay: x has type int</span></span></code></pre></div>
</blockquote>
<p>If we introduce identifier splicing later on (as suggested above), those kinds of splicers would be subject to access checking.</p>
<h1 data-number="6" style="border-bottom:1px solid #cccccc" id="templates-and-reflection"><span class="header-section-number">6</span> Templates and reflection<a href="#templates-and-reflection" class="self-link"></a></h1>
<p>Reflection mostly occurs “after instantiation”. For example, in:</p>
<blockquote>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="dt">void</span> f<span class="op">(</span>T p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb45-2"><a href="#cb45-2"></a>  <span class="kw">constexpr</span> <span class="kw">auto</span> r <span class="op">=</span> <span class="op">^</span>T;</span>
<span id="cb45-3"><a href="#cb45-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>the expression <code class="sourceCode cpp"><span class="op">^</span>T</code> is always a dependent expression that doesn’t produce an actual value until <code class="sourceCode cpp">f</code> is instantiated. I.e., this does not provide a mechanism to get a handle on a reflection for the template parameter <code class="sourceCode cpp">T</code> itself. However, that doesn’t mean that we don’t propose <em>any</em> facilities to reflect templated entities.</p>
<h2 data-number="6.1" id="template-arguments"><span class="header-section-number">6.1</span> Template arguments<a href="#template-arguments" class="self-link"></a></h2>
<p>We propose a function</p>
<blockquote>
<div class="sourceCode" id="cb46"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb46-2"><a href="#cb46-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> has_template_arguments<span class="op">(</span>info reflection<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb46-3"><a href="#cb46-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>that returns <code class="sourceCode cpp"><span class="kw">true</span></code> if and only if the given reflection corresponds to a template specialization (in the standard sense: implicit specializations are included).</p>
<p>The actual template arguments can be obtained through</p>
<blockquote>
<div class="sourceCode" id="cb47"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb47-2"><a href="#cb47-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> template_arguments_of<span class="op">(</span>info reflection<span class="op">)</span> <span class="op">-&gt;</span>std<span class="op">::</span>span<span class="op">&lt;</span>info<span class="op">&gt;</span> <span class="op">{...}</span>;</span>
<span id="cb47-3"><a href="#cb47-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>Conversely, the template producing a specialization can be obtained with</p>
<blockquote>
<div class="sourceCode" id="cb48"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb48-2"><a href="#cb48-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> template_of<span class="op">(</span>info reflection<span class="op">)-&gt;</span>info <span class="op">{...}</span>;</span>
<span id="cb48-3"><a href="#cb48-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>Note that the resulting reflection value (like that for reflecting a template directly) represents that template as completely known at any point it is examined (including not only the primary template definition, but also partial and full specializations). If the given reflection is not that of a specialization, an invalid reflection is returned.</p>
<h2 data-number="6.2" id="template-substitution"><span class="header-section-number">6.2</span> Template substitution<a href="#template-substitution" class="self-link"></a></h2>
<p>We also propose a facility that is the “dual notion” of the previous functions:</p>
<blockquote>
<div class="sourceCode" id="cb49"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb49-2"><a href="#cb49-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> substitute<span class="op">(</span>info templ, std<span class="op">::</span>span<span class="op">&lt;</span>info<span class="op">&gt;</span> args<span class="op">)</span> <span class="op">-&gt;</span>info <span class="op">{</span> <span class="op">...</span> <span class="op">}</span>;</span>
<span id="cb49-3"><a href="#cb49-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>This produces a declared-entity reflection for an instance given a reflection for a template and a span of reflections for specific arguments. A substitution error in the immediate context of the substitution produces an invalid reflection (this is akin to SFINAE). A substitution error outside that immediate context renders the program ill-formed. An incomplete substitution (where not all parameters are substituted by nondependent arguments) also produces an invalid reflection. Note, this functionality can also be approximated using splicers with</p>
<blockquote>
<div class="sourceCode" id="cb50"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1"></a><span class="op">^</span><span class="kw">template</span><span class="op">[:</span>templ<span class="op">:]&lt;...[:</span>args<span class="op">:]...&gt;</span></span></code></pre></div>
</blockquote>
<p>but having both improves readability depending on the context. The substitute form has the added advantage of not triggering an error for failures in the immediate context of the substitution<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>.</p>
<p>Example:</p>
<blockquote>
<div class="sourceCode" id="cb51"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">::</span>meta;</span>
<span id="cb51-2"><a href="#cb51-2"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> <span class="op">...</span> Ts<span class="op">&gt;</span> <span class="kw">struct</span> X <span class="op">{}</span>;</span>
<span id="cb51-3"><a href="#cb51-3"></a><span class="kw">template</span><span class="op">&lt;&gt;</span> <span class="kw">struct</span> X<span class="op">&lt;</span><span class="dt">int</span>, <span class="dt">int</span><span class="op">&gt;</span> <span class="op">{}</span>;</span>
<span id="cb51-4"><a href="#cb51-4"></a><span class="kw">constexpr</span> info type <span class="op">=</span> <span class="op">^</span>X<span class="op">&lt;</span><span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">float</span><span class="op">&gt;</span>;</span>
<span id="cb51-5"><a href="#cb51-5"></a><span class="kw">constexpr</span> info templ <span class="op">=</span> template_of<span class="op">(</span>type<span class="op">)</span>;</span>
<span id="cb51-6"><a href="#cb51-6"></a><span class="kw">constexpr</span> span<span class="op">&lt;</span>info<span class="op">&gt;</span> args <span class="op">=</span> template_arguments_of<span class="op">(</span>type<span class="op">)</span>;</span>
<span id="cb51-7"><a href="#cb51-7"></a><span class="kw">constexpr</span> info new_type <span class="op">=</span> substitute<span class="op">(</span>templ, args<span class="op">.</span>subspan<span class="op">(</span><span class="dv">0</span>, <span class="dv">2</span><span class="op">))</span>;</span>
<span id="cb51-8"><a href="#cb51-8"></a><span class="kw">typename</span><span class="op">[:</span>new_type<span class="op">:]</span> xii; <span class="co">// Type X&lt;int, int&gt;, which selects the specialization.</span></span>
<span id="cb51-9"><a href="#cb51-9"></a>                          <span class="co">// There is no mechanism to instantiate a primary template</span></span>
<span id="cb51-10"><a href="#cb51-10"></a>                          <span class="co">// definition that is superseded by an explicit/partial</span></span>
<span id="cb51-11"><a href="#cb51-11"></a>                          <span class="co">// specialization.</span></span></code></pre></div>
</blockquote>
<p>The use of substitute in that last example could instead be written as:</p>
<blockquote>
<div class="sourceCode" id="cb52"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1"></a><span class="kw">constexpr</span> info new_type <span class="op">=</span> <span class="op">^</span><span class="kw">template</span><span class="op">[:</span>templ<span class="op">:]&lt;...[:</span>args<span class="op">.</span>subspan<span class="op">(</span><span class="dv">0</span>, <span class="dv">2</span><span class="op">):]...&gt;</span>;</span></code></pre></div>
</blockquote>
<p>Another example illustrates how substitutions could produce non-SFINAE errors:</p>
<blockquote>
<div class="sourceCode" id="cb53"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb53-2"><a href="#cb53-2"></a>  T<span class="op">::</span>type I;</span>
<span id="cb53-3"><a href="#cb53-3"></a><span class="op">}</span>;</span>
<span id="cb53-4"><a href="#cb53-4"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T, T<span class="op">::</span>type N<span class="op">&gt;</span> <span class="kw">struct</span> Y <span class="op">{}</span>;</span>
<span id="cb53-5"><a href="#cb53-5"></a><span class="kw">constexpr</span> info ASpec <span class="op">=</span> <span class="op">^</span>A<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span>; <span class="co">// No instantiation yet.</span></span>
<span id="cb53-6"><a href="#cb53-6"></a><span class="kw">constexpr</span> info new_type2 <span class="op">=</span></span>
<span id="cb53-7"><a href="#cb53-7"></a>  substitute<span class="op">(^</span>Y, std<span class="op">::</span>vector<span class="op">&lt;</span>info<span class="op">&gt;{</span> ASpec, <span class="op">^</span><span class="dv">5</span><span class="op">})</span>;</span>
<span id="cb53-8"><a href="#cb53-8"></a>    <span class="co">// Error: Substitution of Y&lt;A&lt;int&gt;, 5&gt; requires A&lt;int&gt; to be instantiated</span></span>
<span id="cb53-9"><a href="#cb53-9"></a>    <span class="co">// outside the immediate context of the substitution.</span></span></code></pre></div>
</blockquote>
<h2 data-number="6.3" id="template-parameters"><span class="header-section-number">6.3</span> Template parameters<a href="#template-parameters" class="self-link"></a></h2>
<p>Although applying <code class="sourceCode cpp"><span class="op">^</span></code> to dependent constructs doesn’t produce an actual value until instantiation/substitution of the enclosing templated entity, reflections of template parameters can be obtained from the reflection of a template:</p>
<blockquote>
<div class="sourceCode" id="cb54"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb54-2"><a href="#cb54-2"></a><span class="kw">consteval</span> <span class="kw">auto</span> parameters_of<span class="op">(</span>info reflection<span class="op">)</span> <span class="op">-&gt;</span> std<span class="op">::</span>span<span class="op">&lt;</span>info<span class="op">&gt;</span> <span class="op">{...}</span>;</span>
<span id="cb54-3"><a href="#cb54-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>Given the reflection of a template, this returns a sequence of reflections for each template parameter. Each of these reflections can be a type, a constant, or a template. However, not all operations applicable to types/constants/templates are necessarily applicable to these reflections. For example, it would not be possible to apply the <code class="sourceCode cpp">std<span class="op">::</span>meta<span class="op">::</span>substitute</code> operation (when available) on the reflection of template template parameters (but it is possible to apply the <code class="sourceCode cpp">std<span class="op">::</span>meta<span class="op">::</span>parameters_of</code> to such a reflection).</p>
<h1 data-number="7" style="border-bottom:1px solid #cccccc" id="the-standard-metaprogramming-library"><span class="header-section-number">7</span> The standard metaprogramming library<a href="#the-standard-metaprogramming-library" class="self-link"></a></h1>
<p>We have already described a number of “metafunctions” living in namespace <code class="sourceCode cpp">std<span class="op">::</span>meta</code> that work with reflections (<code class="sourceCode cpp">entity</code>, <code class="sourceCode cpp">invalid_reflection</code>, <code class="sourceCode cpp">parameters_of</code>, etc.). We propose that these and many others make up a new section of the C++ standard library that we call “the C++ standard metaprogramming library” and which is made available to a program by including a new standard header <code class="sourceCode cpp"><span class="op">&lt;</span>meta<span class="op">&gt;</span></code>.</p>
<p>Besides the metafunctions that we have described so far, we add additional functions based on two sources: * the existing standard library’s [meta] section (described in the “General utilities” clause of the current working paper), and * the [reflect] section of the original “Reflection TS” (<span class="citation" data-cites="N4856">[<a href="#ref-N4856" role="doc-biblioref">N4856</a>]</span>).</p>
<p>We delve into how to “transcribe” those additional metafunctions from the original source below, but first a note about the API design.</p>
<h2 data-number="7.1" id="sequence-and-string-values"><span class="header-section-number">7.1</span> Sequence and string values<a href="#sequence-and-string-values" class="self-link"></a></h2>
<p>Many metafunctions deal with sequences (particularly, sequences of reflection values) and with string values (particularly, names of entities). Earlier versions of this paper used <code class="sourceCode cpp">std<span class="op">::</span>vector</code> and <code class="sourceCode cpp">std<span class="op">::</span>string</code> types for this. However, that was counting on those types being available for constant evaluation. <span class="citation" data-cites="P0784R7">[<a href="#ref-P0784R7" role="doc-biblioref">P0784R7</a>]</span> <em>mostly</em> achieved that availability, but the inability to have nontransient dynamic allocation means that, e.g., using <code class="sourceCode cpp">std<span class="op">::</span>string</code> would make it difficult to transfer a reflection string into the run-time domain.</p>
<p>We therefore now use <code class="sourceCode cpp">std<span class="op">::</span>span</code> and <code class="sourceCode cpp">std<span class="op">::</span>string_view</code> types for this, since they do not require dynamic allocation of backing storage. Instead, the compiler will have to provide static storage for, e.g., reflected strings. In practice, an implementation will want to be careful to only emit those strings in object code if they are actually used in the run-time domain, but that is not a particularly difficult implementation challenge.</p>
<h2 data-number="7.2" id="transcribing-the-standard-librarys-meta-section"><span class="header-section-number">7.2</span> Transcribing the standard library’s [meta] section<a href="#transcribing-the-standard-librarys-meta-section" class="self-link"></a></h2>
<p>The standard library [meta] section (in clause [utilities]) provides a large number of utilities to examine and construct types. We propose that all those utilities be given a counterpart in the value-based reflection world, with needed declarations made available through a new standard header <code class="sourceCode cpp"><span class="op">&lt;</span>meta<span class="op">&gt;</span></code>.</p>
<p>For example, consider the type transformation trait</p>
<blockquote>
<div class="sourceCode" id="cb55"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1"></a>std<span class="op">::</span>make_signed<span class="op">&lt;</span>T<span class="op">&gt;</span></span></code></pre></div>
</blockquote>
<p>which produces a result through its member type</p>
<blockquote>
<div class="sourceCode" id="cb56"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb56-1"><a href="#cb56-1"></a>std<span class="op">::</span>make_signed<span class="op">&lt;</span>T<span class="op">&gt;::</span>type</span></code></pre></div>
</blockquote>
<p>We propose to have a <code class="sourceCode cpp">std<span class="op">::</span>meta</code> counterpart as follows:</p>
<blockquote>
<div class="sourceCode" id="cb57"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb57-2"><a href="#cb57-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> make_signed<span class="op">(</span>info reflection<span class="op">)-&gt;</span>info <span class="op">{...}</span>;</span>
<span id="cb57-3"><a href="#cb57-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>This is expected to be implemented using an intrinsic in the compiler (although that is not a requirement). For a reflection value <code class="sourceCode cpp">r</code> corresponding to a type <code class="sourceCode cpp">T</code> such that</p>
<blockquote>
<div class="sourceCode" id="cb58"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb58-1"><a href="#cb58-1"></a>std<span class="op">::</span>make_signed<span class="op">&lt;</span>T<span class="op">&gt;::</span>type</span></code></pre></div>
</blockquote>
<p>is valid, using the new function as <code class="sourceCode cpp">make_signed<span class="op">(</span>r<span class="op">)</span></code> is equivalent to:</p>
<blockquote>
<div class="sourceCode" id="cb59"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb59-1"><a href="#cb59-1"></a><span class="op">^</span>std<span class="op">::</span>make_signed<span class="op">&lt;</span><span class="kw">typename</span><span class="op">(</span>r<span class="op">)&gt;::</span>type</span></code></pre></div>
</blockquote>
<p>(except for not actually instantiating templates in a quality implementation). For a reflection value for which the above transformation would not be valid (e.g., <code class="sourceCode cpp"><span class="op">^</span><span class="dt">void</span></code>), however, the function returns an invalid reflection.</p>
<p>Most templates specified in [meta.trans] can be transcribed in a similar way, but a few take additional nontype template parameters. Their transcription is also straightforward however. We illustrate this with the <code class="sourceCode cpp">std<span class="op">::</span>enable_if</code> template whose consteval counterpart can be implemented efficiently without intrinsics. The already-standard template-based interface is usually implemented as follows:</p>
<blockquote>
<div class="sourceCode" id="cb60"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb60-1"><a href="#cb60-1"></a><span class="kw">namespace</span> std <span class="op">{</span></span>
<span id="cb60-2"><a href="#cb60-2"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="dt">bool</span>, <span class="kw">typename</span> T <span class="op">=</span> <span class="dt">void</span><span class="op">&gt;</span> <span class="kw">struct</span> enable_if <span class="op">{}</span>;</span>
<span id="cb60-3"><a href="#cb60-3"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">struct</span> enable_if<span class="op">&lt;</span><span class="kw">true</span>, T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb60-4"><a href="#cb60-4"></a>    <span class="kw">using</span> type <span class="op">=</span> T;</span>
<span id="cb60-5"><a href="#cb60-5"></a>  <span class="op">}</span>;</span>
<span id="cb60-6"><a href="#cb60-6"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>The reflection counterpart is then (including a hypothetical implementation)</p>
<blockquote>
<div class="sourceCode" id="cb61"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb61-1"><a href="#cb61-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb61-2"><a href="#cb61-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> enable_if<span class="op">(</span><span class="dt">bool</span> cond, info type <span class="op">=</span> <span class="op">^</span><span class="dt">void</span><span class="op">)</span> <span class="op">-&gt;</span> info <span class="op">{</span></span>
<span id="cb61-3"><a href="#cb61-3"></a>    <span class="cf">if</span> <span class="op">(</span>cond<span class="op">)</span> <span class="op">{</span></span>
<span id="cb61-4"><a href="#cb61-4"></a>      <span class="cf">return</span> type;</span>
<span id="cb61-5"><a href="#cb61-5"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb61-6"><a href="#cb61-6"></a>      <span class="cf">return</span> invalid_reflection<span class="op">(</span><span class="st">&quot;enable_if condition false&quot;</span><span class="op">)</span>;</span>
<span id="cb61-7"><a href="#cb61-7"></a>    <span class="op">}</span></span>
<span id="cb61-8"><a href="#cb61-8"></a>  <span class="op">}</span></span>
<span id="cb61-9"><a href="#cb61-9"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>(We encourage programmers to prefer <em>requires-clauses</em> over enable_if for constraining templates.)</p>
<p>The type traits predicates described in [meta.unary] and [meta.rel] are just as easily mapped to the value-based reflection world. For example, the three templates</p>
<blockquote>
<div class="sourceCode" id="cb62"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb62-1"><a href="#cb62-1"></a><span class="kw">namespace</span> std <span class="op">{</span></span>
<span id="cb62-2"><a href="#cb62-2"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">struct</span> is_union;</span>
<span id="cb62-3"><a href="#cb62-3"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T, <span class="kw">typename</span> <span class="op">...</span> Args<span class="op">&gt;</span> <span class="kw">struct</span> is_constructible;</span>
<span id="cb62-4"><a href="#cb62-4"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> B, <span class="kw">typename</span> D<span class="op">&gt;</span> <span class="kw">struct</span> is_base_of;</span>
<span id="cb62-5"><a href="#cb62-5"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>have counterparts as follows:</p>
<blockquote>
<div class="sourceCode" id="cb63"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb63-1"><a href="#cb63-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb63-2"><a href="#cb63-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_union<span class="op">(</span>info reflection<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb63-3"><a href="#cb63-3"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_constructible<span class="op">(</span>info reflection, std<span class="op">::</span>span<span class="op">&lt;</span>info<span class="op">&gt;</span> arg_types<span class="op">)</span> <span class="op">-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb63-4"><a href="#cb63-4"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_base_of<span class="op">(</span>info base_type, info derived_type<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb63-5"><a href="#cb63-5"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>The other cases follow the same patterns.</p>
<p>The three templates in [meta.unary.prop.query]:</p>
<blockquote>
<div class="sourceCode" id="cb64"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb64-1"><a href="#cb64-1"></a><span class="kw">namespace</span> std <span class="op">{</span></span>
<span id="cb64-2"><a href="#cb64-2"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">struct</span> alignment_of;</span>
<span id="cb64-3"><a href="#cb64-3"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">struct</span> rank;</span>
<span id="cb64-4"><a href="#cb64-4"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T, <span class="dt">unsigned</span> I <span class="op">=</span> <span class="dv">0</span><span class="op">&gt;</span> <span class="kw">struct</span> extent;</span>
<span id="cb64-5"><a href="#cb64-5"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>are slightly irregular, but the corresponding functions can still be intuited:</p>
<blockquote>
<div class="sourceCode" id="cb65"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb65-1"><a href="#cb65-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb65-2"><a href="#cb65-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> alignment_of<span class="op">(</span>info type<span class="op">)-&gt;</span>std<span class="op">::</span><span class="dt">size_t</span> <span class="op">{...}</span>;</span>
<span id="cb65-3"><a href="#cb65-3"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> rank<span class="op">(</span>info type<span class="op">)-&gt;</span><span class="dt">int</span> <span class="op">{...}</span>;</span>
<span id="cb65-4"><a href="#cb65-4"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> extent<span class="op">(</span>info type, <span class="dt">unsigned</span> dim <span class="op">=</span> <span class="dv">0</span><span class="op">)-&gt;</span><span class="dt">int</span> <span class="op">{...}</span>;</span>
<span id="cb65-5"><a href="#cb65-5"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>The helper templates in [meta.help] and [meta.logical] are not needed for value-based reflection since their counterparts are core language features (like the integer types and the logical operators).</p>
<h2 data-number="7.3" id="adapting-the-reflection-ts-reflect-section"><span class="header-section-number">7.3</span> Adapting the Reflection TS’ [reflect] section<a href="#adapting-the-reflection-ts-reflect-section" class="self-link"></a></h2>
<p>The Reflection TS (<span class="citation" data-cites="N4818">[<a href="#ref-N4818" role="doc-biblioref">N4818</a>]</span>) introduces a large number of template metafunctions. This proposal steals many of those features and adapts them to the value-based reflection world. However, we make some changes to better align the semantics with the constraints of the language definition and the flexibility of our value-based approach.</p>
<h3 data-number="7.3.1" id="predicates"><span class="header-section-number">7.3.1</span> Predicates<a href="#predicates" class="self-link"></a></h3>
<p>Let’s start with the predicates (metafunctions returning a bool value). For example, <code class="sourceCode cpp">is_public</code> gets a counterpart as follows:</p>
<blockquote>
<div class="sourceCode" id="cb66"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb66-1"><a href="#cb66-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb66-2"><a href="#cb66-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_public<span class="op">(</span>info base_or_mem<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb66-3"><a href="#cb66-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>That function fails to evaluate to a constant if <code class="sourceCode cpp">base_or_mem</code> does not designate a base class or a class member (that constraint corresponds to the concepts requirements imposed for the class template <code class="sourceCode cpp">is_public</code> proposed in the Reflection TS). <code class="sourceCode cpp">is_protected</code>, <code class="sourceCode cpp">is_private</code>, <code class="sourceCode cpp">is_accessible</code> (which checks whether a member is accessible from the context of invocation), <code class="sourceCode cpp">is_virtual</code>, and <code class="sourceCode cpp">is_final</code> are handled in the same way. For example:</p>
<blockquote>
<div class="sourceCode" id="cb67"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb67-1"><a href="#cb67-1"></a><span class="kw">struct</span> S <span class="op">{</span> <span class="dt">int</span> x; <span class="op">}</span>;</span>
<span id="cb67-2"><a href="#cb67-2"></a><span class="kw">constexpr</span> <span class="dt">bool</span> t <span class="op">=</span> std<span class="op">::</span>meta<span class="op">::</span>is_public<span class="op">(^</span>S<span class="op">::</span>x<span class="op">)</span>; <span class="co">// = true;</span></span>
<span id="cb67-3"><a href="#cb67-3"></a><span class="kw">constexpr</span> <span class="dt">bool</span> e <span class="op">=</span> std<span class="op">::</span>meta<span class="op">::</span>is_public<span class="op">(^</span>S<span class="op">)</span>;    <span class="co">// Error: Not a constant because ^S is not a base or member.</span></span></code></pre></div>
</blockquote>
<p>The <code class="sourceCode cpp">is_unnamed</code> metafunction is transcribed similarly:</p>
<blockquote>
<div class="sourceCode" id="cb68"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb68-1"><a href="#cb68-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb68-2"><a href="#cb68-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_unnamed<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb68-3"><a href="#cb68-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>but this time the function only evaluates to a constant if the given reflection represents a namespace, a data member, a function, a template, a variable, a type, or an enumerator. Failing to evaluate a constant will result in an error, or a deduction failure if in a SFINAE context.</p>
<p><code class="sourceCode cpp">is_scoped_enum</code> becomes</p>
<blockquote>
<div class="sourceCode" id="cb69"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb69-1"><a href="#cb69-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb69-2"><a href="#cb69-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_scoped_enum<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb69-3"><a href="#cb69-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>and always evaluates to a constant.</p>
<p>We propose to replace <code class="sourceCode cpp">is_constexpr</code> by:</p>
<blockquote>
<div class="sourceCode" id="cb70"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb70-1"><a href="#cb70-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb70-2"><a href="#cb70-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_declared_constexpr<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb70-3"><a href="#cb70-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>which is a constant value if <code class="sourceCode cpp">entity</code> designates a variable, a function, a static data member, or a template for these. (We propose the alternative name to distinguish the entities that are declared with the <code class="sourceCode cpp"><span class="kw">constexpr</span></code> or <code class="sourceCode cpp"><span class="kw">consteval</span></code> specifier from entities that are effectively <code class="sourceCode cpp"><span class="kw">constexpr</span></code> (e.g., a function template may be declared <code class="sourceCode cpp"><span class="kw">constexpr</span></code> and its instances would produce <code class="sourceCode cpp"><span class="kw">true</span></code> values with this predicate; however, the instances may not actually be <code class="sourceCode cpp"><span class="kw">constexpr</span></code> functions; conversely, lambda call operators and special member functions may be <code class="sourceCode cpp"><span class="kw">constexpr</span></code> functions without being declared <code class="sourceCode cpp"><span class="kw">constexpr</span></code>).</p>
<p>Immediate (<code class="sourceCode cpp"><span class="kw">consteval</span></code>) functions and function templates are also identifiable:</p>
<blockquote>
<div class="sourceCode" id="cb71"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb71-1"><a href="#cb71-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb71-2"><a href="#cb71-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_consteval<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb71-3"><a href="#cb71-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>Instead of <code class="sourceCode cpp">is_static</code> (for variables) we propose:</p>
<blockquote>
<div class="sourceCode" id="cb72"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb72-1"><a href="#cb72-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb72-2"><a href="#cb72-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> has_static_storage_duration<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb72-3"><a href="#cb72-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>because <code class="sourceCode cpp">is_static</code> suggests a query about a storage class specifier rather than a storage duration.</p>
<blockquote>
<div class="sourceCode" id="cb73"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb73-1"><a href="#cb73-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb73-2"><a href="#cb73-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_inline<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb73-3"><a href="#cb73-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>produces a constant value for reflections of variables, functions, variable/function templates, and namespaces.</p>
<p>A number of function properties produce a constant value for reflections of functions only:</p>
<blockquote>
<div class="sourceCode" id="cb74"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb74-1"><a href="#cb74-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb74-2"><a href="#cb74-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_deleted<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb74-3"><a href="#cb74-3"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_defaulted<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb74-4"><a href="#cb74-4"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_explicit<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb74-5"><a href="#cb74-5"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_override<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb74-6"><a href="#cb74-6"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_pure_virtual<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb74-7"><a href="#cb74-7"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>The following predicates always produce a constant value given a reflection. They produce a <code class="sourceCode cpp"><span class="kw">false</span></code> value for invalid reflections, and otherwise return <code class="sourceCode cpp"><span class="kw">true</span></code> if the predicate applies to the reflected entity:</p>
<blockquote>
<div class="sourceCode" id="cb75"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb75-1"><a href="#cb75-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb75-2"><a href="#cb75-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_class_member<span class="op">(</span>info reflection<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb75-3"><a href="#cb75-3"></a>    <span class="co">// Return true for class and class template members.</span></span>
<span id="cb75-4"><a href="#cb75-4"></a>  <span class="op">...</span></span>
<span id="cb75-5"><a href="#cb75-5"></a>  <span class="op">}</span>;</span>
<span id="cb75-6"><a href="#cb75-6"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_local<span class="op">(</span>info reflection<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb75-7"><a href="#cb75-7"></a>    <span class="co">// Return true for local variables, local members.</span></span>
<span id="cb75-8"><a href="#cb75-8"></a>  <span class="op">...</span></span>
<span id="cb75-9"><a href="#cb75-9"></a>      <span class="op">}</span>;</span>
<span id="cb75-10"><a href="#cb75-10"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_namespace<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb75-11"><a href="#cb75-11"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_template<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb75-12"><a href="#cb75-12"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_type<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb75-13"><a href="#cb75-13"></a>    <span class="co">// Return true for types and type aliases.</span></span>
<span id="cb75-14"><a href="#cb75-14"></a>    <span class="op">...</span></span>
<span id="cb75-15"><a href="#cb75-15"></a>  <span class="op">}</span>;</span>
<span id="cb75-16"><a href="#cb75-16"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_incomplete_type<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span>;</span>
<span id="cb75-17"><a href="#cb75-17"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_closure_type<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb75-18"><a href="#cb75-18"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> has_captures<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb75-19"><a href="#cb75-19"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> has_default_ref_capture<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb75-20"><a href="#cb75-20"></a>    <span class="co">// Return true even if there is no effective capture (i.e., it’s syntactical only).</span></span>
<span id="cb75-21"><a href="#cb75-21"></a>    <span class="op">...</span></span>
<span id="cb75-22"><a href="#cb75-22"></a>  <span class="op">}</span>;</span>
<span id="cb75-23"><a href="#cb75-23"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> has_default_copy_capture<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb75-24"><a href="#cb75-24"></a>    <span class="co">// Return true even if there is no effective capture (i.e., it’s syntactical only).</span></span>
<span id="cb75-25"><a href="#cb75-25"></a>    <span class="op">...</span></span>
<span id="cb75-26"><a href="#cb75-26"></a>  <span class="op">}</span>;</span>
<span id="cb75-27"><a href="#cb75-27"></a></span>
<span id="cb75-28"><a href="#cb75-28"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_simple_capture<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb75-29"><a href="#cb75-29"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_ref_capture<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb75-30"><a href="#cb75-30"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_copy_capture<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb75-31"><a href="#cb75-31"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_explicit_capture<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb75-32"><a href="#cb75-32"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_init_capture<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb75-33"><a href="#cb75-33"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_function_parameter<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb75-34"><a href="#cb75-34"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_template_parameter<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb75-35"><a href="#cb75-35"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_class_template<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb75-36"><a href="#cb75-36"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_alias<span class="op">(</span>info reflection<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb75-37"><a href="#cb75-37"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_alias_template<span class="op">(</span>info reflection<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb75-38"><a href="#cb75-38"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_enumerator<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb75-39"><a href="#cb75-39"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_variable<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb75-40"><a href="#cb75-40"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_variable_template<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb75-41"><a href="#cb75-41"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_static_data_member<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb75-42"><a href="#cb75-42"></a>    <span class="cf">return</span> is_variable<span class="op">(</span>entity<span class="op">)</span> <span class="op">&amp;&amp;</span> is_class_member<span class="op">(</span>entity<span class="op">)</span>;</span>
<span id="cb75-43"><a href="#cb75-43"></a>  <span class="op">}</span>;</span>
<span id="cb75-44"><a href="#cb75-44"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_nonstatic_data_member<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb75-45"><a href="#cb75-45"></a>    <span class="co">// Return true for nonstatic data members, which includes bit fields.</span></span>
<span id="cb75-46"><a href="#cb75-46"></a>    <span class="op">...</span></span>
<span id="cb75-47"><a href="#cb75-47"></a>  <span class="op">}</span>;</span>
<span id="cb75-48"><a href="#cb75-48"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_bit_field<span class="op">(</span>info reflection<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb75-49"><a href="#cb75-49"></a>    <span class="co">// Return true for bit fields, but also for expressions that are bit field selections.</span></span>
<span id="cb75-50"><a href="#cb75-50"></a>    <span class="op">...</span></span>
<span id="cb75-51"><a href="#cb75-51"></a>  <span class="op">}</span>;</span>
<span id="cb75-52"><a href="#cb75-52"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_base_class<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb75-53"><a href="#cb75-53"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_direct_base_class<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb75-54"><a href="#cb75-54"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_virtual_base_class<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb75-55"><a href="#cb75-55"></a>  <span class="cf">return</span> is_base_class<span class="op">(</span>entity<span class="op">)</span> <span class="op">&amp;&amp;</span> is_virtual<span class="op">(</span>entity<span class="op">)</span>;</span>
<span id="cb75-56"><a href="#cb75-56"></a>  <span class="op">}</span></span>
<span id="cb75-57"><a href="#cb75-57"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_function<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb75-58"><a href="#cb75-58"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_function_template<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb75-59"><a href="#cb75-59"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_member_function<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb75-60"><a href="#cb75-60"></a>    <span class="cf">return</span> is_function<span class="op">(</span>entity<span class="op">)</span> <span class="op">&amp;&amp;</span> is_class_member<span class="op">(</span>entity<span class="op">)</span>;</span>
<span id="cb75-61"><a href="#cb75-61"></a>  <span class="op">}</span>;</span>
<span id="cb75-62"><a href="#cb75-62"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_member_function_template<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb75-63"><a href="#cb75-63"></a>    <span class="cf">return</span> is_function_template<span class="op">(</span>entity<span class="op">)</span> <span class="op">&amp;&amp;</span> is_class_member<span class="op">(</span>entity<span class="op">)</span>;</span>
<span id="cb75-64"><a href="#cb75-64"></a>  <span class="op">}</span>;</span>
<span id="cb75-65"><a href="#cb75-65"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_static_member_function<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb75-66"><a href="#cb75-66"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_static_member_function_template<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb75-67"><a href="#cb75-67"></a></span>
<span id="cb75-68"><a href="#cb75-68"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_nonstatic_member_function<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb75-69"><a href="#cb75-69"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_nonstatic_member_function_template<span class="op">(</span>info entity<span class="op">)</span> <span class="op">-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb75-70"><a href="#cb75-70"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_constructor<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb75-71"><a href="#cb75-71"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_constructor_template<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb75-72"><a href="#cb75-72"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_destructor<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb75-73"><a href="#cb75-73"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> is_destructor_template<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb75-74"><a href="#cb75-74"></a><span class="op">}</span> <span class="co">// namespace std::meta</span></span></code></pre></div>
</blockquote>
<p>Note that <code class="sourceCode cpp">is_bit_field</code> above is more general than what the TS proposed since it applies not only to the reflection of data members but also to expressions, because “bitfieldness” is a significant property of an expression. Similarly, we add the following five predicates (with no equivalent in the TS) for reflections of expressions:</p>
<blockquote>
<div class="sourceCode" id="cb76"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb76-1"><a href="#cb76-1"></a><span class="kw">consteval</span> <span class="kw">auto</span> is_lvalue<span class="op">(</span>info reflection<span class="op">)-&gt;</span><span class="dt">bool</span>;</span>
<span id="cb76-2"><a href="#cb76-2"></a><span class="kw">consteval</span> <span class="kw">auto</span> is_xvalue<span class="op">(</span>info reflection<span class="op">)-&gt;</span><span class="dt">bool</span>;</span>
<span id="cb76-3"><a href="#cb76-3"></a><span class="kw">consteval</span> <span class="kw">auto</span> is_prvalue<span class="op">(</span>info reflection<span class="op">)-&gt;</span><span class="dt">bool</span>;</span>
<span id="cb76-4"><a href="#cb76-4"></a><span class="kw">consteval</span> <span class="kw">auto</span> is_glvalue<span class="op">(</span>info reflection<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb76-5"><a href="#cb76-5"></a>  <span class="cf">return</span> is_lvalue<span class="op">(</span>reflection<span class="op">)</span> <span class="op">||</span> is_xvalue<span class="op">(</span>reflection<span class="op">)</span>;</span>
<span id="cb76-6"><a href="#cb76-6"></a><span class="op">}</span></span>
<span id="cb76-7"><a href="#cb76-7"></a><span class="kw">consteval</span> <span class="kw">auto</span> is_rvalue<span class="op">(</span>info reflection<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb76-8"><a href="#cb76-8"></a>  <span class="cf">return</span> is_pralue<span class="op">(</span>reflection<span class="op">)</span> <span class="op">||</span> is_xvalue<span class="op">(</span>reflection<span class="op">)</span>;</span>
<span id="cb76-9"><a href="#cb76-9"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>The following predicate produces a constant value given the reflection of a function type or closure type, or an alias thereof:</p>
<blockquote>
<div class="sourceCode" id="cb77"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb77-1"><a href="#cb77-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb77-2"><a href="#cb77-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> has_ellipsis<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb77-3"><a href="#cb77-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>The following predicate produces a constant value given the reflection of a function type or an alias thereof:</p>
<blockquote>
<div class="sourceCode" id="cb78"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb78-1"><a href="#cb78-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb78-2"><a href="#cb78-2"></a><span class="kw">consteval</span> <span class="kw">auto</span> is_member_function_type<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb78-3"><a href="#cb78-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>Given the reflection of a function or template parameter, <code class="sourceCode cpp">std<span class="op">::</span>meta<span class="op">:</span>has_default</code> returns whether it has an associated default argument:</p>
<blockquote>
<div class="sourceCode" id="cb79"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb79-1"><a href="#cb79-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb79-2"><a href="#cb79-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> has_default<span class="op">(</span>info entity<span class="op">)-&gt;</span><span class="dt">bool</span> <span class="op">{...}</span>;</span>
<span id="cb79-3"><a href="#cb79-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<h3 data-number="7.3.2" id="singular-properties"><span class="header-section-number">7.3.2</span> Singular Properties<a href="#singular-properties" class="self-link"></a></h3>
<p>This section lists facilities that return properties described with a “single value”. The following function can be used to identify a source location of a declared entity:</p>
<blockquote>
<div class="sourceCode" id="cb80"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb80-1"><a href="#cb80-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb80-2"><a href="#cb80-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> source_location_of<span class="op">(</span>info entity<span class="op">)</span> <span class="op">-&gt;</span>std<span class="op">::</span>source_location <span class="op">{...}</span>;</span>
<span id="cb80-3"><a href="#cb80-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>Although this produces a constant result for any reflection value, the returned value is unspecified if the reflection is not that of a declared entity (or alias).</p>
<p>The name of declared entities can be accessed through the following:</p>
<blockquote>
<div class="sourceCode" id="cb81"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb81-1"><a href="#cb81-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb81-2"><a href="#cb81-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> name_of<span class="op">(</span>info entity<span class="op">)-&gt;</span>std<span class="op">::</span>string_view <span class="op">{...}</span>;</span>
<span id="cb81-3"><a href="#cb81-3"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> display_name_of<span class="op">(</span>info entity<span class="op">)</span> <span class="op">-&gt;</span>std<span class="op">::</span>string_view <span class="op">{...}</span>;</span>
<span id="cb81-4"><a href="#cb81-4"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>For named declared entities/aliases, <code class="sourceCode cpp">name_of</code> returns a constant string_view describing the same identifier as that produced by the <code class="sourceCode cpp"><span class="op">[:</span> info <span class="op">:]</span></code> splicer. For any other operand, it produces a constant empty <code class="sourceCode cpp">string_view</code>.</p>
<p>The <code class="sourceCode cpp">display_name_of</code> function produces an unspecified constant non-empty <code class="sourceCode cpp">string_view</code> for any reflection (implementations are encouraged to produce a string that is helpful in identifying the reflected item).</p>
<p>Aliases can be “looked through” using the aforementioned function <code class="sourceCode cpp">entity</code>:</p>
<blockquote>
<div class="sourceCode" id="cb82"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb82-1"><a href="#cb82-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb82-2"><a href="#cb82-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> entity<span class="op">(</span>info reflection<span class="op">)-&gt;</span>info <span class="op">{...}</span>;</span>
<span id="cb82-3"><a href="#cb82-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>A reflection for the type associated with an entity or expression can be retrieved with</p>
<blockquote>
<div class="sourceCode" id="cb83"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb83-1"><a href="#cb83-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb83-2"><a href="#cb83-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> type_of<span class="op">(</span>info reflection<span class="op">)-&gt;</span>info <span class="op">{...}</span>;</span>
<span id="cb83-3"><a href="#cb83-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>If reflection describes an entity (not an expression) that is not a variable, base class, data member, function, or enumerator, this function returns an invalid reflection.</p>
<p>A “parent” entity can be identified with</p>
<blockquote>
<div class="sourceCode" id="cb84"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb84-1"><a href="#cb84-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb84-2"><a href="#cb84-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> parent_of<span class="op">(</span>info reflection<span class="op">)-&gt;</span>info <span class="op">{...}</span>;</span>
<span id="cb84-3"><a href="#cb84-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>For members of classes or namespaces this returns a reflection of the innermost class or namespace. For a base class, this returns the class type from which the base class was obtained (only direct and virtual base classes can be reflected). For function-local entities that are not class members, <code class="sourceCode cpp">parent_of</code> returns the a reflection of the enclosing function. For reflections that do not designate an alias or a declared entity, <code class="sourceCode cpp">parent_of</code> returns an invalid reflection.</p>
<p>The innermost enclosing function and class can also be queried:</p>
<blockquote>
<div class="sourceCode" id="cb85"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb85-1"><a href="#cb85-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb85-2"><a href="#cb85-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> current_function<span class="op">()-&gt;</span>info <span class="op">{...}</span></span>
<span id="cb85-3"><a href="#cb85-3"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> current_class_type<span class="op">()-&gt;</span>info <span class="op">{...}</span></span>
<span id="cb85-4"><a href="#cb85-4"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>That is particularly useful to deal more efficiently with parameter packs (an example will be presented later on). Note that when invoked from an immediate function in a context that does not require a constant-expression, these functions return the result as if invoked from the calling function. Given the reflection of a base or nonstatic data member of a class (but not a class template), layout information can be retrieved with the following functions:</p>
<blockquote>
<div class="sourceCode" id="cb86"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb86-1"><a href="#cb86-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb86-2"><a href="#cb86-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> byte_offset_of<span class="op">(</span>info entity<span class="op">)-&gt;</span>std<span class="op">::</span><span class="dt">size_t</span> <span class="op">{...}</span>;</span>
<span id="cb86-3"><a href="#cb86-3"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> bit_offset_of<span class="op">(</span>info entity<span class="op">)-&gt;</span>std<span class="op">::</span><span class="dt">size_t</span> <span class="op">{...}</span>;</span>
<span id="cb86-4"><a href="#cb86-4"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> byte_size_of<span class="op">(</span>info entity<span class="op">)-&gt;</span>std<span class="op">::</span><span class="dt">size_t</span> <span class="op">{...}</span>;</span>
<span id="cb86-5"><a href="#cb86-5"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> bit_size_of<span class="op">(</span>info entity<span class="op">)-&gt;</span>std<span class="op">::</span><span class="dt">size_t</span> <span class="op">{...}</span>;</span>
<span id="cb86-6"><a href="#cb86-6"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>For reflections that do not designate a base or a nonstatic data member, this does not successfully produce a constant value. <code class="sourceCode cpp">byte_offset_of</code> returns the byte offset of the given base or nonstatic data member (within the parent class). For bit-fields, the offset of the first byte containing the bit field is returned; the bit offset of the first bit (counting from the least significant bit) within that byte is produced by <code class="sourceCode cpp">bit_offset_of</code> (for non-bit-fields, that function returns zero). <code class="sourceCode cpp">byte_size_of</code> produces the allocated size of the associated subobject, except that is does not produce a constant value for bit fields (for base classes, the result may be less than <code class="sourceCode cpp"><span class="kw">sizeof</span></code> applied to the base class type). <code class="sourceCode cpp">bit_size_of</code> produces the allocated size of the associated bit field subobject, and does not produce a constant value for non-bit-field reflections. (A precise specification of this requires a slight tightening of the C++ object model. All implementations already conform to the stricter model.)</p>
<p>The following facilities permit examining parameter types and the <code class="sourceCode cpp"><span class="kw">this</span></code> binding type:</p>
<blockquote>
<div class="sourceCode" id="cb87"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb87-1"><a href="#cb87-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb87-2"><a href="#cb87-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> this_ref_type<span class="op">(</span>info func_type<span class="op">)-&gt;</span>info <span class="op">{...}</span>;</span>
<span id="cb87-3"><a href="#cb87-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>For a member function type <code class="sourceCode cpp">this_ref_type</code> returns the reflection of the parent class associated with the member type, with any member function <em>cv-qualifiers</em> and <em>ref-qualifiers</em> added on top. For example:</p>
<blockquote>
<div class="sourceCode" id="cb88"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb88-1"><a href="#cb88-1"></a><span class="kw">struct</span> S <span class="op">{</span></span>
<span id="cb88-2"><a href="#cb88-2"></a>  <span class="dt">int</span> f<span class="op">()</span> <span class="kw">volatile</span> <span class="op">&amp;&amp;</span>;</span>
<span id="cb88-3"><a href="#cb88-3"></a>  <span class="dt">int</span> g<span class="op">()</span> <span class="kw">const</span>;</span>
<span id="cb88-4"><a href="#cb88-4"></a><span class="op">}</span> s;</span>
<span id="cb88-5"><a href="#cb88-5"></a><span class="kw">constexpr</span> <span class="kw">auto</span> r <span class="op">=</span> this_ref_type<span class="op">(^</span>s<span class="op">.</span>f<span class="op">())</span>; <span class="co">// Reflection for type “S volatile &amp;&amp;”.</span></span>
<span id="cb88-6"><a href="#cb88-6"></a><span class="kw">constexpr</span> <span class="kw">auto</span> r <span class="op">=</span> this_ref_type<span class="op">(^</span>s<span class="op">.</span>g<span class="op">())</span>; <span class="co">// Reflection for type “S const”.</span></span></code></pre></div>
</blockquote>
<h3 data-number="7.3.3" id="plural-properties"><span class="header-section-number">7.3.3</span> Plural properties<a href="#plural-properties" class="self-link"></a></h3>
<p>This section lists metafunctions that return <code class="sourceCode cpp">std<span class="op">::</span>span<span class="op">&lt;</span>info<span class="op">&gt;</span></code> values describing “plural properties” (such as lists of members).</p>
<p>We propose the following function templates to retrieve subobject information:</p>
<blockquote>
<div class="sourceCode" id="cb89"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb89-1"><a href="#cb89-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb89-2"><a href="#cb89-2"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> <span class="op">...</span>Fs<span class="op">&gt;</span></span>
<span id="cb89-3"><a href="#cb89-3"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> members_of<span class="op">(</span>info class_type, Fs <span class="op">...</span>filters<span class="op">)</span> <span class="op">-&gt;</span>std<span class="op">::</span>span<span class="op">&lt;</span>info<span class="op">&gt;</span> <span class="op">{...}</span>;</span>
<span id="cb89-4"><a href="#cb89-4"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> <span class="op">...</span>Fs<span class="op">&gt;</span></span>
<span id="cb89-5"><a href="#cb89-5"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> bases_of<span class="op">(</span>info class_type, Fs <span class="op">...</span>filters<span class="op">)</span> <span class="op">-&gt;</span>std<span class="op">::</span>span<span class="op">&lt;</span>info<span class="op">&gt;</span> <span class="op">{...}</span>;</span>
<span id="cb89-6"><a href="#cb89-6"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>If called with an argument for <code class="sourceCode cpp">class_type</code> that is the reflection of a non-class type or a capturing closure type (or an alias/cv-qualified version thereof), these facilities return a span referencing a single invalid reflection.</p>
<p>Otherwise, if no <code class="sourceCode cpp">filters</code> argument is passed to it, <code class="sourceCode cpp">members_of</code> returns an “unfiltered” sequence of reflections for the following kinds of direct members of a class type (represented by <code class="sourceCode cpp">class_type</code>): nonstatic and static data members and member functions, member types (enumeration and class types) and member aliases, and member templates other than deduction guides. Generated members are included, but inherited constructors, injected-class-names, and unnamed bit fields are not (the standard doesn’t consider those members either). Nonstatic data members appear in declaration order (but not necessarily consecutively).</p>
<p>If any “filters” are passed, they are applied as predicates to the unfiltered sequence, and members for which a predicate produces <code class="sourceCode cpp"><span class="kw">false</span></code> are left out. Predicates are applied left-to-right with short-circuit semantics (i.e., later predicates are not applied if an earlier predicate produced <code class="sourceCode cpp"><span class="kw">false</span></code>).</p>
<p>Similarly, without <code class="sourceCode cpp">filter</code> arguments, invoking <code class="sourceCode cpp">bases_of</code> returns a sequence of reflections for the direct bases of the given (non-capturing-closure) class type. Predicates can be added to narrow down the bases of interest.</p>
<p>The following example illustrates some uses of <code class="sourceCode cpp">members_of</code>:</p>
<blockquote>
<div class="sourceCode" id="cb90"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb90-1"><a href="#cb90-1"></a><span class="kw">struct</span> S <span class="op">{</span></span>
<span id="cb90-2"><a href="#cb90-2"></a>  <span class="dt">double</span> x;</span>
<span id="cb90-3"><a href="#cb90-3"></a>  <span class="dt">int</span> y;</span>
<span id="cb90-4"><a href="#cb90-4"></a>  <span class="dt">void</span> f<span class="op">()</span>;</span>
<span id="cb90-5"><a href="#cb90-5"></a><span class="op">}</span>;</span>
<span id="cb90-6"><a href="#cb90-6"></a><span class="kw">constexpr</span> <span class="kw">auto</span> class_type <span class="op">=</span> <span class="op">^</span>S;</span>
<span id="cb90-7"><a href="#cb90-7"></a><span class="kw">constexpr</span> <span class="kw">auto</span> s_members <span class="op">=</span> members_of<span class="op">(</span>class_type<span class="op">)</span>;</span>
<span id="cb90-8"><a href="#cb90-8"></a><span class="kw">static_assert</span><span class="op">(</span>s_members<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">7</span><span class="op">)</span>;       <span class="co">// x, y, f(), the destructor, and generated constructors.</span></span>
<span id="cb90-9"><a href="#cb90-9"></a><span class="kw">constexpr</span> <span class="kw">auto</span> s_data_members <span class="op">=</span> members_of<span class="op">(</span>class_type, is_nonstatic_data_member<span class="op">)</span>;</span>
<span id="cb90-10"><a href="#cb90-10"></a><span class="kw">static_assert</span><span class="op">(</span>s_data_members<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">2</span><span class="op">)</span>;  <span class="co">// x and y.</span></span>
<span id="cb90-11"><a href="#cb90-11"></a></span>
<span id="cb90-12"><a href="#cb90-12"></a><span class="kw">consteval</span> <span class="kw">auto</span> has_integral_type<span class="op">(</span>std<span class="op">::</span>meta<span class="op">::</span>info reflection<span class="op">)</span> <span class="op">{</span></span>
<span id="cb90-13"><a href="#cb90-13"></a>  <span class="cf">return</span> std<span class="op">::</span>meta<span class="op">::</span>is_integral<span class="op">(</span>std<span class="op">::</span>meta<span class="op">::</span>type_of<span class="op">(</span>reflection<span class="op">))</span>;</span>
<span id="cb90-14"><a href="#cb90-14"></a><span class="op">}</span>;</span>
<span id="cb90-15"><a href="#cb90-15"></a><span class="kw">constexpr</span> <span class="kw">auto</span> s_imembers <span class="op">=</span> members_of<span class="op">(</span>class_type, is_nonstatic_data_member, has_integral_type<span class="op">)</span>;</span>
<span id="cb90-16"><a href="#cb90-16"></a><span class="kw">static_assert</span><span class="op">(</span>s_imembers<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span>;     <span class="co">// Just y.</span></span>
<span id="cb90-17"><a href="#cb90-17"></a><span class="kw">constexpr</span> <span class="kw">auto</span> s_nested_types <span class="op">=</span> members_of<span class="op">(</span>class_type, is_type<span class="op">)</span>;</span>
<span id="cb90-18"><a href="#cb90-18"></a><span class="kw">static_assert</span><span class="op">(</span>s_members<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span>;      <span class="co">// S has no nested types.</span></span></code></pre></div>
</blockquote>
<p>The enumerators of an enumeration type can be inspected using <code class="sourceCode cpp">enumerators_of</code>:</p>
<blockquote>
<div class="sourceCode" id="cb91"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb91-1"><a href="#cb91-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb91-2"><a href="#cb91-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> enumerators_of<span class="op">(</span>info enum_type<span class="op">)-&gt;</span>std<span class="op">::</span>span<span class="op">&lt;</span>info<span class="op">&gt;</span> <span class="op">{...}</span>;</span>
<span id="cb91-3"><a href="#cb91-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>If the argument passed for <code class="sourceCode cpp">enum_type</code> is not a reflection for an enumeration type, this returns a span referencing just an invalid reflection.</p>
<p>The parameters of a function type or the parameters of a template can be inspected using:</p>
<blockquote>
<div class="sourceCode" id="cb92"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb92-1"><a href="#cb92-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb92-2"><a href="#cb92-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> parameters_of<span class="op">(</span>info reflection<span class="op">)</span> <span class="op">-&gt;</span>std<span class="op">::</span>span<span class="op">&lt;</span>info<span class="op">&gt;</span> <span class="op">{...}</span>;</span>
<span id="cb92-3"><a href="#cb92-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>If the argument passed for <code class="sourceCode cpp">reflection</code> is not a reflection for a function, a member function, a function type, a closure type, or a template, this returns a span referencing one invalid reflection. Otherwise, the span contains an entry for each ordinary parameter: No entry is made for the <code class="sourceCode cpp"><span class="kw">this</span></code> parameter or for an ellipsis parameter.</p>
<p>A function is also available to introspect lambda captures associated with a closure type:</p>
<blockquote>
<div class="sourceCode" id="cb93"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb93-1"><a href="#cb93-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb93-2"><a href="#cb93-2"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> captures_of<span class="op">(</span>info closure_type<span class="op">)</span> <span class="op">-&gt;</span>std<span class="op">::</span>span<span class="op">&lt;</span>info<span class="op">&gt;</span> <span class="op">{...}</span>;</span>
<span id="cb93-3"><a href="#cb93-3"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>If the argument passed for <code class="sourceCode cpp">closure_type</code> is not a reflection for a closure type, this returns a span referencing just an invalid reflection.</p>
<p>Of note here is that we are not proposing a function to retrieve members of namespaces: Due to their “open scope” nature, we believe that capability is somewhat meaningless. There is however no known technical reason preventing us from doing so.</p>
<p>We are also not proposing functions to expose the structure of templates. In particular, there is no mechanism to retrieve the members of a class template or the function parameters of a function template.</p>
<h2 data-number="7.4" id="anonymous-unions"><span class="header-section-number">7.4</span> Anonymous unions<a href="#anonymous-unions" class="self-link"></a></h2>
<p>Consider:</p>
<blockquote>
<div class="sourceCode" id="cb94"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb94-1"><a href="#cb94-1"></a><span class="kw">struct</span> S <span class="op">{</span></span>
<span id="cb94-2"><a href="#cb94-2"></a>  <span class="dt">bool</span> flag;</span>
<span id="cb94-3"><a href="#cb94-3"></a>  <span class="kw">union</span> <span class="op">{</span></span>
<span id="cb94-4"><a href="#cb94-4"></a>    <span class="dt">int</span> x;</span>
<span id="cb94-5"><a href="#cb94-5"></a>    <span class="dt">float</span> f;</span>
<span id="cb94-6"><a href="#cb94-6"></a>  <span class="op">}</span>;</span>
<span id="cb94-7"><a href="#cb94-7"></a><span class="op">}</span>;</span>
<span id="cb94-8"><a href="#cb94-8"></a></span>
<span id="cb94-9"><a href="#cb94-9"></a><span class="kw">constexpr</span> <span class="kw">auto</span> dmembers <span class="op">=</span> members_of<span class="op">(^</span>S, is_nonstatic_data_member<span class="op">)</span>;</span>
<span id="cb94-10"><a href="#cb94-10"></a><span class="kw">static_assert</span><span class="op">(</span>dmembers<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">2</span><span class="op">)</span>;</span></code></pre></div>
</blockquote>
<p>The sequence <code class="sourceCode cpp">dmembers</code> here will contain two reflections: One for flag and one for an unnamed data member of the unnamed union type. Conversely, <code class="sourceCode cpp">parent_of<span class="op">(^</span>S<span class="op">::</span>x<span class="op">)</span></code> produces a reflection for that unnamed union type rather than for <code class="sourceCode cpp">S</code>. Despite its lack of a declared name (which means <code class="sourceCode cpp">name_of</code> returns an empty <code class="sourceCode cpp">string_view</code>), the unnamed data member can be referred to with the <code class="sourceCode cpp"><span class="op">[:</span> <span class="op">...</span> <span class="op">:]</span></code> splicer:</p>
<blockquote>
<div class="sourceCode" id="cb95"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb95-1"><a href="#cb95-1"></a><span class="kw">constexpr</span> S s <span class="op">=</span> <span class="op">{</span> <span class="kw">false</span>, <span class="op">{</span> <span class="op">.</span>x <span class="op">=</span> <span class="dv">42</span> <span class="op">}</span> <span class="op">}</span>;</span>
<span id="cb95-2"><a href="#cb95-2"></a><span class="kw">static_assert</span><span class="op">(</span>name_of<span class="op">(</span>dmembers<span class="op">[</span><span class="dv">1</span><span class="op">])</span> <span class="op">==</span> <span class="st">&quot;&quot;</span><span class="op">)</span>;                                          <span class="co">// Okay.</span></span>
<span id="cb95-3"><a href="#cb95-3"></a><span class="kw">static_assert</span><span class="op">(</span>s<span class="op">.</span>idexpr<span class="op">(</span> dmembers<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">).</span>x <span class="op">==</span> <span class="dv">42</span><span class="op">)</span>;                                     <span class="co">// Okay.</span></span>
<span id="cb95-4"><a href="#cb95-4"></a><span class="kw">static_assert</span><span class="op">(</span>remove_reference<span class="op">(^</span><span class="kw">decltype</span><span class="op">(</span>s<span class="op">.[:</span>dmembers<span class="op">[</span><span class="dv">1</span><span class="op">]:]))</span> <span class="op">==</span> parent_of<span class="op">(^</span>S<span class="op">::</span>f<span class="op">)</span>;   <span class="co">// Okay.</span></span></code></pre></div>
</blockquote>
<p>Let’s take that last line apart.</p>
<p>In the left-hand side of the equality test <code class="sourceCode cpp">dmembers<span class="op">[</span><span class="dv">1</span><span class="op">]</span></code> is a reflection of the unnamed data member for the anonymous union. Therefore, <code class="sourceCode cpp">s<span class="op">.[:</span>dmembers<span class="op">[</span><span class="dv">1</span><span class="op">]:]</span></code> is an lvalue designating the anonymous union subobject of <code class="sourceCode cpp">s</code>, and thus <code class="sourceCode cpp"><span class="kw">decltype</span></code> applied to that produces a reference to the anonymous union type. The <code class="sourceCode cpp"><span class="op">^</span></code> operator returns the reflection designating that type and <code class="sourceCode cpp">remove_reference</code> finally returns a reflection designating the underlying union type.</p>
<p>In the right-hand side, <code class="sourceCode cpp"><span class="op">^</span>S<span class="op">::</span>f</code> is a reflection designating the member <code class="sourceCode cpp">S<span class="op">::</span>f</code>, which is actually a member <code class="sourceCode cpp">S<span class="op">::&lt;</span>unnamed<span class="op">-</span><span class="kw">union</span><span class="op">-</span>type<span class="op">&gt;::</span>f</code>. Therefore, <code class="sourceCode cpp">parent_of</code> also produces a reflection designating the underlying union type of the anonymous union, and the assertion succeeds.</p>
<h2 data-number="7.5" id="other-facilities"><span class="header-section-number">7.5</span> Other Facilities<a href="#other-facilities" class="self-link"></a></h2>
<h3 data-number="7.5.1" id="reflecting-values"><span class="header-section-number">7.5.1</span> Reflecting values<a href="#reflecting-values" class="self-link"></a></h3>
<p>It turns out to be useful to be able to lift a constant value into reflections for an expression denoting that constant value. We therefore propose a pair of metafunction templates to do exactly that:</p>
<blockquote>
<div class="sourceCode" id="cb96"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb96-1"><a href="#cb96-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb96-2"><a href="#cb96-2"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb96-3"><a href="#cb96-3"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> reflect_value<span class="op">(</span>T <span class="kw">const</span><span class="op">&amp;)-&gt;</span>info;</span>
<span id="cb96-4"><a href="#cb96-4"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> R<span class="op">&gt;</span></span>
<span id="cb96-5"><a href="#cb96-5"></a>  <span class="kw">consteval</span> <span class="kw">auto</span> reflect_values<span class="op">(</span>R <span class="kw">const</span><span class="op">&amp;)-&gt;</span>std<span class="op">::</span>span<span class="op">&lt;</span>info<span class="op">&gt;</span>;</span>
<span id="cb96-6"><a href="#cb96-6"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>(The second template applies the first to each element of a range of values.)</p>
<p>For example:</p>
<blockquote>
<div class="sourceCode" id="cb97"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb97-1"><a href="#cb97-1"></a><span class="kw">constexpr</span> std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">{</span> <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> <span class="op">}</span>;</span>
<span id="cb97-2"><a href="#cb97-2"></a><span class="kw">constexpr</span> std<span class="op">::</span>span<span class="op">&lt;</span>std<span class="op">::</span>meta<span class="op">::</span>info<span class="op">&gt;</span> rv <span class="op">=</span> reflect_values<span class="op">(</span>v<span class="op">)</span>;</span></code></pre></div>
</blockquote>
<p>Such a lifted sequence can then be spliced into a template argument context:</p>
<blockquote>
<div class="sourceCode" id="cb98"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb98-1"><a href="#cb98-1"></a>std<span class="op">::</span>integer_sequence<span class="op">&lt;</span><span class="dt">int</span>, <span class="op">...[:</span>rv<span class="op">:]...&gt;</span> is123; <span class="co">// same as std::integer_sequence&lt;int, 1, 2, 3&gt;</span></span></code></pre></div>
</blockquote>
<p>provided the reflected constants are valid in that context.</p>
<h1 data-number="8" style="border-bottom:1px solid #cccccc" id="metaprogramming-examples"><span class="header-section-number">8</span> Metaprogramming Examples<a href="#metaprogramming-examples" class="self-link"></a></h1>
<p>We believe that the facilities presented here permit the kind of computation previously performed with C++ template metaprogramming and that they are preferable over TMP because they scale better. We therefore suggest that no broad set of TMP facilities should be further added to the language.</p>
<p>Examples in this section are drawn from a variety of sources, including <span class="citation" data-cites="P0385R0">[<a href="#ref-P0385R0" role="doc-biblioref">P0385R0</a>]</span> by Matúš Chochlík and Axel Naumann and <span class="citation" data-cites="P0949R0">[<a href="#ref-P0949R0" role="doc-biblioref">P0949R0</a>]</span> by Peter Dimov.</p>
<h2 data-number="8.1" id="hashing"><span class="header-section-number">8.1</span> Hashing<a href="#hashing" class="self-link"></a></h2>
<p>We can also use the approach above to synthesize an overload of hash_append (proposed by Howard Hinnant et al. in <span class="citation" data-cites="N3980">[<a href="#ref-N3980" role="doc-biblioref">N3980</a>]</span>, Types Don’t Know #).</p>
<blockquote>
<div class="sourceCode" id="cb99"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb99-1"><a href="#cb99-1"></a><span class="pp">#include </span><span class="im">&lt;meta&gt;</span></span>
<span id="cb99-2"><a href="#cb99-2"></a></span>
<span id="cb99-3"><a href="#cb99-3"></a><span class="kw">namespace</span> meta <span class="op">=</span> std<span class="op">::</span>meta;</span>
<span id="cb99-4"><a href="#cb99-4"></a><span class="kw">template</span><span class="op">&lt;</span>HashAlgorithm H, StandardLayoutType T<span class="op">&gt;</span></span>
<span id="cb99-5"><a href="#cb99-5"></a>  <span class="dt">bool</span> hash_append<span class="op">(</span>H <span class="op">&amp;</span>algo, <span class="kw">const</span> T <span class="op">&amp;</span>t<span class="op">)</span> <span class="op">{</span></span>
<span id="cb99-6"><a href="#cb99-6"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> data_members <span class="op">=</span> members_of<span class="op">(^</span>T, meta<span class="op">::</span>is_nonstatic_data_member<span class="op">)</span>;</span>
<span id="cb99-7"><a href="#cb99-7"></a>    <span class="kw">template</span> <span class="cf">for</span> <span class="op">(</span><span class="kw">constexpr</span> meta<span class="op">::</span>info member <span class="op">:</span> data_members<span class="op">)</span></span>
<span id="cb99-8"><a href="#cb99-8"></a>      hash_append<span class="op">(</span>algo, t<span class="op">.[:</span>member<span class="op">:])</span>;</span>
<span id="cb99-9"><a href="#cb99-9"></a>  <span class="op">}</span></span></code></pre></div>
</blockquote>
<p>The algorithm is straightforward: Recursively apply hash_append to each member for the class <code class="sourceCode cpp">T</code>. Within that call the expression <code class="sourceCode cpp">t<span class="op">.[:</span>member<span class="op">:]</span></code> yields a <em>postfix-expression</em> for the designated member in the class object. The resolution of that <em>postfix-expression</em> does not require name lookup or access control (unlike by-name mechanisms), and it works even for bit fields (unlike mechanisms based on pointer-to-member values).</p>
<p>Note that this uses expansion statements as proposed by <span class="citation" data-cites="P1306R1">[<a href="#ref-P1306R1" role="doc-biblioref">P1306R1</a>]</span> (and that is typical of practical uses of reflection). An expansion statement requires a compile-time range, which is why <code class="sourceCode cpp">data_members</code> must be a <code class="sourceCode cpp"><span class="kw">constexpr</span></code> variable.</p>
<h2 data-number="8.2" id="schema-generation"><span class="header-section-number">8.2</span> Schema generation<a href="#schema-generation" class="self-link"></a></h2>
<p>We can use this same pattern to generate SQL schemas from C++ classes. The implementation here mixes runtime SQL generation with static reflection, in order to demonstrate the interaction between these two features.</p>
<p>The entry point for the facility is a function template that takes a (standard layout) type parameter and writes the corresponding SQL CREATE TABLE statement.</p>
<blockquote>
<div class="sourceCode" id="cb100"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb100-1"><a href="#cb100-1"></a><span class="kw">template</span><span class="op">&lt;</span>StandardLayoutType T<span class="op">&gt;</span></span>
<span id="cb100-2"><a href="#cb100-2"></a><span class="dt">void</span> create_table<span class="op">()</span> <span class="op">{</span></span>
<span id="cb100-3"><a href="#cb100-3"></a>  create_table_from_reflection<span class="op">&lt;^</span>T<span class="op">&gt;()</span>;</span>
<span id="cb100-4"><a href="#cb100-4"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>This function simply delegates to a function parameterized by its reflection. Because reflection is expected to be an “advanced” feature, it might be desirable to hide it from user-facing interfaces. The SQL generating function template is shown below.</p>
<blockquote>
<div class="sourceCode" id="cb101"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb101-1"><a href="#cb101-1"></a><span class="pp">#include </span><span class="im">&lt;meta&gt;</span></span>
<span id="cb101-2"><a href="#cb101-2"></a><span class="kw">namespace</span> meta <span class="op">=</span> std<span class="op">::</span>meta;</span>
<span id="cb101-3"><a href="#cb101-3"></a></span>
<span id="cb101-4"><a href="#cb101-4"></a><span class="kw">template</span><span class="op">&lt;</span>meta<span class="op">::</span>info Class<span class="op">&gt;</span></span>
<span id="cb101-5"><a href="#cb101-5"></a>  <span class="kw">requires</span> meta<span class="op">::</span>is_class<span class="op">(</span>Class<span class="op">)</span></span>
<span id="cb101-6"><a href="#cb101-6"></a><span class="dt">void</span> create_table_from_reflection<span class="op">()</span> <span class="op">{</span></span>
<span id="cb101-7"><a href="#cb101-7"></a>  std<span class="op">::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;CREATE TABLE &quot;</span> <span class="op">&lt;&lt;</span> meta<span class="op">::</span>name_of<span class="op">(</span>Class<span class="op">)</span> <span class="op">&lt;&lt;</span> “<span class="op">(</span>\n”;</span>
<span id="cb101-8"><a href="#cb101-8"></a>  <span class="kw">constexpr</span> <span class="kw">auto</span> members <span class="op">=</span> meta<span class="op">::</span>members_of<span class="op">(</span>Class, is_non_static_data_member<span class="op">)</span>;</span>
<span id="cb101-9"><a href="#cb101-9"></a>  <span class="dt">int</span> size <span class="op">=</span> members<span class="op">.</span>size<span class="op">()</span>, num <span class="op">=</span> <span class="dv">0</span>;</span>
<span id="cb101-10"><a href="#cb101-10"></a>  <span class="kw">template</span> <span class="cf">for</span> <span class="op">(</span><span class="kw">constexpr</span> meta<span class="op">::</span>info member <span class="op">:</span> members<span class="op">)</span> <span class="op">{</span></span>
<span id="cb101-11"><a href="#cb101-11"></a>    create_column<span class="op">&lt;</span>member<span class="op">&gt;()</span>;</span>
<span id="cb101-12"><a href="#cb101-12"></a>    <span class="cf">if</span> <span class="op">(++</span>num <span class="op">!=</span> size<span class="op">)</span></span>
<span id="cb101-13"><a href="#cb101-13"></a>      std<span class="op">::</span>cout <span class="op">&lt;&lt;</span> “,\n”;</span>
<span id="cb101-14"><a href="#cb101-14"></a>  <span class="op">}</span></span>
<span id="cb101-15"><a href="#cb101-15"></a>  std<span class="op">::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;);</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb101-16"><a href="#cb101-16"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>This function emits a CREATE TABLE statement for the name of the class, and “iterates” over the class’s data members — again using an <em>expansion statement</em> (<span class="citation" data-cites="P1306R1">[<a href="#ref-P1306R1" role="doc-biblioref">P1306R1</a>]</span>) — emitting column definitions for each (see below for <code class="sourceCode cpp">create_column</code>). We maintain the member count so that we can correctly insert commas into the output after each column.</p>
<p>Reflection facilities can only be used at compile time. Because this function mixes runtime code (<code class="sourceCode cpp">std<span class="op">::</span>cout</code>) with static reflection (<code class="sourceCode cpp">meta<span class="op">::</span>info</code>), we need to ensure that reflections do not “mix” with the runtime systems. We cannot, with this approach to generating SQL, pass the reflected class as a function argument, as that would leak the reflection — handle to an internal data structure that is only meaningful during translation — to run time. In other words, for mixed run-time/reflective algorithms reflection values must be passed as template arguments. We explore an alternative design of this algorithm in the following section.</p>
<p>Creating a column is straightforward: We serialize the member’s name and translate its C++ type into SQL.</p>
<blockquote>
<pre class="cp"><code>template&lt;meta::info Member&gt;
  requires meta::is_non_static_data_member(Member)
void create_column() {
  std::cout &lt;&lt; meta::name_of(Member) &lt;&lt; &quot; &quot;;
  std::cout &lt;&lt; to_sql(meta::type_of(Member));
}</code></pre>
</blockquote>
<p>Finally, we need a facility to translate C++ types to SQL types. Here, we use a series of explicit specializations over reflections, with the generic case (i.e., primary template) triggering an instantiation error if used.</p>
<blockquote>
<div class="sourceCode" id="cb102"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb102-1"><a href="#cb102-1"></a><span class="kw">template</span><span class="op">&lt;</span>meta<span class="op">::</span>info Type<span class="op">&gt;</span></span>
<span id="cb102-2"><a href="#cb102-2"></a><span class="kw">consteval</span> <span class="kw">const</span> <span class="dt">char</span><span class="op">*</span> to_sql<span class="op">()</span> <span class="op">{</span></span>
<span id="cb102-3"><a href="#cb102-3"></a>  <span class="kw">static_assert</span><span class="op">(</span><span class="kw">false</span>, “no translation to SQL”<span class="op">)</span>;</span>
<span id="cb102-4"><a href="#cb102-4"></a><span class="op">}</span></span>
<span id="cb102-5"><a href="#cb102-5"></a></span>
<span id="cb102-6"><a href="#cb102-6"></a><span class="kw">template</span><span class="op">&lt;&gt;</span></span>
<span id="cb102-7"><a href="#cb102-7"></a><span class="kw">consteval</span> <span class="kw">const</span> <span class="dt">char</span><span class="op">*</span> to_sql<span class="op">&lt;^</span><span class="dt">int</span><span class="op">&gt;()</span> <span class="op">{</span></span>
<span id="cb102-8"><a href="#cb102-8"></a>  <span class="cf">return</span> “INTEGER”;</span>
<span id="cb102-9"><a href="#cb102-9"></a><span class="op">}</span></span>
<span id="cb102-10"><a href="#cb102-10"></a></span>
<span id="cb102-11"><a href="#cb102-11"></a><span class="kw">template</span><span class="op">&lt;&gt;</span></span>
<span id="cb102-12"><a href="#cb102-12"></a><span class="kw">consteval</span> <span class="kw">const</span> <span class="dt">char</span><span class="op">*</span> to_sql<span class="op">&lt;^</span><span class="dt">float</span><span class="op">&gt;()</span> <span class="op">{</span></span>
<span id="cb102-13"><a href="#cb102-13"></a>  <span class="cf">return</span> “FLOAT”;</span>
<span id="cb102-14"><a href="#cb102-14"></a><span class="op">}</span></span>
<span id="cb102-15"><a href="#cb102-15"></a><span class="co">// etc</span></span></code></pre></div>
</blockquote>
<h2 data-number="8.3" id="schema-generation-take-two"><span class="header-section-number">8.3</span> Schema generation (take two)<a href="#schema-generation-take-two" class="self-link"></a></h2>
<p>The approach above mixes runtime SQL generation with static reflection: We call a function to print the schema to <code class="sourceCode cpp">std<span class="op">::</span>cout</code>. An alternative approach is to synthesize the schema as a compile-time string, and then print the result later:</p>
<blockquote>
<div class="sourceCode" id="cb103"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb103-1"><a href="#cb103-1"></a><span class="kw">template</span><span class="op">&lt;</span>StandardLayoutType T<span class="op">&gt;</span></span>
<span id="cb103-2"><a href="#cb103-2"></a><span class="kw">consteval</span> std<span class="op">::</span>string create_table<span class="op">()</span> <span class="op">{</span></span>
<span id="cb103-3"><a href="#cb103-3"></a>  <span class="cf">return</span> create_table_from_reflection<span class="op">&lt;^</span>T<span class="op">&gt;()</span>;</span>
<span id="cb103-4"><a href="#cb103-4"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>The string-generation code could be as follows</p>
<blockquote>
<div class="sourceCode" id="cb104"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb104-1"><a href="#cb104-1"></a><span class="pp">#include </span><span class="im">&lt;meta&gt;</span></span>
<span id="cb104-2"><a href="#cb104-2"></a></span>
<span id="cb104-3"><a href="#cb104-3"></a><span class="kw">template</span><span class="op">&lt;</span>meta<span class="op">::</span>info Class<span class="op">&gt;</span></span>
<span id="cb104-4"><a href="#cb104-4"></a>  <span class="kw">requires</span> meta<span class="op">::</span>is_class<span class="op">(</span>Class<span class="op">)</span></span>
<span id="cb104-5"><a href="#cb104-5"></a><span class="kw">consteval</span> std<span class="op">::</span>string create_table<span class="op">()</span> <span class="op">{</span></span>
<span id="cb104-6"><a href="#cb104-6"></a>  std<span class="op">::</span>string result<span class="op">(</span>“”<span class="op">)</span>; <span class="co">// Assuming this should work</span></span>
<span id="cb104-7"><a href="#cb104-7"></a>  result <span class="op">+=</span> <span class="st">&quot;CREATE TABLE &quot;</span> <span class="op">+</span> meta<span class="op">::</span>name_of<span class="op">(</span>Class<span class="op">)</span> <span class="op">+</span> “<span class="op">(</span>\n”;</span>
<span id="cb104-8"><a href="#cb104-8"></a>  std<span class="op">::</span>span<span class="op">&lt;</span>meta<span class="op">::</span>info<span class="op">&gt;</span> members <span class="op">=</span> data_members_of<span class="op">(^</span>Class<span class="op">)</span>;</span>
<span id="cb104-9"><a href="#cb104-9"></a>  <span class="dt">int</span> num <span class="op">=</span> <span class="dv">0</span>;</span>
<span id="cb104-10"><a href="#cb104-10"></a>  <span class="cf">for</span> <span class="op">(</span>meta<span class="op">::</span>info member <span class="op">:</span> members<span class="op">)</span> <span class="op">{</span></span>
<span id="cb104-11"><a href="#cb104-11"></a>    result <span class="op">+=</span> create_column<span class="op">(</span>member<span class="op">)</span>;</span>
<span id="cb104-12"><a href="#cb104-12"></a>    <span class="cf">if</span> <span class="op">(++</span>num <span class="op">!=</span> members<span class="op">.</span>size<span class="op">())</span></span>
<span id="cb104-13"><a href="#cb104-13"></a>      result <span class="op">+=</span> “,\n”;</span>
<span id="cb104-14"><a href="#cb104-14"></a>  <span class="op">}</span></span>
<span id="cb104-15"><a href="#cb104-15"></a>  result <span class="op">+=</span> <span class="st">&quot;);</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb104-16"><a href="#cb104-16"></a>  <span class="cf">return</span> result;</span>
<span id="cb104-17"><a href="#cb104-17"></a><span class="op">}</span></span>
<span id="cb104-18"><a href="#cb104-18"></a></span>
<span id="cb104-19"><a href="#cb104-19"></a><span class="kw">consteval</span> std<span class="op">::</span>string <span class="dt">void</span> create_column<span class="op">(</span>meta<span class="op">::</span>info member<span class="op">)</span> <span class="op">{</span></span>
<span id="cb104-20"><a href="#cb104-20"></a>  std<span class="op">::</span>string result<span class="op">(</span>“”<span class="op">)</span>;</span>
<span id="cb104-21"><a href="#cb104-21"></a>  result <span class="op">+=</span> meta<span class="op">::</span>name_of<span class="op">(</span>member<span class="op">)</span> <span class="op">+</span> <span class="st">&quot; &quot;</span>;</span>
<span id="cb104-22"><a href="#cb104-22"></a>  result <span class="op">+=</span> to_sql<span class="op">(</span>meta<span class="op">::</span>type_of<span class="op">(</span>member<span class="op">))</span>;</span>
<span id="cb104-23"><a href="#cb104-23"></a>  <span class="cf">return</span> result;</span>
<span id="cb104-24"><a href="#cb104-24"></a><span class="op">}</span></span>
<span id="cb104-25"><a href="#cb104-25"></a></span>
<span id="cb104-26"><a href="#cb104-26"></a><span class="kw">consteval</span> <span class="kw">const</span> <span class="dt">char</span><span class="op">*</span> to_sql<span class="op">(</span>meta<span class="op">::</span>info type<span class="op">)</span> <span class="op">{</span></span>
<span id="cb104-27"><a href="#cb104-27"></a>  <span class="kw">static</span> std<span class="op">::</span>unordered_map<span class="op">&lt;</span>meta<span class="op">::</span>info, <span class="kw">const</span> <span class="dt">char</span><span class="op">*&gt;</span> types <span class="op">{</span></span>
<span id="cb104-28"><a href="#cb104-28"></a>    <span class="op">{^</span><span class="dt">int</span>, “INTEGER”<span class="op">}</span>,</span>
<span id="cb104-29"><a href="#cb104-29"></a>    <span class="op">{^</span><span class="dt">float</span>, “FLOAT”<span class="op">}</span>,</span>
<span id="cb104-30"><a href="#cb104-30"></a>    <span class="co">// etc.</span></span>
<span id="cb104-31"><a href="#cb104-31"></a>  <span class="op">}</span>;</span>
<span id="cb104-32"><a href="#cb104-32"></a></span>
<span id="cb104-33"><a href="#cb104-33"></a>  <span class="op">[[</span><span class="at">assert</span><span class="op">:</span><span class="at"> meta</span><span class="op">::</span><span class="at">is_type</span><span class="op">(</span><span class="at">type</span><span class="op">)]]</span>;</span>
<span id="cb104-34"><a href="#cb104-34"></a>  <span class="op">[[</span><span class="at">assert</span><span class="op">:</span><span class="at"> types</span><span class="op">.</span><span class="at">count</span><span class="op">(</span><span class="at">type</span><span class="op">)</span><span class="at"> </span><span class="op">!=</span><span class="at"> </span><span class="dv">0</span><span class="op">]]</span>;</span>
<span id="cb104-35"><a href="#cb104-35"></a>  <span class="cf">return</span> types<span class="op">.</span>find<span class="op">(</span>type<span class="op">)-&gt;</span>second;</span>
<span id="cb104-36"><a href="#cb104-36"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>There are significant differences between this and the earlier example. In essence, this implementation looks like a normal program except that each function is a <code class="sourceCode cpp"><span class="kw">consteval</span></code> function dealing with reflection values. In other words, because the entire facility is expected to run at compile time, we don’t have to use different constructs between the run-time and compile-time values in the implementation (e.g., expansion statements vs. loops); everything just looks like run-time code.</p>
<h2 data-number="8.4" id="template-argument-list-assignment"><span class="header-section-number">8.4</span> Template argument list assignment<a href="#template-argument-list-assignment" class="self-link"></a></h2>
<p>In <span class="citation" data-cites="P0949R0">[<a href="#ref-P0949R0" role="doc-biblioref">P0949R0</a>]</span>, Peter Dimov proposes a facility to “assign” a list of template arguments for one template to another using:</p>
<blockquote>
<div class="sourceCode" id="cb105"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb105-1"><a href="#cb105-1"></a>mp_assign<span class="op">&lt;</span>ClassTmpl1<span class="op">&lt;</span>A1, A2, <span class="op">...&gt;</span>, ClassTmpl2<span class="op">&lt;</span>B1, B2, <span class="op">...&gt;&gt;</span></span></code></pre></div>
</blockquote>
<p>This is an alias for <code class="sourceCode cpp">ClassTmpl1<span class="op">&lt;</span>B1, B2, <span class="op">...&gt;</span></code>. The template arguments <code class="sourceCode cpp">An</code> and <code class="sourceCode cpp">Bn</code> are all type arguments. If the arguments of mp_assign are not of those forms, a substitution failure occurs.</p>
<p>Using the features proposed in this paper, we can implement this facility as follows:</p>
<blockquote>
<div class="sourceCode" id="cb106"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb106-1"><a href="#cb106-1"></a><span class="pp">#include </span><span class="im">&lt;meta&gt;</span></span>
<span id="cb106-2"><a href="#cb106-2"></a><span class="kw">using</span> std<span class="op">::</span>meta<span class="op">::</span>info;</span>
<span id="cb106-3"><a href="#cb106-3"></a><span class="kw">using</span> std<span class="op">::</span>vector;</span>
<span id="cb106-4"><a href="#cb106-4"></a></span>
<span id="cb106-5"><a href="#cb106-5"></a><span class="kw">consteval</span> info class_template_of<span class="op">(</span>info inst<span class="op">)</span> <span class="op">{</span></span>
<span id="cb106-6"><a href="#cb106-6"></a>  <span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">::</span>meta;</span>
<span id="cb106-7"><a href="#cb106-7"></a>  info tmpl <span class="op">=</span> template_of<span class="op">(</span>inst<span class="op">)</span>;</span>
<span id="cb106-8"><a href="#cb106-8"></a>  <span class="cf">if</span> <span class="op">(</span>is_class_template<span class="op">(</span>inst<span class="op">)</span> <span class="op">||</span> is_invalid_reflection<span class="op">(</span>tmpl<span class="op">)</span> <span class="op">{</span></span>
<span id="cb106-9"><a href="#cb106-9"></a>    <span class="cf">return</span> tmpl;</span>
<span id="cb106-10"><a href="#cb106-10"></a>  <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb106-11"><a href="#cb106-11"></a>    <span class="cf">return</span> invalid_reflection<span class="op">(</span><span class="st">&quot;Not a class template instance&quot;</span><span class="op">)</span>;</span>
<span id="cb106-12"><a href="#cb106-12"></a>  <span class="op">}</span></span>
<span id="cb106-13"><a href="#cb106-13"></a><span class="op">}</span></span>
<span id="cb106-14"><a href="#cb106-14"></a></span>
<span id="cb106-15"><a href="#cb106-15"></a><span class="kw">consteval</span> vector<span class="op">&lt;</span>info<span class="op">&gt;</span> template_type_arguments_of<span class="op">(</span>info inst<span class="op">)</span> <span class="op">{</span></span>
<span id="cb106-16"><a href="#cb106-16"></a>  <span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">::</span>meta;</span>
<span id="cb106-17"><a href="#cb106-17"></a>  <span class="kw">auto</span> args <span class="op">=</span> template_arguments_of<span class="op">(</span>inst<span class="op">)</span>;</span>
<span id="cb106-18"><a href="#cb106-18"></a>  <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> arg<span class="op">:</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb106-19"><a href="#cb106-19"></a>    <span class="cf">if</span> <span class="op">(</span>is_invalid<span class="op">(</span>arg<span class="op">)</span> <span class="op">&amp;&amp;</span> args<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb106-20"><a href="#cb106-20"></a>      <span class="co">// template_arguments_of was invalid: Propagate the error.</span></span>
<span id="cb106-21"><a href="#cb106-21"></a>      <span class="cf">return</span> vector<span class="op">&lt;</span>info<span class="op">&gt;(</span>args<span class="op">.</span>begin<span class="op">()</span>, args<span class="op">.</span>end<span class="op">())</span>;</span>
<span id="cb106-22"><a href="#cb106-22"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(!</span>is_type<span class="op">(</span>arg<span class="op">))</span> <span class="op">{</span></span>
<span id="cb106-23"><a href="#cb106-23"></a>      <span class="co">// Not a type argument.</span></span>
<span id="cb106-24"><a href="#cb106-24"></a>      <span class="cf">return</span> vector<span class="op">&lt;</span>info<span class="op">&gt;{</span>invalid_reflection<span class="op">(</span><span class="st">&quot;Not all arguments are types&quot;</span><span class="op">)}</span>;</span>
<span id="cb106-25"><a href="#cb106-25"></a>    <span class="op">}</span></span>
<span id="cb106-26"><a href="#cb106-26"></a>  <span class="op">}</span></span>
<span id="cb106-27"><a href="#cb106-27"></a>  <span class="cf">return</span> vector<span class="op">&lt;</span>info<span class="op">&gt;(</span>args<span class="op">.</span>begin<span class="op">()</span>, args<span class="op">.</span>end<span class="op">())</span>;</span>
<span id="cb106-28"><a href="#cb106-28"></a><span class="op">}</span></span>
<span id="cb106-29"><a href="#cb106-29"></a></span>
<span id="cb106-30"><a href="#cb106-30"></a><span class="kw">consteval</span> info rf_assign<span class="op">(</span>info inst1, info inst2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb106-31"><a href="#cb106-31"></a>  <span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">::</span>meta;</span>
<span id="cb106-32"><a href="#cb106-32"></a>  info tmpl1 <span class="op">=</span> class_template_of<span class="op">(</span>inst1<span class="op">)</span>;</span>
<span id="cb106-33"><a href="#cb106-33"></a>  info tmpl2 <span class="op">=</span> class_template_of<span class="op">(</span>inst2<span class="op">)</span>;</span>
<span id="cb106-34"><a href="#cb106-34"></a>  <span class="cf">if</span> <span class="op">(</span>is_invalid<span class="op">(</span>tmpl2<span class="op">))</span> <span class="cf">return</span> tmpl2;</span>
<span id="cb106-35"><a href="#cb106-35"></a>  <span class="kw">auto</span> args1 <span class="op">=</span> template_type_arguments_of<span class="op">(</span>inst1<span class="op">)</span>;</span>
<span id="cb106-36"><a href="#cb106-36"></a>  <span class="cf">if</span> <span class="op">(</span>args1<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">1</span> <span class="op">&amp;&amp;</span> is_invalid<span class="op">(</span>args1<span class="op">[</span><span class="dv">0</span><span class="op">]))</span> <span class="cf">return</span> args1;</span>
<span id="cb106-37"><a href="#cb106-37"></a>  <span class="kw">auto</span> args2 <span class="op">=</span> template_type_arguments_of<span class="op">(</span>inst1<span class="op">)</span>;</span>
<span id="cb106-38"><a href="#cb106-38"></a>  <span class="cf">return</span> substitute<span class="op">(</span>tmpl1, args2<span class="op">)</span>;</span>
<span id="cb106-39"><a href="#cb106-39"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>If needed, <code class="sourceCode cpp">mp_assign</code> could be expressed in terms of <code class="sourceCode cpp">rf_assign</code>:</p>
<blockquote>
<div class="sourceCode" id="cb107"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb107-1"><a href="#cb107-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T1, <span class="kw">typename</span> T2<span class="op">&gt;</span></span>
<span id="cb107-2"><a href="#cb107-2"></a>  <span class="kw">using</span> mp_assign <span class="op">=</span> <span class="kw">typename</span><span class="op">[:</span>rf_assign<span class="op">(^</span>T1, <span class="op">^</span>T2<span class="op">):]</span>;</span></code></pre></div>
</blockquote>
<p>Note that in our implementation of <code class="sourceCode cpp">rf_assign</code>, much of the code is dedicated to implementing the constraints of <code class="sourceCode cpp">mp_assign</code>. However, those constraints exist only because of two TMP limitations:</p>
<ol type="1">
<li>parameter packs cannot model mixed-kind template argument lists, and</li>
<li>template template parameters cannot accept function/variable templates.</li>
</ol>
<p>In the reflection world we can easily lift those constraints, which produces the following simplified-yet-more-powerful implementation of <code class="sourceCode cpp">rf_assign</code>:</p>
<blockquote>
<div class="sourceCode" id="cb108"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb108-1"><a href="#cb108-1"></a><span class="kw">consteval</span> info rf_assign<span class="op">(</span>info inst1, info inst2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb108-2"><a href="#cb108-2"></a>  <span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">::</span>meta;</span>
<span id="cb108-3"><a href="#cb108-3"></a>  <span class="cf">return</span> substitute<span class="op">(</span>template_of<span class="op">(</span>inst1<span class="op">)</span>, template_arguments_of<span class="op">(</span>inst2<span class="op">))</span>;</span>
<span id="cb108-4"><a href="#cb108-4"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<h2 data-number="8.5" id="dealing-more-efficiently-with-parameter-packs"><span class="header-section-number">8.5</span> Dealing more efficiently with parameter packs<a href="#dealing-more-efficiently-with-parameter-packs" class="self-link"></a></h2>
<p>Currently, parameter packs are generally dealt with through recursive template instantiation (i.e., a form of TMP, with all its disadvantages). With the set of features presented here, many interesting applications of packs can be expressed more directly and using fewer compilation resources. Here is a simple example:</p>
<blockquote>
<div class="sourceCode" id="cb109"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb109-1"><a href="#cb109-1"></a><span class="pp">#include </span><span class="im">&lt;meta&gt;</span></span>
<span id="cb109-2"><a href="#cb109-2"></a><span class="co">// Function taking an arbitrary number of arguments and returning a vector containing copies of the</span></span>
<span id="cb109-3"><a href="#cb109-3"></a><span class="co">// arguments that have the given type T.</span></span>
<span id="cb109-4"><a href="#cb109-4"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T, <span class="kw">typename</span> <span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb109-5"><a href="#cb109-5"></a>std<span class="op">::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> select_values_of_type<span class="op">(</span>Ts <span class="op">...</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb109-6"><a href="#cb109-6"></a>  std<span class="op">::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> result<span class="op">{}</span>;</span>
<span id="cb109-7"><a href="#cb109-7"></a>  <span class="kw">template</span> <span class="cf">for</span> <span class="op">(</span><span class="kw">constexpr</span> <span class="kw">auto</span> param<span class="op">:</span> parameters_of<span class="op">(</span>current_function<span class="op">()))</span> <span class="op">{</span></span>
<span id="cb109-8"><a href="#cb109-8"></a>    <span class="cf">if</span> <span class="op">(^</span>T <span class="op">==</span> type_of<span class="op">(</span>param<span class="op">))</span> <span class="op">{</span></span>
<span id="cb109-9"><a href="#cb109-9"></a>      result<span class="op">.</span>push_back<span class="op">([:</span>params<span class="op">[</span>i<span class="op">]:])</span>;</span>
<span id="cb109-10"><a href="#cb109-10"></a>    <span class="op">}</span></span>
<span id="cb109-11"><a href="#cb109-11"></a>  <span class="op">}</span></span>
<span id="cb109-12"><a href="#cb109-12"></a>  <span class="cf">return</span> result;</span>
<span id="cb109-13"><a href="#cb109-13"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<h2 data-number="8.6" id="applying-functions-to-all-members"><span class="header-section-number">8.6</span> Applying functions to all members<a href="#applying-functions-to-all-members" class="self-link"></a></h2>
<p><span class="citation" data-cites="P0949R0">[<a href="#ref-P0949R0" role="doc-biblioref">P0949R0</a>]</span> presents a TMP metafunction <code class="sourceCode cpp">get_all_data_members</code> aimed at collecting reflection information for all the data members of a class (not just the direct ones) using the facilities of the first reflection TS (<span class="citation" data-cites="N4818">[<a href="#ref-N4818" role="doc-biblioref">N4818</a>]</span>).</p>
<p>Unfortunately, <code class="sourceCode cpp">get_all_data_members</code> as presented in <span class="citation" data-cites="P0949R0">[<a href="#ref-P0949R0" role="doc-biblioref">P0949R0</a>]</span> has a number of problems:</p>
<ul>
<li>It doesn’t correctly use the TMP-based reflection API to access base classes (it looks like it treats a base class as a base class <em>type</em>). Fixing that is nontrivial.</li>
<li>Its logic ignores virtual bases.</li>
<li>The TMP-based reflection API doesn’t deal well with bit fields (it relies on pointer-to-member constants, which cannot point to bit fields).</li>
</ul>
<p>To address those shortcomings, we present a different interface with similar capabilities:</p>
<blockquote>
<div class="sourceCode" id="cb110"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb110-1"><a href="#cb110-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T, <span class="kw">typename</span> F<span class="op">&gt;</span></span>
<span id="cb110-2"><a href="#cb110-2"></a><span class="dt">void</span> apply_to_all_data_members<span class="op">(</span>T <span class="op">&amp;&amp;</span>r_obj, F <span class="op">&amp;&amp;</span>f<span class="op">)</span>;</span>
<span id="cb110-3"><a href="#cb110-3"></a>  <span class="co">// Invoke f(r_obj.x) for every accessible data member of r_obj, including</span></span>
<span id="cb110-4"><a href="#cb110-4"></a>  <span class="co">// those in base classes (and possibly hidden by more-derived member declarations).</span></span></code></pre></div>
</blockquote>
<p>With the facilities we have proposed in this paper, this can be implemented as follows.</p>
<blockquote>
<div class="sourceCode" id="cb111"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb111-1"><a href="#cb111-1"></a><span class="pp">#include </span><span class="im">&lt;meta&gt;</span></span>
<span id="cb111-2"><a href="#cb111-2"></a><span class="kw">using</span> std<span class="op">::</span>meta<span class="op">::</span>info;</span>
<span id="cb111-3"><a href="#cb111-3"></a></span>
<span id="cb111-4"><a href="#cb111-4"></a><span class="co">// Convenience function to retrieve accessible nonstatic data members of a given class:</span></span>
<span id="cb111-5"><a href="#cb111-5"></a><span class="kw">consteval</span> <span class="kw">auto</span> get_members<span class="op">(</span>info classinfo<span class="op">)</span> <span class="op">{</span></span>
<span id="cb111-6"><a href="#cb111-6"></a>  <span class="cf">return</span> members_of<span class="op">(</span>classinfo, is_nonstatic_data_member, is_accessible<span class="op">)</span>;</span>
<span id="cb111-7"><a href="#cb111-7"></a><span class="op">}</span>;</span>
<span id="cb111-8"><a href="#cb111-8"></a></span>
<span id="cb111-9"><a href="#cb111-9"></a><span class="co">// Convenience function to select nonvirtual bases and members.</span></span>
<span id="cb111-10"><a href="#cb111-10"></a><span class="kw">consteval</span> <span class="kw">auto</span> is_not_virtual<span class="op">(</span>info base_or_mem<span class="op">)</span> <span class="op">{</span></span>
<span id="cb111-11"><a href="#cb111-11"></a>  <span class="cf">return</span> <span class="op">!</span>is_virtual<span class="op">(</span>base_or_mem<span class="op">)</span>;</span>
<span id="cb111-12"><a href="#cb111-12"></a><span class="op">}</span>;</span>
<span id="cb111-13"><a href="#cb111-13"></a></span>
<span id="cb111-14"><a href="#cb111-14"></a><span class="co">// Utility to get the reflection information for the types of base classes (rather than the base</span></span>
<span id="cb111-15"><a href="#cb111-15"></a><span class="co">// classes themselves) of a given class.</span></span>
<span id="cb111-16"><a href="#cb111-16"></a><span class="kw">consteval</span> <span class="kw">auto</span> get_base_types<span class="op">(</span>info classtype, <span class="dt">bool</span> virtual_bases<span class="op">)</span> <span class="op">{</span></span>
<span id="cb111-17"><a href="#cb111-17"></a>  <span class="kw">auto</span> result <span class="op">=</span> bases_of<span class="op">(</span>classtype, is_accessible, virtual_bases <span class="op">?</span> is_virtual <span class="op">:</span> is_not_virtual<span class="op">)</span>;</span>
<span id="cb111-18"><a href="#cb111-18"></a>  <span class="co">// Replace each base reflection by the reflection of its type.</span></span>
<span id="cb111-19"><a href="#cb111-19"></a>  <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="op">&amp;</span>info <span class="op">:</span> result<span class="op">)</span> <span class="op">{</span></span>
<span id="cb111-20"><a href="#cb111-20"></a>    info <span class="op">=</span> type_of<span class="op">(</span>info<span class="op">)</span>;</span>
<span id="cb111-21"><a href="#cb111-21"></a>  <span class="op">}</span></span>
<span id="cb111-22"><a href="#cb111-22"></a>  <span class="cf">return</span> result;</span>
<span id="cb111-23"><a href="#cb111-23"></a><span class="op">}</span>;</span>
<span id="cb111-24"><a href="#cb111-24"></a></span>
<span id="cb111-25"><a href="#cb111-25"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T, <span class="kw">typename</span> F<span class="op">&gt;</span></span>
<span id="cb111-26"><a href="#cb111-26"></a><span class="dt">void</span> apply_to_data_members<span class="op">(</span>T <span class="op">*</span>p_obj, F <span class="op">&amp;</span>f<span class="op">)</span> <span class="op">{</span></span>
<span id="cb111-27"><a href="#cb111-27"></a>  <span class="kw">template</span> <span class="cf">for</span> <span class="op">(</span><span class="kw">constexpr</span> <span class="kw">auto</span> member <span class="op">:</span> get_members<span class="op">(^</span>T<span class="op">))</span> <span class="op">{</span></span>
<span id="cb111-28"><a href="#cb111-28"></a>    f<span class="op">(</span>p_obj<span class="op">-&gt;[:</span>member<span class="op">:])</span>;</span>
<span id="cb111-29"><a href="#cb111-29"></a>  <span class="op">}</span></span>
<span id="cb111-30"><a href="#cb111-30"></a><span class="op">}</span></span>
<span id="cb111-31"><a href="#cb111-31"></a></span>
<span id="cb111-32"><a href="#cb111-32"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T, <span class="kw">typename</span> F<span class="op">&gt;</span></span>
<span id="cb111-33"><a href="#cb111-33"></a><span class="dt">void</span> apply_to_base_data_members<span class="op">(</span>T <span class="op">*</span>p_obj, F <span class="op">&amp;</span>f, <span class="dt">bool</span> virtual_bases, <span class="dt">bool</span> skip_direct_members<span class="op">)</span> <span class="op">{</span></span>
<span id="cb111-34"><a href="#cb111-34"></a>  <span class="co">// Recursively traverse (depth-first) either the nonvirtual or virtual base classes (depending</span></span>
<span id="cb111-35"><a href="#cb111-35"></a>  <span class="co">// on the virtual_bases flag). We do this by collecting the base class types and casting</span></span>
<span id="cb111-36"><a href="#cb111-36"></a>  <span class="co">// the pointer one level up.</span></span>
<span id="cb111-37"><a href="#cb111-37"></a>  <span class="kw">auto</span> type <span class="op">=</span> <span class="op">^</span>T;</span>
<span id="cb111-38"><a href="#cb111-38"></a>  <span class="kw">template</span> <span class="cf">for</span> <span class="op">(</span><span class="kw">constexpr</span> <span class="kw">auto</span> basetype <span class="op">:</span> get_base_types<span class="op">(</span>type, virtual_bases<span class="op">))</span> <span class="op">{</span></span>
<span id="cb111-39"><a href="#cb111-39"></a>    apply_to_base_data_members<span class="op">&lt;</span>T, F<span class="op">&gt;(</span></span>
<span id="cb111-40"><a href="#cb111-40"></a>      <span class="kw">static_cast</span><span class="op">&lt;</span><span class="kw">typename</span><span class="op">[:</span>basetype<span class="op">:]*&gt;(</span>p_obj<span class="op">)</span>,</span>
<span id="cb111-41"><a href="#cb111-41"></a>      f,</span>
<span id="cb111-42"><a href="#cb111-42"></a>      virtual_bases,</span>
<span id="cb111-43"><a href="#cb111-43"></a>      <span class="co">/*skip_direct_members=*/</span><span class="kw">false</span><span class="op">)</span>;</span>
<span id="cb111-44"><a href="#cb111-44"></a>  <span class="op">}</span></span>
<span id="cb111-45"><a href="#cb111-45"></a></span>
<span id="cb111-46"><a href="#cb111-46"></a>  <span class="cf">if</span> <span class="op">(!</span>skip_direct_members<span class="op">)</span> <span class="op">{</span></span>
<span id="cb111-47"><a href="#cb111-47"></a>    <span class="co">// Now that the base classes have been traversed, handle the data members at this level.</span></span>
<span id="cb111-48"><a href="#cb111-48"></a>    <span class="kw">template</span> <span class="cf">for</span> <span class="op">(</span><span class="kw">constexpr</span> <span class="kw">auto</span> member <span class="op">:</span> get_members<span class="op">(</span>type<span class="op">))</span> <span class="op">{</span></span>
<span id="cb111-49"><a href="#cb111-49"></a>      f<span class="op">(</span>p_obj<span class="op">-&gt;[:</span>member<span class="op">:])</span>;</span>
<span id="cb111-50"><a href="#cb111-50"></a>    <span class="op">}</span></span>
<span id="cb111-51"><a href="#cb111-51"></a>  <span class="op">}</span></span>
<span id="cb111-52"><a href="#cb111-52"></a><span class="op">}</span></span>
<span id="cb111-53"><a href="#cb111-53"></a></span>
<span id="cb111-54"><a href="#cb111-54"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T, <span class="kw">typename</span> F<span class="op">&gt;</span></span>
<span id="cb111-55"><a href="#cb111-55"></a><span class="dt">void</span> apply_to_all_data_members<span class="op">(</span>T <span class="kw">const</span> <span class="op">&amp;&amp;</span>r_obj, F <span class="op">&amp;&amp;</span>f<span class="op">)</span> <span class="op">{</span></span>
<span id="cb111-56"><a href="#cb111-56"></a>  T <span class="kw">const</span> <span class="op">*</span>p_obj <span class="op">=</span> std<span class="op">::</span>addressof<span class="op">(</span>r_obj<span class="op">)</span>;</span>
<span id="cb111-57"><a href="#cb111-57"></a>  apply_to_base_data_members<span class="op">&lt;</span>T, F<span class="op">&gt;(</span>p_obj, f, <span class="co">/*virtual_bases=*/</span><span class="kw">true</span>, <span class="co">/*skip_direct_members=*/</span><span class="kw">true</span><span class="op">)</span>;</span>
<span id="cb111-58"><a href="#cb111-58"></a>  apply_to_base_data_members<span class="op">&lt;</span>T, F<span class="op">&gt;(</span>p_obj, f, <span class="co">/*virtual_bases=*/</span><span class="kw">false</span>, <span class="co">/*skip_direct_members=*/</span><span class="kw">false</span><span class="op">)</span>;</span>
<span id="cb111-59"><a href="#cb111-59"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>This implementation reads like ordinary C++ code. Every invocation instantiates three function templates, independently of how complex type <code class="sourceCode cpp">T</code> is (though the amount of code in each instantiation does depend on T because of the expansion statements).</p>
<p>This implementation still has a weakness, however: The notion of “accessibility” of bases and members is determined from the context of the implementation, not that of the call to <code class="sourceCode cpp">apply_to_all_data_members</code>. (The same limitation is imposed by the first Reflection TS.) We do not at this time propose to resolve that issue but we know of at least two ways to address it:</p>
<ul>
<li>more powerful code injection primitives, or</li>
<li>introduce a reflection for “context”.</li>
</ul>
<p>The second option would be less efficient since that context would have to be passed along as a template argument, which would cause each invocation of <code class="sourceCode cpp">apply_to_all_data_members</code> to have a distinct instantiation.</p>
<p>Alternatively, here is an implementation that doesn’t use expansion statements. Instead, it relies on <em>fold-expressions</em>.</p>
<blockquote>
<div class="sourceCode" id="cb112"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb112-1"><a href="#cb112-1"></a><span class="co">// Convenience function to retrieve accessible nonstatic data members of a given class:</span></span>
<span id="cb112-2"><a href="#cb112-2"></a><span class="kw">consteval</span> <span class="kw">auto</span> get_members<span class="op">(</span>info classinfo<span class="op">)</span> <span class="op">{</span></span>
<span id="cb112-3"><a href="#cb112-3"></a>  <span class="cf">return</span> members_of<span class="op">(</span>classinfo, is_nonstatic_data_member, is_accessible<span class="op">)</span>;</span>
<span id="cb112-4"><a href="#cb112-4"></a><span class="op">}</span>;</span>
<span id="cb112-5"><a href="#cb112-5"></a></span>
<span id="cb112-6"><a href="#cb112-6"></a><span class="co">// Convenience function to select nonvirtual bases and members.</span></span>
<span id="cb112-7"><a href="#cb112-7"></a><span class="kw">consteval</span> <span class="kw">auto</span> is_not_virtual<span class="op">(</span>info base_or_mem<span class="op">)</span> <span class="op">{</span></span>
<span id="cb112-8"><a href="#cb112-8"></a>  <span class="cf">return</span> <span class="op">!</span>is_virtual<span class="op">(</span>base_or_mem<span class="op">)</span>;</span>
<span id="cb112-9"><a href="#cb112-9"></a><span class="op">}</span>;</span>
<span id="cb112-10"><a href="#cb112-10"></a></span>
<span id="cb112-11"><a href="#cb112-11"></a><span class="co">// Utility to get the reflection information for the types of base classes (rather than the base</span></span>
<span id="cb112-12"><a href="#cb112-12"></a><span class="co">// classes themselves) of a given class.</span></span>
<span id="cb112-13"><a href="#cb112-13"></a><span class="kw">consteval</span> <span class="kw">auto</span> get_base_types<span class="op">(</span>info classtype, <span class="dt">bool</span> virtual_bases<span class="op">)</span> <span class="op">{</span></span>
<span id="cb112-14"><a href="#cb112-14"></a>  <span class="kw">auto</span> result <span class="op">=</span> bases_of<span class="op">(</span>classtype, is_accessible, virtual_bases <span class="op">?</span> is_virtual <span class="op">:</span> is_not_virtual<span class="op">)</span>;</span>
<span id="cb112-15"><a href="#cb112-15"></a>  <span class="co">// Replace each base reflection by the reflection of its type.</span></span>
<span id="cb112-16"><a href="#cb112-16"></a>  <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="op">&amp;</span>info <span class="op">:</span> result<span class="op">)</span> <span class="op">{</span></span>
<span id="cb112-17"><a href="#cb112-17"></a>    info <span class="op">=</span> type_of<span class="op">(</span>info<span class="op">)</span>;</span>
<span id="cb112-18"><a href="#cb112-18"></a>  <span class="op">}</span></span>
<span id="cb112-19"><a href="#cb112-19"></a>  <span class="cf">return</span> result;</span>
<span id="cb112-20"><a href="#cb112-20"></a><span class="op">}</span>;</span>
<span id="cb112-21"><a href="#cb112-21"></a></span>
<span id="cb112-22"><a href="#cb112-22"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T, <span class="kw">typename</span> F, std<span class="op">::</span>meta<span class="op">::</span>info <span class="op">...</span> members<span class="op">&gt;</span></span>
<span id="cb112-23"><a href="#cb112-23"></a><span class="dt">void</span> apply_to_data_members<span class="op">(</span>T <span class="op">*</span>p_obj, F <span class="op">&amp;</span>f<span class="op">)</span> <span class="op">{</span></span>
<span id="cb112-24"><a href="#cb112-24"></a>  <span class="op">(</span><span class="dt">void</span><span class="op">)(</span>f<span class="op">(</span>p_obj<span class="op">-&gt;[:</span>members<span class="op">:])</span>, <span class="op">...)</span>; <span class="co">// Fold-expression.</span></span>
<span id="cb112-25"><a href="#cb112-25"></a><span class="op">}</span></span>
<span id="cb112-26"><a href="#cb112-26"></a></span>
<span id="cb112-27"><a href="#cb112-27"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T, <span class="kw">typename</span> F, std<span class="op">::</span>meta<span class="op">::</span>info <span class="op">...</span> classtypes<span class="op">&gt;</span></span>
<span id="cb112-28"><a href="#cb112-28"></a><span class="dt">void</span> apply_to_base_data_members<span class="op">(</span>T <span class="op">*</span>p_obj, F <span class="op">&amp;</span>f, <span class="dt">bool</span> virtual_bases, <span class="dt">bool</span> skip_direct_members<span class="op">)</span> <span class="op">{</span></span>
<span id="cb112-29"><a href="#cb112-29"></a>  <span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">::</span>meta;</span>
<span id="cb112-30"><a href="#cb112-30"></a>  <span class="co">// Use a fold-expression to recurse through given bases if needed.</span></span>
<span id="cb112-31"><a href="#cb112-31"></a>  <span class="op">(</span>apply_to_base_data_members<span class="op">&lt;</span></span>
<span id="cb112-32"><a href="#cb112-32"></a>    T, F, <span class="op">...[:</span>get_base_types<span class="op">(</span>classtypes, virtual_bases<span class="op">):]...</span></span>
<span id="cb112-33"><a href="#cb112-33"></a>    <span class="op">&gt;(</span></span>
<span id="cb112-34"><a href="#cb112-34"></a>      <span class="kw">static_cast</span><span class="op">&lt;</span><span class="kw">typename</span><span class="op">(</span><span class="ex">typeof</span><span class="op">(</span>bases<span class="op">))*&gt;(</span>p_obj<span class="op">)</span>, f,</span>
<span id="cb112-35"><a href="#cb112-35"></a>      virtual_bases,</span>
<span id="cb112-36"><a href="#cb112-36"></a>      <span class="co">/*skip_direct_members=*/</span><span class="kw">false</span><span class="op">)</span>, <span class="op">...)</span>;</span>
<span id="cb112-37"><a href="#cb112-37"></a></span>
<span id="cb112-38"><a href="#cb112-38"></a>  <span class="cf">if</span> <span class="op">(!</span>skip_direct_members<span class="op">)</span> <span class="op">{</span></span>
<span id="cb112-39"><a href="#cb112-39"></a>    <span class="co">// Use another fold-expression to handle the data members of each specified class type.</span></span>
<span id="cb112-40"><a href="#cb112-40"></a>    <span class="op">(</span>apply_to_data_members<span class="op">&lt;</span></span>
<span id="cb112-41"><a href="#cb112-41"></a>      T, F, <span class="op">...[:</span>get_members<span class="op">(</span>classtypes<span class="op">):]...</span></span>
<span id="cb112-42"><a href="#cb112-42"></a>      <span class="op">&gt;(</span>p_obj, f<span class="op">)</span>, <span class="op">...)</span>;</span>
<span id="cb112-43"><a href="#cb112-43"></a>  <span class="op">}</span></span>
<span id="cb112-44"><a href="#cb112-44"></a><span class="op">}</span></span>
<span id="cb112-45"><a href="#cb112-45"></a></span>
<span id="cb112-46"><a href="#cb112-46"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T, <span class="kw">typename</span> F<span class="op">&gt;</span></span>
<span id="cb112-47"><a href="#cb112-47"></a><span class="dt">void</span> apply_to_all_data_members<span class="op">(</span>T <span class="kw">const</span> <span class="op">&amp;&amp;</span>r_obj, F <span class="op">&amp;&amp;</span>f<span class="op">)</span> <span class="op">{</span></span>
<span id="cb112-48"><a href="#cb112-48"></a>  T <span class="kw">const</span> <span class="op">*</span>p_obj <span class="op">=</span> std<span class="op">::</span>addressof<span class="op">(</span>r_obj<span class="op">)</span>;</span>
<span id="cb112-49"><a href="#cb112-49"></a></span>
<span id="cb112-50"><a href="#cb112-50"></a>  apply_to_base_data_members<span class="op">&lt;</span>T, F, <span class="op">^</span>T<span class="op">&gt;(</span>p_obj, f, <span class="co">/*virtual_bases=*/</span><span class="kw">true</span>, <span class="co">/*skip_direct_members=*/</span><span class="kw">true</span><span class="op">)</span>;</span>
<span id="cb112-51"><a href="#cb112-51"></a>  apply_to_base_data_members<span class="op">&lt;</span>T, F, <span class="op">^</span>T<span class="op">&gt;(</span>p_obj, f, <span class="co">/*virtual_bases=*/</span><span class="kw">false</span>, <span class="co">/*skip_direct_members=*/</span><span class="kw">false</span><span class="op">)</span>;</span>
<span id="cb112-52"><a href="#cb112-52"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<p>Clearly this is far less readable than the first version. It also involves more instantiations than the first version, but it is nonetheless more efficient than a pure TMP-based solution.</p>
<h1 data-number="9" style="border-bottom:1px solid #cccccc" id="appendix-meta-library-synopsis"><span class="header-section-number">9</span> Appendix: Meta-library synopsis<a href="#appendix-meta-library-synopsis" class="self-link"></a></h1>
<p>This appendix briefly lists declarations for all the intrinsic meta-functions being worked on in the Lock3 Software implementation. As mentioned, these declarations are eventually meant to be brought into a program by including the standard header <code class="sourceCode cpp"><span class="op">&lt;</span>meta<span class="op">&gt;</span></code>. In its current form the list differs slightly from the discussions in this paper because of implementation realities. We expect to harmonize the two over time.</p>
<p>Parameters to queries are named to represent the subset of <code class="sourceCode cpp">meta<span class="op">::</span>info</code> values accepted by each function:</p>
<ul>
<li><code class="sourceCode cpp">reflection</code> – accepts any value.</li>
<li><code class="sourceCode cpp">invalid</code> – accepts only an invalid reflection.</li>
<li><code class="sourceCode cpp">function</code> – accepts any value that designates a function.</li>
<li><code class="sourceCode cpp">variable</code> – accepts any value that designates a variable.</li>
<li><code class="sourceCode cpp">bitfield</code> – accepts any value that designates a bitfield.</li>
<li><code class="sourceCode cpp">type</code> – accepts any value that designates a type.</li>
<li><code class="sourceCode cpp">xxx_type</code> – accepts any value that designates a type of kind <code class="sourceCode cpp">xxx</code> (e.g., <code class="sourceCode cpp">enum_type</code>)</li>
<li><code class="sourceCode cpp">templ</code> – accepts any value that designates a template.</li>
<li><code class="sourceCode cpp">special</code> – accepts any value that designates a template specialization.</li>
<li><code class="sourceCode cpp">entity</code> – accepts any value that designates an entity.</li>
<li><code class="sourceCode cpp">parameter</code> – accepts any value that designates a function or template parameter.</li>
<li><code class="sourceCode cpp">expression</code> – accepts any value that designates an expression.</li>
<li><code class="sourceCode cpp">argument</code> – accepts any value that designates a function or template argument.</li>
<li><code class="sourceCode cpp">base</code> – accepts any value that designates a base class specifier.</li>
<li><code class="sourceCode cpp">mem</code> – accepts any value that designates a class member.</li>
<li><code class="sourceCode cpp">mem_function</code> – accepts any value that designates a member function.</li>
<li><code class="sourceCode cpp">spec_mem_function</code> – accepts any value that designates a special member function.</li>
<li><code class="sourceCode cpp">base_or_mem</code> – accepts any value that designates a base class specifier or a class member.</li>
</ul>
<p>Some operations are polymorphic and accept combinations. For example, the parameter of <code class="sourceCode cpp">is_public</code> is <code class="sourceCode cpp">base_or_mem</code>. Operations accepting sequences are pluralized (e.g., <code class="sourceCode cpp">reflections</code>), meaning that the restriction applies to all elements of the sequence. Also, note that a function accepting a <code class="sourceCode cpp">declarator</code> will accept a function, variable, or bitfield.</p>
<p>Although all the declarations are being considered and worked on, some are not implemented or not tested. The list below highlights those declarations as follows:</p>
<table>
<tr>
<th colspan="2">
Highlights for interfaces still requiring work
</th>
</tr>
<tr>
<td>
<span style="background-color:red">Red</span>
</td>
<td>
Not implemented, because of not-yet-resolved limitations
</td>
</tr>
<tr>
<td>
<span style="background-color:orange">Orange</span>
</td>
<td>
Not implemented, because of fixable limitations
</td>
</tr>
<tr>
<td>
<span style="background-color:yellow">Yellow</span>
</td>
<td>
Not <em>yet</em> implemented
</td>
</tr>
<tr>
<td>
<span class="addu">Green</span>
</td>
<td>
Implemented, but not tested
</td>
</tr>
</table>
<p>The synopsis of <code class="sourceCode cpp"><span class="op">&lt;</span>experimental<span class="op">/</span>meta<span class="op">&gt;</span></code> header is:</p>
<style>
  span.orange { background-color: orange }
  span.red { background-color: red }
  span.yellow { background-color: yellow }
</style>
<blockquote>
<div class="sourceCode" id="cb113"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb113-1"><a href="#cb113-1"></a><span class="kw">namespace</span> std<span class="op">::</span>meta <span class="op">{</span></span>
<span id="cb113-2"><a href="#cb113-2"></a>  <span class="co">// Reflection type</span></span>
<span id="cb113-3"><a href="#cb113-3"></a>  <span class="kw">using</span> info <span class="op">=</span> <span class="kw">decltype</span><span class="op">(^</span><span class="dt">void</span><span class="op">)</span>;</span>
<span id="cb113-4"><a href="#cb113-4"></a></span>
<span id="cb113-5"><a href="#cb113-5"></a>  <span class="co">// Classification</span></span>
<span id="cb113-6"><a href="#cb113-6"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_invalid<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-7"><a href="#cb113-7"></a></span>
<span id="cb113-8"><a href="#cb113-8"></a>  <span class="co">// Scope</span></span>
<span id="cb113-9"><a href="#cb113-9"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_local<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-10"><a href="#cb113-10"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_class_member<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-11"><a href="#cb113-11"></a></span>
<span id="cb113-12"><a href="#cb113-12"></a>  <span class="co">// Variables</span></span>
<span id="cb113-13"><a href="#cb113-13"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_variable<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-14"><a href="#cb113-14"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_static_storage_duration<span class="op">(</span>info variable<span class="op">)</span>;</span>
<span id="cb113-15"><a href="#cb113-15"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_thread_local_storage_duration<span class="op">(</span>info variable<span class="op">)</span>;</span>
<span id="cb113-16"><a href="#cb113-16"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_automatic_storage_duration<span class="op">(</span>info variable<span class="op">)</span>;</span>
<span id="cb113-17"><a href="#cb113-17"></a></span>
<span id="cb113-18"><a href="#cb113-18"></a>  <span class="co">// Functions</span></span>
<span id="cb113-19"><a href="#cb113-19"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_function<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-20"><a href="#cb113-20"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_nothrow<span class="op">(</span>info function<span class="op">)</span>;</span>
<span id="cb113-21"><a href="#cb113-21"></a>  <span class="orange">consteval bool has_ellipsis(info function);</span></span>
<span id="cb113-22"><a href="#cb113-22"></a></span>
<span id="cb113-23"><a href="#cb113-23"></a>  <span class="red">// Classes</span></span>
<span id="cb113-24"><a href="#cb113-24"></a>  <span class="red">template&lt;typename …Args&gt;</span></span>
<span id="cb113-25"><a href="#cb113-25"></a>  <span class="red">consteval std::span<info> members_of(info class_type, Args …filters);</span></span>
<span id="cb113-26"><a href="#cb113-26"></a>  <span class="red">template&lt;typename …Args&gt;</span></span>
<span id="cb113-27"><a href="#cb113-27"></a>  <span class="red">consteval std::span<info> bases_of(info class_type, Args …filters);</span></span>
<span id="cb113-28"><a href="#cb113-28"></a></span>
<span id="cb113-29"><a href="#cb113-29"></a>  <span class="co">// Classes</span></span>
<span id="cb113-30"><a href="#cb113-30"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_class<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-31"><a href="#cb113-31"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_union<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-32"><a href="#cb113-32"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_virtual_destructor<span class="op">(</span>info class_type<span class="op">)</span>;</span>
<span id="cb113-33"><a href="#cb113-33"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_declared_class<span class="op">(</span>info class_type<span class="op">)</span>;</span>
<span id="cb113-34"><a href="#cb113-34"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_declared_struct<span class="op">(</span>info class_type<span class="op">)</span>;</span>
<span id="cb113-35"><a href="#cb113-35"></a></span>
<span id="cb113-36"><a href="#cb113-36"></a>  <span class="co">// Data Members</span></span>
<span id="cb113-37"><a href="#cb113-37"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_data_member<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-38"><a href="#cb113-38"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_static_data_member<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-39"><a href="#cb113-39"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_nonstatic_data_member<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-40"><a href="#cb113-40"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_bit_field<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-41"><a href="#cb113-41"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_mutable<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-42"><a href="#cb113-42"></a></span>
<span id="cb113-43"><a href="#cb113-43"></a>  <span class="co">// Member Functions</span></span>
<span id="cb113-44"><a href="#cb113-44"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_member_function<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-45"><a href="#cb113-45"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_static_member_function<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-46"><a href="#cb113-46"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_nonstatic_member_function<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-47"><a href="#cb113-47"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_normal<span class="op">(</span>info mem_function<span class="op">)</span>;</span>
<span id="cb113-48"><a href="#cb113-48"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_conversion<span class="op">(</span>info mem_function<span class="op">)</span>;</span>
<span id="cb113-49"><a href="#cb113-49"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_override<span class="op">(</span>info mem_function<span class="op">)</span>;</span>
<span id="cb113-50"><a href="#cb113-50"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_override_specified<span class="op">(</span>info mem_function<span class="op">)</span>;</span>
<span id="cb113-51"><a href="#cb113-51"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_deleted<span class="op">(</span>info mem_function<span class="op">)</span>;</span>
<span id="cb113-52"><a href="#cb113-52"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_virtual<span class="op">(</span>info mem_function<span class="op">)</span>;</span>
<span id="cb113-53"><a href="#cb113-53"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_pure_virtual<span class="op">(</span>info mem_function<span class="op">)</span>;</span>
<span id="cb113-54"><a href="#cb113-54"></a></span>
<span id="cb113-55"><a href="#cb113-55"></a>  <span class="co">// Special Member Functions</span></span>
<span id="cb113-56"><a href="#cb113-56"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_constructor<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-57"><a href="#cb113-57"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_default_constructor<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-58"><a href="#cb113-58"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_copy_constructor<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-59"><a href="#cb113-59"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_move_constructor<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-60"><a href="#cb113-60"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_copy_assignment_operator<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-61"><a href="#cb113-61"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_move_assignment_operator<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-62"><a href="#cb113-62"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_copy<span class="op">(</span>info mem_function<span class="op">)</span>;</span>
<span id="cb113-63"><a href="#cb113-63"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_move<span class="op">(</span>info mem_function<span class="op">)</span>;</span>
<span id="cb113-64"><a href="#cb113-64"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_destructor<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-65"><a href="#cb113-65"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_defaulted<span class="op">(</span>info spec_mem_function<span class="op">)</span>;</span>
<span id="cb113-66"><a href="#cb113-66"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_explicit<span class="op">(</span>info spec_mem_function<span class="op">)</span>;</span>
<span id="cb113-67"><a href="#cb113-67"></a></span>
<span id="cb113-68"><a href="#cb113-68"></a>  <span class="co">// Access</span></span>
<span id="cb113-69"><a href="#cb113-69"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_access<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-70"><a href="#cb113-70"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_public<span class="op">(</span>info base_or_mem<span class="op">)</span>;</span>
<span id="cb113-71"><a href="#cb113-71"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_protected<span class="op">(</span>info base_or_mem<span class="op">)</span>;</span>
<span id="cb113-72"><a href="#cb113-72"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_private<span class="op">(</span>info base_or_mem<span class="op">)</span>;</span>
<span id="cb113-73"><a href="#cb113-73"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_default_access<span class="op">(</span>info base_or_mem<span class="op">)</span>;</span>
<span id="cb113-74"><a href="#cb113-74"></a></span>
<span id="cb113-75"><a href="#cb113-75"></a>  <span class="co">// Linkage</span></span>
<span id="cb113-76"><a href="#cb113-76"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_linkage<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-77"><a href="#cb113-77"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_externally_linked<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-78"><a href="#cb113-78"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_internally_linked<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-79"><a href="#cb113-79"></a></span>
<span id="cb113-80"><a href="#cb113-80"></a>  <span class="co">// General purpose</span></span>
<span id="cb113-81"><a href="#cb113-81"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_extern_specified<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-82"><a href="#cb113-82"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_inline<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-83"><a href="#cb113-83"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_inline_specified<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-84"><a href="#cb113-84"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_constexpr<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-85"><a href="#cb113-85"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_consteval<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-86"><a href="#cb113-86"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_final<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-87"><a href="#cb113-87"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_defined<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-88"><a href="#cb113-88"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_complete<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-89"><a href="#cb113-89"></a></span>
<span id="cb113-90"><a href="#cb113-90"></a>  <span class="co">// Namespaces</span></span>
<span id="cb113-91"><a href="#cb113-91"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_namespace<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-92"><a href="#cb113-92"></a></span>
<span id="cb113-93"><a href="#cb113-93"></a>  <span class="addu">// Aliases</span></span>
<span id="cb113-94"><a href="#cb113-94"></a>  <span class="addu">consteval bool is_alias(info reflection);</span></span>
<span id="cb113-95"><a href="#cb113-95"></a>  <span class="addu">consteval bool is_namespace_alias(info reflection);</span></span>
<span id="cb113-96"><a href="#cb113-96"></a>  <span class="addu">consteval bool is_type_alias(info reflection);</span></span>
<span id="cb113-97"><a href="#cb113-97"></a>  <span class="addu">consteval bool is_alias_template(info reflection);</span></span>
<span id="cb113-98"><a href="#cb113-98"></a></span>
<span id="cb113-99"><a href="#cb113-99"></a>  <span class="co">// Enums</span></span>
<span id="cb113-100"><a href="#cb113-100"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_enum<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-101"><a href="#cb113-101"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_unscoped_enum<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-102"><a href="#cb113-102"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_scoped_enum<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-103"><a href="#cb113-103"></a>  <span class="red">consteval std::span<info> enumerators_of(info enum_type);</span></span>
<span id="cb113-104"><a href="#cb113-104"></a></span>
<span id="cb113-105"><a href="#cb113-105"></a>  <span class="co">// Enumerator</span></span>
<span id="cb113-106"><a href="#cb113-106"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_enumerator<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-107"><a href="#cb113-107"></a></span>
<span id="cb113-108"><a href="#cb113-108"></a>  <span class="co">// Templates</span></span>
<span id="cb113-109"><a href="#cb113-109"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_template<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-110"><a href="#cb113-110"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_class_template<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-111"><a href="#cb113-111"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_function_template<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-112"><a href="#cb113-112"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_variable_template<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-113"><a href="#cb113-113"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_member_function_template<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-114"><a href="#cb113-114"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_static_member_function_template<span class="op">(</span>reflection<span class="op">)</span>;</span>
<span id="cb113-115"><a href="#cb113-115"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_nonstatic_member_function_template<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-116"><a href="#cb113-116"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_constructor_template<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-117"><a href="#cb113-117"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_destructor_template<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-118"><a href="#cb113-118"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_concept<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-119"><a href="#cb113-119"></a></span>
<span id="cb113-120"><a href="#cb113-120"></a>  <span class="co">// Specializations</span></span>
<span id="cb113-121"><a href="#cb113-121"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_specialization<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-122"><a href="#cb113-122"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_partial_specialization<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-123"><a href="#cb113-123"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_explicit_specialization<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-124"><a href="#cb113-124"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_implicit_instantiation<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-125"><a href="#cb113-125"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_explicit_instantiation<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-126"><a href="#cb113-126"></a>  <span class="orange">consteval info template_of(info special);</span></span>
<span id="cb113-127"><a href="#cb113-127"></a>  <span class="orange">consteval bool has_template_arguments(info reflection);</span></span>
<span id="cb113-128"><a href="#cb113-128"></a>  <span class="orange">consteval std::span<info> template_arguments_of(info special);</span></span>
<span id="cb113-129"><a href="#cb113-129"></a>  <span class="orange">consteval info substitute(info templ, std::span<info> args);</span></span>
<span id="cb113-130"><a href="#cb113-130"></a></span>
<span id="cb113-131"><a href="#cb113-131"></a>  <span class="addu">// Base classes</span></span>
<span id="cb113-132"><a href="#cb113-132"></a>  <span class="addu">consteval bool is_base_class(info reflection);</span></span>
<span id="cb113-133"><a href="#cb113-133"></a>  <span class="addu">consteval bool is_direct_base_class(info reflection);</span></span>
<span id="cb113-134"><a href="#cb113-134"></a>  <span class="addu">consteval bool is_virtual_base_class(info reflection);</span></span>
<span id="cb113-135"><a href="#cb113-135"></a></span>
<span id="cb113-136"><a href="#cb113-136"></a>  <span class="co">// Parameters</span></span>
<span id="cb113-137"><a href="#cb113-137"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_function_parameter<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-138"><a href="#cb113-138"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_template_parameter<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-139"><a href="#cb113-139"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_type_template_parameter<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-140"><a href="#cb113-140"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_nontype_template_parameter<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-141"><a href="#cb113-141"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_template_template_parameter<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-142"><a href="#cb113-142"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_default_argument<span class="op">(</span>info parameter<span class="op">)</span>;</span>
<span id="cb113-143"><a href="#cb113-143"></a>  <span class="red">consteval std::span<info> parameters_of(info function_or_templ);</span></span>
<span id="cb113-144"><a href="#cb113-144"></a></span>
<span id="cb113-145"><a href="#cb113-145"></a>  <span class="co">// Types</span></span>
<span id="cb113-146"><a href="#cb113-146"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-147"><a href="#cb113-147"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_fundamental_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-148"><a href="#cb113-148"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_fundamental_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-149"><a href="#cb113-149"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_arithmetic_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-150"><a href="#cb113-150"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_arithmetic_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-151"><a href="#cb113-151"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_scalar_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-152"><a href="#cb113-152"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_scalar_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-153"><a href="#cb113-153"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_object_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-154"><a href="#cb113-154"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_object_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-155"><a href="#cb113-155"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_compound_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-156"><a href="#cb113-156"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_compound_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-157"><a href="#cb113-157"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_function_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-158"><a href="#cb113-158"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_function_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-159"><a href="#cb113-159"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_class_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-160"><a href="#cb113-160"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_class_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-161"><a href="#cb113-161"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_union_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-162"><a href="#cb113-162"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_union_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-163"><a href="#cb113-163"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_enum_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-164"><a href="#cb113-164"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_enum_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-165"><a href="#cb113-165"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_unscoped_enum_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-166"><a href="#cb113-166"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_unscoped_enum_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-167"><a href="#cb113-167"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_scoped_enum_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-168"><a href="#cb113-168"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_scoped_enum_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-169"><a href="#cb113-169"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_void_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-170"><a href="#cb113-170"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_void_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-171"><a href="#cb113-171"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_null_pointer_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-172"><a href="#cb113-172"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_null_pointer_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-173"><a href="#cb113-173"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_integral_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-174"><a href="#cb113-174"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_integral_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-175"><a href="#cb113-175"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_floating_point_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-176"><a href="#cb113-176"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_floating_point_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-177"><a href="#cb113-177"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_array_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-178"><a href="#cb113-178"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_array_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-179"><a href="#cb113-179"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_pointer_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-180"><a href="#cb113-180"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_pointer_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-181"><a href="#cb113-181"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_reference_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-182"><a href="#cb113-182"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_reference_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-183"><a href="#cb113-183"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_lvalue_reference_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-184"><a href="#cb113-184"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_lvalue_reference_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-185"><a href="#cb113-185"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_rvalue_reference_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-186"><a href="#cb113-186"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_rvalue_reference_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-187"><a href="#cb113-187"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_member_pointer_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-188"><a href="#cb113-188"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_member_pointer_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-189"><a href="#cb113-189"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_member_object_pointer_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-190"><a href="#cb113-190"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_member_object_pointer_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-191"><a href="#cb113-191"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_member_function_pointer_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-192"><a href="#cb113-192"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_member_function_pointer_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-193"><a href="#cb113-193"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_closure_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-194"><a href="#cb113-194"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_closure_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-195"><a href="#cb113-195"></a></span>
<span id="cb113-196"><a href="#cb113-196"></a>  <span class="co">// Type properties</span></span>
<span id="cb113-197"><a href="#cb113-197"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_incomplete_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-198"><a href="#cb113-198"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_incomplete_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-199"><a href="#cb113-199"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_const_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-200"><a href="#cb113-200"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_const_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-201"><a href="#cb113-201"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_volatile_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-202"><a href="#cb113-202"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_volatile_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-203"><a href="#cb113-203"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_trivial_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-204"><a href="#cb113-204"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_trivial_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-205"><a href="#cb113-205"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_trivially_copyable_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-206"><a href="#cb113-206"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_trivially_copyable_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-207"><a href="#cb113-207"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_standard_layout_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-208"><a href="#cb113-208"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_standard_layout_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-209"><a href="#cb113-209"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_pod_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-210"><a href="#cb113-210"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_pod_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-211"><a href="#cb113-211"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_literal_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-212"><a href="#cb113-212"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_literal_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-213"><a href="#cb113-213"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_empty_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-214"><a href="#cb113-214"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_empty_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-215"><a href="#cb113-215"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_polymorphic_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-216"><a href="#cb113-216"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_polymorphic_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-217"><a href="#cb113-217"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_abstract_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-218"><a href="#cb113-218"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_abstract_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-219"><a href="#cb113-219"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_final_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-220"><a href="#cb113-220"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_final_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-221"><a href="#cb113-221"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_aggregate_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-222"><a href="#cb113-222"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_aggregate_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-223"><a href="#cb113-223"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_signed_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-224"><a href="#cb113-224"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_signed_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-225"><a href="#cb113-225"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_unsigned_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-226"><a href="#cb113-226"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_unsigned_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-227"><a href="#cb113-227"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_unique_object_representations<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-228"><a href="#cb113-228"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_type_with_unique_object_representations<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-229"><a href="#cb113-229"></a>  <span class="orange">consteval std::size_t size_of(info reflection);</span></span>
<span id="cb113-230"><a href="#cb113-230"></a>  <span class="orange">consteval std::size_t byte_size_of(info reflection);</span></span>
<span id="cb113-231"><a href="#cb113-231"></a>  <span class="orange">consteval std::size_t bit_size_of(info reflection);</span></span>
<span id="cb113-232"><a href="#cb113-232"></a>  <span class="orange">consteval std::size_t byte_offset_of(info reflection);</span></span>
<span id="cb113-233"><a href="#cb113-233"></a>  <span class="orange">consteval std::size_t bit_offset_of(info reflection);</span></span>
<span id="cb113-234"><a href="#cb113-234"></a>  <span class="orange">consteval std::size_t alignment_of(info reflection);</span></span>
<span id="cb113-235"><a href="#cb113-235"></a>  <span class="orange">consteval std::size_t rank(info reflection);</span></span>
<span id="cb113-236"><a href="#cb113-236"></a>  <span class="orange">consteval std::size_t extent(info reflection);</span></span>
<span id="cb113-237"><a href="#cb113-237"></a></span>
<span id="cb113-238"><a href="#cb113-238"></a>  <span class="co">// Type operations</span></span>
<span id="cb113-239"><a href="#cb113-239"></a>  <span class="red">consteval bool is_constructible(info reflection, std::span<info> arguments);</span></span>
<span id="cb113-240"><a href="#cb113-240"></a>  <span class="red">consteval bool is_trivially_constructible(info reflection, std:span<info> arguments);</span></span>
<span id="cb113-241"><a href="#cb113-241"></a>  <span class="red">consteval bool is_nothrow_constructible(info reflection, std::span<info> arguments);</span></span>
<span id="cb113-242"><a href="#cb113-242"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_default_constructible_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-243"><a href="#cb113-243"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_default_constructible_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-244"><a href="#cb113-244"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_trivially_default_constructible_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-245"><a href="#cb113-245"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_trivially_default_constructible_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-246"><a href="#cb113-246"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_nothrow_default_constructible_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-247"><a href="#cb113-247"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_nothrow_default_constructible_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-248"><a href="#cb113-248"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_copy_constructible_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-249"><a href="#cb113-249"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_copy_constructible_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-250"><a href="#cb113-250"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_trivially_copy_constructible_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-251"><a href="#cb113-251"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_trivially_copy_constructible_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-252"><a href="#cb113-252"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_nothrow_copy_constructible_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-253"><a href="#cb113-253"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_nothrow_copy_constructible_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-254"><a href="#cb113-254"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_move_constructible_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-255"><a href="#cb113-255"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_move_constructible_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-256"><a href="#cb113-256"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_trivially_move_constructible_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-257"><a href="#cb113-257"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_trivially_move_constructible_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-258"><a href="#cb113-258"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_nothrow_move_constructible_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-259"><a href="#cb113-259"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_nothrow_move_constructible_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-260"><a href="#cb113-260"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_assignable_type<span class="op">(</span>info type,info assigned_type<span class="op">)</span>;</span>
<span id="cb113-261"><a href="#cb113-261"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_trivially_assignable_type<span class="op">(</span>info type,info assigned_type<span class="op">)</span>;</span>
<span id="cb113-262"><a href="#cb113-262"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_nothrow_assignable_type<span class="op">(</span>info type,info assigned_type<span class="op">)</span>;</span>
<span id="cb113-263"><a href="#cb113-263"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_copy_assignable_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-264"><a href="#cb113-264"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_copy_assignable_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-265"><a href="#cb113-265"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_trivially_copy_assignable_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-266"><a href="#cb113-266"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_trivially_copy_assignable_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-267"><a href="#cb113-267"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_nothrow_copy_assignable_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-268"><a href="#cb113-268"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_nothrow_copy_assignable_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-269"><a href="#cb113-269"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_move_assignable_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-270"><a href="#cb113-270"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_move_assignable_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-271"><a href="#cb113-271"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_trivially_move_assignable_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-272"><a href="#cb113-272"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_trivially_move_assignable_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-273"><a href="#cb113-273"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_nothrow_move_assignable_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-274"><a href="#cb113-274"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_nothrow_move_assignable_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-275"><a href="#cb113-275"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_destructible_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-276"><a href="#cb113-276"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_destructible_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-277"><a href="#cb113-277"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_trivially_destructible_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-278"><a href="#cb113-278"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_trivially_destructible_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-279"><a href="#cb113-279"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_nothrow_destructible_type<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-280"><a href="#cb113-280"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_nothrow_destructible_type<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-281"><a href="#cb113-281"></a>  <span class="yellow">consteval bool is_swappable(info reflection);</span></span>
<span id="cb113-282"><a href="#cb113-282"></a>  <span class="yellow">consteval bool is_nothrow_swappable(info reflection);</span></span>
<span id="cb113-283"><a href="#cb113-283"></a>  <span class="yellow">consteval bool is_swappable_with(info reflection1, info reflection2);</span></span>
<span id="cb113-284"><a href="#cb113-284"></a>  <span class="yellow">consteval bool is_nothrow_swappable_with(info reflection1, info reflection2);</span></span>
<span id="cb113-285"><a href="#cb113-285"></a></span>
<span id="cb113-286"><a href="#cb113-286"></a>  <span class="co">// Captures</span></span>
<span id="cb113-287"><a href="#cb113-287"></a>  <span class="red">consteval std::span<info> captures_of(info reflection);</span></span>
<span id="cb113-288"><a href="#cb113-288"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_default_ref_capture<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-289"><a href="#cb113-289"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_default_copy_capture<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-290"><a href="#cb113-290"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_capture<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-291"><a href="#cb113-291"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_simple_capture<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-292"><a href="#cb113-292"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_ref_capture<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-293"><a href="#cb113-293"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_copy_capture<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-294"><a href="#cb113-294"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_explicit_capture<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-295"><a href="#cb113-295"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_init_capture<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-296"><a href="#cb113-296"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> has_captures<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-297"><a href="#cb113-297"></a></span>
<span id="cb113-298"><a href="#cb113-298"></a>  <span class="co">// Type relations</span></span>
<span id="cb113-299"><a href="#cb113-299"></a>  <span class="orange">consteval bool is_same(info reflection1, info reflection2);</span></span>
<span id="cb113-300"><a href="#cb113-300"></a>  <span class="orange">consteval bool is_base_of(info base_type, info derived_type);</span></span>
<span id="cb113-301"><a href="#cb113-301"></a>  <span class="orange">consteval bool is_convertible(info from_type, info to_type);</span></span>
<span id="cb113-302"><a href="#cb113-302"></a>  <span class="orange">consteval bool is_nothrow_convertible(info from_type, info to_type);</span></span>
<span id="cb113-303"><a href="#cb113-303"></a></span>
<span id="cb113-304"><a href="#cb113-304"></a>  <span class="co">// Invocation</span></span>
<span id="cb113-305"><a href="#cb113-305"></a>  <span class="red">consteval bool is_invocable(info function, std::span<info> arguments);</span></span>
<span id="cb113-306"><a href="#cb113-306"></a>  <span class="red">consteval bool is_nothrow_invocable(info function, std::span<info> arguments);</span></span>
<span id="cb113-307"><a href="#cb113-307"></a>  <span class="red">consteval bool is_invocable_r(info function, std::span<info> arguments, info result);</span></span>
<span id="cb113-308"><a href="#cb113-308"></a>  <span class="red">consteval bool is_nothrow_invocable_r(info function, std::span<info> arguments, info result);</span></span>
<span id="cb113-309"><a href="#cb113-309"></a></span>
<span id="cb113-310"><a href="#cb113-310"></a>  <span class="co">// Type transformation</span></span>
<span id="cb113-311"><a href="#cb113-311"></a>  <span class="kw">consteval</span> info remove_const<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-312"><a href="#cb113-312"></a>  <span class="kw">consteval</span> info remove_volatile<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-313"><a href="#cb113-313"></a>  <span class="kw">consteval</span> info remove_cv<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-314"><a href="#cb113-314"></a>  <span class="kw">consteval</span> info add_const<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-315"><a href="#cb113-315"></a>  <span class="kw">consteval</span> info add_volatile<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-316"><a href="#cb113-316"></a>  <span class="kw">consteval</span> info add_cv<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-317"><a href="#cb113-317"></a>  <span class="kw">consteval</span> info remove_reference<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-318"><a href="#cb113-318"></a>  <span class="kw">consteval</span> info add_lvalue_reference<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-319"><a href="#cb113-319"></a>  <span class="kw">consteval</span> info add_rvalue_reference<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-320"><a href="#cb113-320"></a>  <span class="kw">consteval</span> info remove_pointer<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-321"><a href="#cb113-321"></a>  <span class="kw">consteval</span> info add_pointer<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-322"><a href="#cb113-322"></a>  <span class="kw">consteval</span> info remove_cvref<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-323"><a href="#cb113-323"></a>  <span class="kw">consteval</span> info decay<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-324"><a href="#cb113-324"></a>  <span class="kw">consteval</span> info make_signed<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-325"><a href="#cb113-325"></a>  <span class="kw">consteval</span> info make_unsigned<span class="op">(</span>info type<span class="op">)</span>;</span>
<span id="cb113-326"><a href="#cb113-326"></a>  <span class="orange">consteval info aligned_storage(std::size_t length, std::size_t align = /* default-alignment */);</span></span>
<span id="cb113-327"><a href="#cb113-327"></a>  <span class="red">consteval info aligned_union(std::size_t length, std::span<info> types);</span></span>
<span id="cb113-328"><a href="#cb113-328"></a>  <span class="orange">consteval info enable_if(bool cond, info type = ^void);</span></span>
<span id="cb113-329"><a href="#cb113-329"></a></span>
<span id="cb113-330"><a href="#cb113-330"></a>  <span class="co">// Associated types</span></span>
<span id="cb113-331"><a href="#cb113-331"></a>  <span class="kw">consteval</span> info this_ref_type_of<span class="op">(</span>info mem_function<span class="op">)</span>;</span>
<span id="cb113-332"><a href="#cb113-332"></a>  <span class="orange">consteval info common_type(std::span<info> types);</span></span>
<span id="cb113-333"><a href="#cb113-333"></a>  <span class="kw">consteval</span> info underlying_type_of<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-334"><a href="#cb113-334"></a>  <span class="red">consteval info invoke_result(info function, std::span<info> arguments);</span></span>
<span id="cb113-335"><a href="#cb113-335"></a>  <span class="kw">consteval</span> info type_of<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-336"><a href="#cb113-336"></a>  <span class="kw">consteval</span> info return_type_of<span class="op">(</span>info function<span class="op">)</span>;</span>
<span id="cb113-337"><a href="#cb113-337"></a></span>
<span id="cb113-338"><a href="#cb113-338"></a>  <span class="co">// Associated reflections</span></span>
<span id="cb113-339"><a href="#cb113-339"></a>  <span class="red">consteval bool is_entity(info reflection);</span></span>
<span id="cb113-340"><a href="#cb113-340"></a>  <span class="kw">consteval</span> info entity_of<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-341"><a href="#cb113-341"></a>  <span class="kw">consteval</span> info parent_of<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-342"><a href="#cb113-342"></a>  <span class="kw">consteval</span> info definition_of<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-343"><a href="#cb113-343"></a></span>
<span id="cb113-344"><a href="#cb113-344"></a>  <span class="co">// Names</span></span>
<span id="cb113-345"><a href="#cb113-345"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_named<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-346"><a href="#cb113-346"></a>  <span class="kw">consteval</span> std<span class="op">::</span>string_view name_of<span class="op">(</span>info named<span class="op">)</span>;</span>
<span id="cb113-347"><a href="#cb113-347"></a>  <span class="red">consteval std::string_view display_name_of(info named);</span></span>
<span id="cb113-348"><a href="#cb113-348"></a></span>
<span id="cb113-349"><a href="#cb113-349"></a>  <span class="co">// Expressions</span></span>
<span id="cb113-350"><a href="#cb113-350"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_lvalue<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-351"><a href="#cb113-351"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_xvalue<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-352"><a href="#cb113-352"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_prvalue<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-353"><a href="#cb113-353"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_glvalue<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-354"><a href="#cb113-354"></a>  <span class="kw">consteval</span> <span class="dt">bool</span> is_rvalue<span class="op">(</span>info reflection<span class="op">)</span>;</span>
<span id="cb113-355"><a href="#cb113-355"></a><span class="op">}</span></span></code></pre></div>
</blockquote>
<h1 data-number="10" style="border-bottom:1px solid #cccccc" id="bibliography"><span class="header-section-number">10</span> References<a href="#bibliography" class="self-link"></a></h1>
<div id="refs" class="references hanging-indent" role="doc-bibliography">
<div id="ref-N3980">
<p>[N3980] H. Hinnant, V. Falco, J. Byteway. 2014-05-24. Types don’t know #. <br />
<a href="https://wg21.link/n3980">https://wg21.link/n3980</a></p>
</div>
<div id="ref-N4766">
<p>[N4766] David Sankel. 2018-08-11. Working Draft, C++ Extensions for Reflection. <br />
<a href="https://wg21.link/n4766">https://wg21.link/n4766</a></p>
</div>
<div id="ref-N4818">
<p>[N4818] David Sankel. 2019-06-17. Working Draft, C++ Extensions for Reflection. <br />
<a href="https://wg21.link/n4818">https://wg21.link/n4818</a></p>
</div>
<div id="ref-N4856">
<p>[N4856] David Sankel. 2020-03-02. C++ Extensions for Reflection. <br />
<a href="https://wg21.link/n4856">https://wg21.link/n4856</a></p>
</div>
<div id="ref-P0385R0">
<p>[P0385R0] Matúš Chochlík, Alex Naumann. 2016-05-30. Static reflection: Rationale, design and evolution. <br />
<a href="https://wg21.link/p0385r0">https://wg21.link/p0385r0</a></p>
</div>
<div id="ref-P0425R0">
<p>[P0425R0] Louis Dionne. 2017-06-18. Metaprogramming by design, not by accident. <br />
<a href="https://wg21.link/p0425r0">https://wg21.link/p0425r0</a></p>
</div>
<div id="ref-P0595R2">
<p>[P0595R2] Richard Smith, Andrew Sutton, Daveed Vandevoorde. 2018-11-09. std::is_constant_evaluated. <br />
<a href="https://wg21.link/p0595r2">https://wg21.link/p0595r2</a></p>
</div>
<div id="ref-P0732R2">
<p>[P0732R2] Jeff Snyder, Louis Dionne. 2018-06-06. Class Types in Non-Type Template Parameters. <br />
<a href="https://wg21.link/p0732r2">https://wg21.link/p0732r2</a></p>
</div>
<div id="ref-P0784R7">
<p>[P0784R7] Daveed Vandevoorde, Peter Dimov,Louis Dionne, Nina Ranns, Richard Smith, Daveed Vandevoorde. 2019-07-22. More constexpr containers. <br />
<a href="https://wg21.link/p0784r7">https://wg21.link/p0784r7</a></p>
</div>
<div id="ref-P0949R0">
<p>[P0949R0] Peter Dimov. 2018-02-11. Adding support for type-based metaprogramming to the standard library. <br />
<a href="https://wg21.link/p0949r0">https://wg21.link/p0949r0</a></p>
</div>
<div id="ref-P0993R0">
<p>[P0993R0] Andrew Sutton, Herb Sutter. 2014-04-02. Value-based Reflection. <br />
<a href="https://wg21.link/p0993r0">https://wg21.link/p0993r0</a></p>
</div>
<div id="ref-P1073R3">
<p>[P1073R3] Richard Smith, Andrew Sutton, Daveed Vandevoorde. 2018-11-06. Immediate functions. <br />
<a href="https://wg21.link/p1073r3">https://wg21.link/p1073r3</a></p>
</div>
<div id="ref-P1240R0">
<p>[P1240R0] Andrew Sutton, Faisal Vali, Daveed Vandevoorde. 2018-10-08. Scalable Reflection in C++. <br />
<a href="https://wg21.link/p1240r0">https://wg21.link/p1240r0</a></p>
</div>
<div id="ref-P1240R1">
<p>[P1240R1] Daveed Vandevoorde, Wyatt Childers, Andrew Sutton, Faisal Vali, Daveed Vandevoorde. 2019-10-08. Scalable Reflection in C++. <br />
<a href="https://wg21.link/p1240r1">https://wg21.link/p1240r1</a></p>
</div>
<div id="ref-P1306R1">
<p>[P1306R1] Andrew Sutton, Sam Goodrick, Daveed Vandevoorde. 2019-01-21. Expansion statements. <br />
<a href="https://wg21.link/p1306r1">https://wg21.link/p1306r1</a></p>
</div>
<div id="ref-P1717R0">
<p>[P1717R0] Andrew Sutton, Wyatt Childers. 2019-06-17. Compile-time Metaprogramming in C++. <br />
<a href="https://wg21.link/p1717r0">https://wg21.link/p1717r0</a></p>
</div>
<div id="ref-P1907R1">
<p>[P1907R1] Jens Maurer. 2019-11-08. Inconsistencies with non-type template parameters. <br />
<a href="https://wg21.link/p1907r1">https://wg21.link/p1907r1</a></p>
</div>
<div id="ref-P2050R0">
<p>[P2050R0] Andrew Sutton, Wyatt Childers. 2020-01-13. Tweaks to the design of source code fragments. <br />
<a href="https://wg21.link/p2050r0">https://wg21.link/p2050r0</a></p>
</div>
<div id="ref-P2237R0">
<p>[P2237R0] Andrew Sutton. 2020-10-15. Metaprogramming. <br />
<a href="https://wg21.link/p2237r0">https://wg21.link/p2237r0</a></p>
</div>
<div id="ref-P2320R0">
<p>[P2320R0] Andrew Sutton, Wyatt Childers, Daveed Vandevoorde. 2021-02-15. The Syntax of Static Reflection. <br />
<a href="https://wg21.link/p2320r0">https://wg21.link/p2320r0</a></p>
</div>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>We used to think that C++/CLI had already appropriated that syntax, but C++/CLI (and related C++ dialects) only uses the caret for handle declarations and not for handle indirections.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Which includes any parenthesized expression.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>This paper does not currently deal with structured bindings because their exact nature in the standard is still somewhat in flux at the time of this writing. Once they’re clarified, we intend to revisit their status as a “declared entity”.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>We could define it via <code class="sourceCode cpp"><span class="kw">using</span> info <span class="op">=</span> <span class="kw">decltype</span><span class="op">(^</span><span class="dt">void</span><span class="op">)</span>;</code><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>We use trailing return types for standard meta functions, but that’s just a stylistic preference. The traditional return type style is just as valid.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>While working with our implementations, we have noticed that it would be very convenient if the lifting operator would be a SFINAE context as well. E.g., instantiating <code class="sourceCode cpp"><span class="op">^</span>T<span class="op">::</span>X</code> would produce an invalid reflection when <code class="sourceCode cpp">T <span class="op">=</span> <span class="dt">int</span></code>. That option is still being considered.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</div>
</div>
</body>
</html>
