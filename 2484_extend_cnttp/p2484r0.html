<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="mpark/wg21" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2021-11-13" />
  <title>Extending support for class types as non-type template parameters</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
      div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
      ul.task-list{list-style: none;}
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode
        {  background-color: #f6f8fa; }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span. { } /* Normal */
      code span.al { color: #ff0000; } /* Alert */
      code span.an { } /* Annotation */
      code span.at { } /* Attribute */
      code span.bn { color: #9f6807; } /* BaseN */
      code span.bu { color: #9f6807; } /* BuiltIn */
      code span.cf { color: #00607c; } /* ControlFlow */
      code span.ch { color: #9f6807; } /* Char */
      code span.cn { } /* Constant */
      code span.co { color: #008000; font-style: italic; } /* Comment */
      code span.cv { color: #008000; font-style: italic; } /* CommentVar */
      code span.do { color: #008000; } /* Documentation */
      code span.dt { color: #00607c; } /* DataType */
      code span.dv { color: #9f6807; } /* DecVal */
      code span.er { color: #ff0000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #9f6807; } /* Float */
      code span.fu { } /* Function */
      code span.im { } /* Import */
      code span.in { color: #008000; } /* Information */
      code span.kw { color: #00607c; } /* Keyword */
      code span.op { color: #af1915; } /* Operator */
      code span.ot { } /* Other */
      code span.pp { color: #6f4e37; } /* Preprocessor */
      code span.re { } /* RegionMarker */
      code span.sc { color: #9f6807; } /* SpecialChar */
      code span.ss { color: #9f6807; } /* SpecialString */
      code span.st { color: #9f6807; } /* String */
      code span.va { } /* Variable */
      code span.vs { color: #9f6807; } /* VerbatimString */
      code span.wa { color: #008000; font-weight: bold; } /* Warning */
      code.diff {color: #898887}
      code.diff span.va {color: #006e28}
      code.diff span.st {color: #bf0303}
  </style>
  <style type="text/css">
body {
margin: 5em;
font-family: serif;

hyphens: auto;
line-height: 1.35;
}
div.wrapper {
max-width: 60em;
margin: auto;
}
ul {
list-style-type: none;
padding-left: 2em;
margin-top: -0.2em;
margin-bottom: -0.2em;
}
a {
text-decoration: none;
color: #4183C4;
}
a.hidden_link {
text-decoration: none;
color: inherit;
}
li {
margin-top: 0.6em;
margin-bottom: 0.6em;
}
h1, h2, h3, h4 {
position: relative;
line-height: 1;
}
a.self-link {
position: absolute;
top: 0;
left: calc(-1 * (3.5rem - 26px));
width: calc(3.5rem - 26px);
height: 2em;
text-align: center;
border: none;
transition: opacity .2s;
opacity: .5;
font-family: sans-serif;
font-weight: normal;
font-size: 83%;
}
a.self-link:hover { opacity: 1; }
a.self-link::before { content: "§"; }
ul > li:before {
content: "\2014";
position: absolute;
margin-left: -1.5em;
}
:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }
.abbr_ref { float: right; }
.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }
:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }
.secnum { display: inline-block; min-width: 35pt; }
.header-section-number { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }
div.sourceLinkParent {
float: right;
}
a.sourceLink {
position: absolute;
opacity: 0;
margin-left: 10pt;
}
a.sourceLink:hover {
opacity: 1;
}
a.itemDeclLink {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
opacity: 0;
}
a.itemDeclLink:hover { opacity: 1; }
span.marginalizedparent {
position: relative;
left: -5em;
}
li span.marginalizedparent { left: -7em; }
li ul > li span.marginalizedparent { left: -9em; }
li ul > li ul > li span.marginalizedparent { left: -11em; }
li ul > li ul > li ul > li span.marginalizedparent { left: -13em; }
div.footnoteNumberParent {
position: relative;
left: -4.7em;
}
a.marginalized {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
}
a.enumerated_item_num {
position: relative;
left: -3.5em;
display: inline-block;
margin-right: -3em;
text-align: right;
width: 3em;
}
div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }
span.indexparent {
display: inline;
position: relative;
float: right;
right: -1em;
}
a.index {
position: absolute;
display: none;
}
a.index:before { content: "⟵"; }

a.index:target {
display: inline;
}
.indexitems {
margin-left: 2em;
text-indent: -2em;
}
div.itemdescr {
margin-left: 3em;
}
.bnf {
font-family: serif;
margin-left: 40pt;
margin-top: 0.5em;
margin-bottom: 0.5em;
}
.ncbnf {
font-family: serif;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
}
.ncsimplebnf {
font-family: serif;
font-style: italic;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
background: inherit; 
}
span.textnormal {
font-style: normal;
font-family: serif;
white-space: normal;
display: inline-block;
}
span.rlap {
display: inline-block;
width: 0px;
}
span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }
span.phantom { color: white; }

span.math { font-style: normal; }
span.mathblock {
display: block;
margin-left: auto;
margin-right: auto;
margin-top: 1.2em;
margin-bottom: 1.2em;
text-align: center;
}
span.mathalpha {
font-style: italic;
}
span.synopsis {
font-weight: bold;
margin-top: 0.5em;
display: block;
}
span.definition {
font-weight: bold;
display: block;
}
.codeblock {
margin-left: 1.2em;
line-height: 127%;
}
.outputblock {
margin-left: 1.2em;
line-height: 127%;
}
div.itemdecl {
margin-top: 2ex;
}
code.itemdeclcode {
white-space: pre;
display: block;
}
span.textsuperscript {
vertical-align: super;
font-size: smaller;
line-height: 0;
}
.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }
.footnote {
font-size: small;
margin-left: 2em;
margin-right: 2em;
margin-top: 0.6em;
margin-bottom: 0.6em;
}
div.minipage {
display: inline-block;
margin-right: 3em;
}
div.numberedTable {
text-align: center;
margin: 2em;
}
div.figure {
text-align: center;
margin: 2em;
}
table {
border: 1px solid black;
border-collapse: collapse;
margin-left: auto;
margin-right: auto;
margin-top: 0.8em;
text-align: left;
hyphens: none; 
}
td, th {
padding-left: 1em;
padding-right: 1em;
vertical-align: top;
}
td.empty {
padding: 0px;
padding-left: 1px;
}
td.left {
text-align: left;
}
td.right {
text-align: right;
}
td.center {
text-align: center;
}
td.justify {
text-align: justify;
}
td.border {
border-left: 1px solid black;
}
tr.rowsep, td.cline {
border-top: 1px solid black;
}
tr.even, tr.odd {
border-bottom: 1px solid black;
}
tr.capsep {
border-top: 3px solid black;
border-top-style: double;
}
tr.header {
border-bottom: 3px solid black;
border-bottom-style: double;
}
th {
border-bottom: 1px solid black;
}
span.centry {
font-weight: bold;
}
div.table {
display: block;
margin-left: auto;
margin-right: auto;
text-align: center;
width: 90%;
}
span.indented {
display: block;
margin-left: 2em;
margin-bottom: 1em;
margin-top: 1em;
}
ol.enumeratea { list-style-type: none; background: inherit; }
ol.enumerate { list-style-type: none; background: inherit; }

code.sourceCode > span { display: inline; }
</style>
  <style type="text/css">a {
color : #4183C4;
text-decoration: underline;
}
a.marginalized {
text-decoration: none;
}
a.self-link {
text-decoration: none;
}
h1#toctitle {
border-bottom: 1px solid #cccccc;
}
#TOC li {
margin-top: 1px;
margin-bottom: 1px;
}
#TOC ul>li:before { display: none; }
h3.subtitle { margin-top: -15px; }
h1:target { background-color: transparent; }
h2:target { background-color: transparent; }
h3:target { background-color: transparent; }
h4:target { background-color: transparent; }
h5:target { background-color: transparent; }
h6:target { background-color: transparent; }
code span.co { font-family: monospace; }
table tr {
background-color: white;
}
table tr:nth-child(2n) {
background-color: #f6f8fa;
}
#title-block-header > table tr:nth-child(2n) {
background-color: white;
}
td > div.sourceCode {
background-color: inherit;
}
table {
border-collapse: collapse;
}
table td, table th {
border: 1px solid #cccccc;
}
table th {
border-bottom: 1px solid black;
text-align: center;
}
table tr:first-child th {
border-top: 0;
}
table tr:last-child td {
border-bottom: 0;
}
table tr td:first-child,
table tr th:first-child {
border-left: 0;
}
table tr td:last-child,
table tr th:last-child {
border-right: 0;
}
table tbody tr:first-child td {
border-top: 1px solid black;
}
#title-block-header td { border: 0; }
@media all {
body {
margin: 2em;
}
}
@media screen and (min-width: 480px) {
body {
margin: 5em;
}
}
#refs code{padding-left: 0px; text-indent: 0px;}
:root {
--diff-ins: #e6ffed;
--diff-strongins: #acf2bd;
--diff-del: #ffdddd;
--diff-strongdel: #ff8888;
}
span.diffins {
background-color: var(--diff-strongins);
}
span.diffdel {
background-color: var(--diff-strongdel);
}
div.rm { text-decoration: line-through; }
div.rm code.sourceCode { text-decoration: line-through; }
div.addu, span.addu {
color: #006e28;
background-color: var(--diff-ins);
}

div.rm pre, div.add pre { background-color: #f6f8fa; }
div.addu pre { background-color: var(--diff-ins); }
div.add, div.add pre { background-color: var(--diff-ins); }
div.addu blockquote {
border-left: 4px solid #00a000;
padding: 0 15px;
color: #006e28;
text-decoration: none;
}
div.addu blockquote code.sourceCode { text-decoration: none; }
div.addu blockquote pre { text-decoration: none; }
div.addu blockquote pre code { text-decoration: none; }
div.quote {
border-left: 7px solid #ccc;
background: #f9f9f9;
margin: 1.5em 10px;
padding-left: 20px;
}
code.diff span.va { color: #000000; background-color: var(--diff-ins); }
code.diff span.st { color: #000000; background-color: var(--diff-del); }
</style>
  <link href="data:image/x-icon;base64,AAABAAIAEBAAAAEAIABoBAAAJgAAACAgAAABACAAqBAAAI4EAAAoAAAAEAAAACAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAVoJEAN6CRADegkQAWIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wCCRAAAgkQAAIJEAACCRAAsgkQAvoJEAP+CRAD/gkQA/4JEAP+CRADAgkQALoJEAACCRAAAgkQAAP///wD///8AgkQAAIJEABSCRACSgkQA/IJEAP99PQD/dzMA/3czAP99PQD/gkQA/4JEAPyCRACUgkQAFIJEAAD///8A////AHw+AFiBQwDqgkQA/4BBAP9/PxP/uZd6/9rJtf/bybX/upd7/39AFP+AQQD/gkQA/4FDAOqAQgBc////AP///wDKklv4jlEa/3o7AP+PWC//8+3o///////////////////////z7un/kFox/35AAP+GRwD/mVYA+v///wD///8A0Zpk+NmibP+0d0T/8evj///////+/fv/1sKz/9bCs//9/fr//////+/m2/+NRwL/nloA/5xYAPj///8A////ANKaZPjRmGH/5cKh////////////k149/3UwAP91MQD/lmQ//86rhv+USg3/m1YA/5hSAP+bVgD4////AP///wDSmmT4zpJY/+/bx///////8+TV/8mLT/+TVx//gkIA/5lVAP+VTAD/x6B//7aEVv/JpH7/s39J+P///wD///8A0ppk+M6SWP/u2sf///////Pj1f/Nj1T/2KFs/8mOUv+eWhD/lEsA/8aee/+0glT/x6F7/7J8Rvj///8A////ANKaZPjRmGH/48Cf///////+/v7/2qt//82PVP/OkFX/37KJ/86siv+USg7/mVQA/5hRAP+bVgD4////AP///wDSmmT40ppk/9CVXP/69O////////7+/v/x4M//8d/P//7+/f//////9u7n/6tnJf+XUgD/nFgA+P///wD///8A0ppk+NKaZP/RmWL/1qNy//r07///////////////////////+vXw/9akdP/Wnmn/y5FY/6JfFvj///8A////ANKaZFTSmmTo0ppk/9GYYv/Ql1//5cWm//Hg0P/x4ND/5cWm/9GXYP/RmGH/0ppk/9KaZOjVnmpY////AP///wDSmmQA0ppkEtKaZI7SmmT60ppk/9CWX//OkVb/zpFW/9CWX//SmmT/0ppk/NKaZJDSmmQS0ppkAP///wD///8A0ppkANKaZADSmmQA0ppkKtKaZLrSmmT/0ppk/9KaZP/SmmT/0ppkvNKaZCrSmmQA0ppkANKaZAD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkUtKaZNzSmmTc0ppkVNKaZADSmmQA0ppkANKaZADSmmQA////AP5/AAD4HwAA4AcAAMADAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAMADAADgBwAA+B8AAP5/AAAoAAAAIAAAAEAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAyCRACMgkQA6oJEAOqCRACQgkQAEIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRABigkQA5oJEAP+CRAD/gkQA/4JEAP+CRADqgkQAZoJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAA4gkQAwoJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQAxIJEADyCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAP///wD///8A////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAWgkQAmIJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAJyCRAAYgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAdIJEAPCCRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAPSCRAB4gkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQASoJEANKCRAD/gkQA/4JEAP+CRAD/g0YA/39AAP9zLgD/bSQA/2shAP9rIQD/bSQA/3MuAP9/PwD/g0YA/4JEAP+CRAD/gkQA/4JEAP+CRADUgkQAToJEAACCRAAAgkQAAP///wD///8A////AP///wB+PwAAgkUAIoJEAKiCRAD/gkQA/4JEAP+CRAD/hEcA/4BBAP9sIwD/dTAA/5RfKv+viF7/vp56/76ee/+wiF7/lWAr/3YxAP9sIwD/f0AA/4RHAP+CRAD/gkQA/4JEAP+CRAD/gkQArIJEACaBQwAA////AP///wD///8A////AIBCAEBzNAD6f0EA/4NFAP+CRAD/gkQA/4VIAP92MwD/bSUA/6N1Tv/ezsL/////////////////////////////////38/D/6V3Uv9uJgD/dTEA/4VJAP+CRAD/gkQA/4JEAP+BQwD/fUAA/4FDAEj///8A////AP///wD///8AzJRd5qBlKf91NgD/dDUA/4JEAP+FSQD/cy4A/3YyAP/PuKP//////////////////////////////////////////////////////9K7qP94NQD/ciwA/4VJAP+CRAD/fkEA/35BAP+LSwD/mlYA6v///wD///8A////AP///wDdpnL/4qx3/8KJUv+PUhf/cTMA/3AsAP90LgD/4dK+/////////////////////////////////////////////////////////////////+TYxf91MAD/dTIA/31CAP+GRwD/llQA/6FcAP+gWwD8////AP///wD///8A////ANGZY/LSm2X/4ap3/92mcP+wdT3/byQA/8mwj////////////////////////////////////////////////////////////////////////////+LYxv9zLgP/jUoA/59bAP+hXAD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/RmWL/1p9q/9ubXv/XqXj////////////////////////////7+fD/vZyG/6BxS/+gcUr/vJuE//r37f//////////////////////3MOr/5dQBf+dVQD/nVkA/5xYAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmWP/yohJ//jo2P//////////////////////4NTG/4JDFf9lGAD/bSQA/20kAP9kGAD/fz8S/+Xb0f//////5NG9/6txN/+LOgD/m1QA/51aAP+cWAD/m1cA/5xYAP+cWADy////AP///wD///8A////ANKaZPLSmmT/0ppk/8+TWf/Unmv//v37//////////////////////+TWRr/VwsA/35AAP+ERgD/g0UA/4JGAP9lHgD/kFga/8KXX/+TRwD/jT4A/49CAP+VTQD/n10A/5xYAP+OQQD/lk4A/55cAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/y4tO/92yiP//////////////////////8NnE/8eCQP+rcTT/ez0A/3IyAP98PgD/gEMA/5FSAP+USwD/jj8A/5lUAP+JNwD/yqV2/694Mf+HNQD/jkAA/82rf/+laBj/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/LiUr/4byY///////////////////////gupX/0I5P/+Wuev/Lklz/l1sj/308AP+QSwD/ol0A/59aAP+aVQD/k0oA/8yoh///////+fXv/6pwO//Lp3v///////Pr4f+oay7y////AP///wD///8A////ANKaZPLSmmT/0ppk/8uJSv/hvJj//////////////////////+G7l//Jhkb/0ppk/96nc//fqXX/x4xO/6dkFP+QSQD/llEA/5xXAP+USgD/yaOA///////38uv/qG05/8ijdv//////8efb/6ZpLPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/zIxO/9yxh///////////////////////7dbA/8iEQf/Sm2X/0Zlj/9ScZv/eqHf/2KJv/7yAQf+XTgD/iToA/5lSAP+JNgD/yKFv/611LP+HNQD/jT8A/8qmeP+kZRT/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/Pk1n/1J5q//78+//////////////////+/fv/1aFv/8iEQv/Tm2b/0ppl/9GZY//Wn2z/1pZc/9eldf/Bl2b/kUcA/4w9AP+OQAD/lUwA/59eAP+cWQD/jT8A/5ZOAP+eXADy////AP///wD///8A////ANKaZPLSmmT/0ppk/9KZY//KiEn/8d/P///////////////////////47+f/05tm/8iCP//KiEj/yohJ/8eCP//RmGH//vfy///////n1sP/rXQ7/4k4AP+TTAD/nVoA/5xYAP+cVwD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/0ptl/8uLTf/aq37////////////////////////////+/fz/6c2y/961jv/etY7/6Myx//78+v//////////////////////3MWv/5xXD/+ORAD/mFQA/51ZAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmmT/0ppk/8mFRP/s1b//////////////////////////////////////////////////////////////////////////////+PD/0JFU/7NzMv+WUQD/kUsA/5tXAP+dWQDy////AP///wD///8A////ANKaZP/SmmT/0ppk/9KaZP/Sm2X/z5NZ/8yMT//z5NX/////////////////////////////////////////////////////////////////9Ofa/8yNUP/UmGH/36p5/8yTWv+qaSD/kksA/5ROAPz///8A////AP///wD///8A0ppk5NKaZP/SmmT/0ppk/9KaZP/TnGf/zY9T/82OUv/t1sD//////////////////////////////////////////////////////+7Yw//OkFX/zI5R/9OcZ//SmmP/26V0/9ymdf/BhUf/ol8R6P///wD///8A////AP///wDSmmQ80ppk9tKaZP/SmmT/0ppk/9KaZP/TnGj/zpFW/8qJSv/dson/8uHS//////////////////////////////////Lj0//etIv/y4lL/86QVf/TnGj/0ppk/9KaZP/RmWP/05xn/9ymdfjUnWdC////AP///wD///8A////ANKaZADSmmQc0ppkotKaZP/SmmT/0ppk/9KaZP/Tm2b/0Zli/8qJSf/NjlH/16Z3/+G8mP/myKr/5siq/+G8mP/Xp3f/zY5S/8qISf/RmGH/05tm/9KaZP/SmmT/0ppk/9KaZP/SmmSm0pljINWdaQD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkQtKaZMrSmmT/0ppk/9KaZP/SmmT/0ptl/9GYYf/Nj1P/y4lL/8qISP/KiEj/y4lK/82PU//RmGH/0ptl/9KaZP/SmmT/0ppk/9KaZP/SmmTO0ppkRtKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZGzSmmTu0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmTw0ppkcNKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZBLSmmSQ0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppklNKaZBTSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQy0ppkutKaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppkvtKaZDbSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkXNKaZODSmmT/0ppk/9KaZP/SmmT/0ppk5NKaZGDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkBtKaZIbSmmTo0ppk6tKaZIrSmmQK0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP/8P///+B///+AH//+AAf//AAD//AAAP/AAAA/gAAAHwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA+AAAAfwAAAP/AAAP/8AAP//gAH//+AH///4H////D//" rel="icon" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
</head>
<body>
<div class="wrapper">
<header id="title-block-header">
<h1 class="title" style="text-align:center">Extending support for class types as non-type template parameters</h1>

<table style="border:none;float:right">
  <tr>
    <td>Document #:</td>
    <td>P2484R0</td>
  </tr>
  <tr>
    <td>Date:</td>
    <td>2021-11-13</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Project:</td>
    <td>Programming Language C++</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Audience:</td>
    <td>
      EWG<br>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top">Reply-to:</td>
    <td>
      Richard Smith<br>&lt;<a href="mailto:richard@metafoo.co.uk" class="email">richard@metafoo.co.uk</a>&gt;<br>
      Barry Revzin<br>&lt;<a href="mailto:barry.revzin@gmail.com" class="email">barry.revzin@gmail.com</a>&gt;<br>
    </td>
  </tr>
</table>

</header>
<div style="clear:both">
<div id="TOC" role="doc-toc">
<h1 id="toctitle">Contents</h1>
<ul>
<li><a href="#abstract"><span class="toc-section-number">1</span> Abstract<span></span></a></li>
<li><a href="#introduction"><span class="toc-section-number">2</span> Introduction<span></span></a></li>
<li><a href="#proposal-operator-template"><span class="toc-section-number">3</span> Proposal: <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">template</span><span class="op">()</span></code><span></span></a>
<ul>
<li><a href="#use-of-operator-template"><span class="toc-section-number">3.1</span> Use of <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">template</span></code><span></span></a></li>
<li><a href="#variable-length-representation"><span class="toc-section-number">3.2</span> Variable-length representation<span></span></a></li>
<li><a href="#string_view-and-span"><span class="toc-section-number">3.3</span> <code class="sourceCode cpp">string_view</code> and <code class="sourceCode cpp">span</code><span></span></a></li>
<li><a href="#reference-types"><span class="toc-section-number">3.4</span> Reference types<span></span></a></li>
<li><a href="#direction-for-c23"><span class="toc-section-number">3.5</span> Direction for C++23<span></span></a></li>
</ul></li>
<li><a href="#proposal"><span class="toc-section-number">4</span> Proposal<span></span></a>
<ul>
<li><a href="#language-wording"><span class="toc-section-number">4.1</span> Language Wording<span></span></a></li>
<li><a href="#library-wording"><span class="toc-section-number">4.2</span> Library Wording<span></span></a></li>
<li><a href="#feature-test-macros"><span class="toc-section-number">4.3</span> Feature-test macros<span></span></a></li>
</ul></li>
<li><a href="#bibliography"><span class="toc-section-number">5</span> References<span></span></a></li>
</ul>
</div>
<h1 data-number="1" style="border-bottom:1px solid #cccccc" id="abstract"><span class="header-section-number">1</span> Abstract<a href="#abstract" class="self-link"></a></h1>
<p>C++20 introduced the ability to have class types as non-type template parameters. This paper extends the set of types that can be used as non-type template parameters (to allow <code class="sourceCode cpp">std<span class="op">::</span>tuple<span class="op">&lt;</span>T<span class="op">...&gt;</span></code>, <code class="sourceCode cpp">std<span class="op">::</span>optional<span class="op">&lt;</span>T<span class="op">&gt;</span></code>, and <code class="sourceCode cpp">std<span class="op">::</span>variant<span class="op">&lt;</span>T<span class="op">...&gt;</span></code>) and provides a direction for extending it further in the future (to eventually allow <code class="sourceCode cpp">std<span class="op">::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span></code> and <code class="sourceCode cpp">std<span class="op">::</span>string</code>).</p>
<h1 data-number="2" style="border-bottom:1px solid #cccccc" id="introduction"><span class="header-section-number">2</span> Introduction<a href="#introduction" class="self-link"></a></h1>
<p><span class="citation" data-cites="P0732R2">[<a href="#ref-P0732R2" role="doc-biblioref">P0732R2</a>]</span> first introduced the ability to have class types as non-type template parameters. The original design was based on defaulting <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">&lt;=&gt;</span></code>. But there were problems with and limits to this approach, as described in <span class="citation" data-cites="P1907R0">[<a href="#ref-P1907R0" role="doc-biblioref">P1907R0</a>]</span>. A subsequent design, <span class="citation" data-cites="P1907R1">[<a href="#ref-P1907R1" role="doc-biblioref">P1907R1</a>]</span>, was adopted for C++20.</p>
<p>This design introduces the term <em>structural type</em>, as defined in <span>13.2 <a href="https://wg21.link/temp.param">[temp.param]</a></span>/7:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_1" id="pnum_1">7</a></span> A <em>structural type</em> is one of the following:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_2" id="pnum_2">(7.1)</a></span> a scalar type, or</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_3" id="pnum_3">(7.2)</a></span> an lvalue reference type, or</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_4" id="pnum_4">(7.3)</a></span> a literal class type with the following properties:
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_5" id="pnum_5">(7.3.1)</a></span> all base classes and non-static data members are public and non-mutable and</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_6" id="pnum_6">(7.3.2)</a></span> the types of all bases classes and non-static data members are structural types or (possibly multi-dimensional) array thereof.</li>
</ul></li>
</ul>
</blockquote>
<p>The all-public restriction is to ensure that doing template equivalence on every member is a sensible decision to make, as the kind of type for which this is wrong (e.g. <code class="sourceCode cpp">std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span></code>) will likely have its members private.</p>
<p>The result of this is that many types become usable as non-type template parameters, like <code class="sourceCode cpp">std<span class="op">::</span>pair<span class="op">&lt;</span><span class="dt">int</span>, <span class="dt">int</span><span class="op">&gt;</span></code> and <code class="sourceCode cpp">std<span class="op">::</span>array<span class="op">&lt;</span><span class="dt">int</span>, <span class="dv">2</span><span class="op">&gt;</span></code>. But many other similar ones don’t, like <code class="sourceCode cpp">std<span class="op">::</span>tuple<span class="op">&lt;</span><span class="dt">int</span>, <span class="dt">int</span><span class="op">&gt;</span></code> or <code class="sourceCode cpp">std<span class="op">::</span>optional<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span></code>. For both of these, member-wise equivalence would actually do the right thing - but these types are not going to be implemented with all-public members, so they just don’t work with the C++20 rules. All we need for <code class="sourceCode cpp">tuple</code> and <code class="sourceCode cpp">optional</code> and <code class="sourceCode cpp">variant</code> is the ability to opt in to the default member-wise equivalence rules we already have.</p>
<p>But going forward, that’s not quite sufficient for several important types. Eventually, it would be nice to be able to use <code class="sourceCode cpp">std<span class="op">::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span></code> and <code class="sourceCode cpp">std<span class="op">::</span>string</code> as non-type template parameters. A <code class="sourceCode cpp">string</code> might be implemented as <code class="sourceCode cpp">tuple<span class="op">&lt;</span><span class="dt">char</span><span class="op">*</span>, <span class="dt">char</span><span class="op">*</span>, <span class="dt">char</span><span class="op">*&gt;</span></code> (or perhaps one pointer and two sizes), but examining all three pointer values is not the right model, otherwise code like this would never work:</p>
<blockquote>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>string S<span class="op">&gt;</span> <span class="kw">struct</span> X <span class="op">{</span> <span class="op">}</span>;</span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a>X<span class="op">&lt;</span><span class="st">&quot;hello&quot;</span><span class="op">&gt;</span> a;</span>
<span id="cb1-4"><a href="#cb1-4"></a>X<span class="op">&lt;</span><span class="st">&quot;hello&quot;</span><span class="op">&gt;</span> b;</span>
<span id="cb1-5"><a href="#cb1-5"></a>a <span class="op">=</span> b;</span></code></pre></div>
</blockquote>
<p>The expectation is that <code class="sourceCode cpp">a</code> and <code class="sourceCode cpp">b</code> have the same type, but if template equivalence were based on the underlying pointers of the <code class="sourceCode cpp">string</code>, those two <code class="sourceCode cpp">string</code>s would have allocated their memory differently and so would have different pointers! We need something different here.</p>
<h1 data-number="3" style="border-bottom:1px solid #cccccc" id="proposal-operator-template"><span class="header-section-number">3</span> Proposal: <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">template</span><span class="op">()</span></code><a href="#proposal-operator-template" class="self-link"></a></h1>
<p>The proposal is that a type, <code class="sourceCode cpp">T</code>, can define an <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">template</span></code> which returns a type <code class="sourceCode cpp">R</code>. <code class="sourceCode cpp">R</code> must be a structural type, and acts as the representation of <code class="sourceCode cpp">T</code>. <code class="sourceCode cpp">T</code> must also be constructible from <code class="sourceCode cpp">R</code>.</p>
<p>For a example:</p>
<blockquote>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">class</span> A <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>    <span class="dt">int</span> i;</span>
<span id="cb2-4"><a href="#cb2-4"></a></span>
<span id="cb2-5"><a href="#cb2-5"></a>    <span class="kw">struct</span> Repr <span class="op">{</span> <span class="dt">int</span> i; <span class="op">}</span>;</span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a>    <span class="kw">constexpr</span> A<span class="op">(</span>Repr r<span class="op">)</span> <span class="op">:</span> i<span class="op">(</span>r<span class="op">.</span>i<span class="op">)</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span> <span class="kw">template</span><span class="op">()</span> <span class="kw">const</span> <span class="op">-&gt;</span> Repr <span class="op">{</span> <span class="cf">return</span> <span class="op">{</span>i<span class="op">}</span>; <span class="op">}</span></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb2-10"><a href="#cb2-10"></a>    <span class="kw">constexpr</span> A<span class="op">(</span><span class="dt">int</span> i<span class="op">)</span> <span class="op">:</span> i<span class="op">(</span>i<span class="op">)</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="op">}</span>;</span>
<span id="cb2-12"><a href="#cb2-12"></a></span>
<span id="cb2-13"><a href="#cb2-13"></a><span class="kw">template</span> <span class="op">&lt;</span>A a<span class="op">&gt;</span> <span class="kw">struct</span> X <span class="op">{</span> <span class="op">}</span>;</span></code></pre></div>
</blockquote>
<p><code class="sourceCode cpp">A</code> by default is not structural (it has a private member), but its <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">template</span></code> returns <code class="sourceCode cpp">Repr</code> (which <em>is</em> structural) and <code class="sourceCode cpp">A</code> is constructible from <code class="sourceCode cpp">Repr</code>. The compiler will use <code class="sourceCode cpp">Repr</code> to determine <code class="sourceCode cpp">A</code>’s template equivalence rules (as well as its mangling).</p>
<p><code class="sourceCode cpp">A<span class="op">{</span><span class="dv">1</span><span class="op">}</span></code> and <code class="sourceCode cpp">A<span class="op">{</span><span class="dv">1</span><span class="op">}</span></code> are equivalent because <code class="sourceCode cpp">A<span class="op">::</span>Repr<span class="op">{</span><span class="dv">1</span><span class="op">}</span></code> and <code class="sourceCode cpp">A<span class="op">::</span>Repr<span class="op">{</span><span class="dv">1</span><span class="op">}</span></code> are equivalent.</p>
<p>This example can be simplified. We need some representation that can encapsulate an <code class="sourceCode cpp"><span class="dt">int</span></code>, but we don’t need a whole new type for that:</p>
<blockquote>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">class</span> A2 <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>    <span class="dt">int</span> i;</span>
<span id="cb3-4"><a href="#cb3-4"></a></span>
<span id="cb3-5"><a href="#cb3-5"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span> <span class="kw">template</span><span class="op">()</span> <span class="kw">const</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span> <span class="cf">return</span> i; <span class="op">}</span></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>    <span class="kw">constexpr</span> A2<span class="op">(</span><span class="dt">int</span> i<span class="op">)</span> <span class="op">:</span> i<span class="op">(</span>i<span class="op">)</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="op">}</span>;</span>
<span id="cb3-9"><a href="#cb3-9"></a></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="kw">template</span> <span class="op">&lt;</span>A2 a<span class="op">&gt;</span> <span class="kw">struct</span> X <span class="op">{</span> <span class="op">}</span>;</span></code></pre></div>
</blockquote>
<p>The above implementation is also sufficient, because <code class="sourceCode cpp"><span class="dt">int</span></code> is structural.</p>
<p>But extending the above example to handle <em>multiple</em> private members would be very tedious if we had to do it by hand. What would you do for <code class="sourceCode cpp">tuple</code>? Implement a whole new <code class="sourceCode cpp">tuple</code> that is all-public instead of all-private? So instead, the model allows for defaulting <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">template</span><span class="op">()</span></code>:</p>
<blockquote>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">class</span> A3 <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>    <span class="dt">int</span> i;</span>
<span id="cb4-4"><a href="#cb4-4"></a>    <span class="dt">int</span> j;</span>
<span id="cb4-5"><a href="#cb4-5"></a></span>
<span id="cb4-6"><a href="#cb4-6"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span> <span class="kw">template</span><span class="op">()</span> <span class="kw">const</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb4-8"><a href="#cb4-8"></a>    <span class="kw">constexpr</span> A3<span class="op">(</span><span class="dt">int</span> i, <span class="dt">int</span> j<span class="op">)</span> <span class="op">:</span> i<span class="op">(</span>i<span class="op">)</span>, j<span class="op">(</span>j<span class="op">)</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="op">}</span>;</span>
<span id="cb4-10"><a href="#cb4-10"></a></span>
<span id="cb4-11"><a href="#cb4-11"></a><span class="kw">template</span> <span class="op">&lt;</span>A3 a<span class="op">&gt;</span> <span class="kw">struct</span> X <span class="op">{</span> <span class="op">}</span>;</span></code></pre></div>
</blockquote>
<p>This paper is proposing the above be valid. A type with a defaulted <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">template</span></code> would base its equivalence on all of its base classes and subobjects, same as a C++20 structural class type. The only difference would be that those base classes and subobjects would be allowed to be private.</p>
<p>Note, though, that this is not recursive:</p>
<blockquote>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">class</span> B <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>    <span class="dt">int</span> i;</span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="op">}</span>;</span>
<span id="cb5-4"><a href="#cb5-4"></a></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="kw">class</span> D <span class="op">:</span> B <span class="op">{</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>    <span class="dt">int</span> j;</span>
<span id="cb5-7"><a href="#cb5-7"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span> <span class="kw">template</span><span class="op">()</span> <span class="kw">const</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="op">}</span>;</span>
<span id="cb5-9"><a href="#cb5-9"></a></span>
<span id="cb5-10"><a href="#cb5-10"></a><span class="kw">template</span> <span class="op">&lt;</span>D d<span class="op">&gt;</span> <span class="co">// error: D is not structural because B is not structural</span></span>
<span id="cb5-11"><a href="#cb5-11"></a><span class="kw">struct</span> Y <span class="op">{</span> <span class="op">}</span>;  <span class="co">// ... and B is not structural because it has a private member</span></span></code></pre></div>
</blockquote>
<h2 data-number="3.1" id="use-of-operator-template"><span class="header-section-number">3.1</span> Use of <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">template</span></code><a href="#use-of-operator-template" class="self-link"></a></h2>
<p>The only intent of <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">template</span></code> is to allow the compiler to determine template equivalence and mangling. No program ever need invoke it for any reason, so no provision need to made in the language for allowing it or defining what that means. This avoids the question of what exactly the return type of a defaulted <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">template</span></code> is: it doesn’t matter, it’s just annotation.</p>
<p>No program ever needs to invoke an <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">template</span></code> because of the recursive nature of the definition of structural. In order to incorporate some user-defined type <code class="sourceCode cpp">C</code> into your mangling, you simply use it directly:</p>
<blockquote>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">class</span> A <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>    C c;  <span class="co">// some user-defined type (possibly C++20 structural, possibly has operator template)</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>    D d;  <span class="co">// some other user-defined type that doesn&#39;t participate in mangling for some reason</span></span>
<span id="cb6-5"><a href="#cb6-5"></a></span>
<span id="cb6-6"><a href="#cb6-6"></a>    <span class="kw">struct</span> Repr <span class="op">{</span> C c; <span class="op">}</span>;</span>
<span id="cb6-7"><a href="#cb6-7"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span> <span class="kw">template</span><span class="op">()</span> <span class="kw">const</span> <span class="op">{</span> <span class="cf">return</span> Repr<span class="op">{</span>c<span class="op">}</span>; <span class="op">}</span></span>
<span id="cb6-8"><a href="#cb6-8"></a>    <span class="kw">explicit</span> <span class="kw">constexpr</span> A<span class="op">(</span>Repr<span class="op">)</span>;</span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="op">}</span>;</span></code></pre></div>
</blockquote>
<p>If <code class="sourceCode cpp">C</code> is structural, regardless of how it gets there (whether <code class="sourceCode cpp">C</code> is an alias for <code class="sourceCode cpp"><span class="dt">int</span></code> or has a custom <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">template</span></code>), <code class="sourceCode cpp">Repr</code> is structural and correctly uses <code class="sourceCode cpp">C</code>’s equivalence rules. No need for any <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">template</span></code> invocation here.</p>
<h2 data-number="3.2" id="variable-length-representation"><span class="header-section-number">3.2</span> Variable-length representation<a href="#variable-length-representation" class="self-link"></a></h2>
<p>The model for defaulted <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">template</span></code> allows for letting <code class="sourceCode cpp">tuple</code>, <code class="sourceCode cpp">optional</code>, and <code class="sourceCode cpp">variant</code> opt in to being used as non-type template parameters. The simple member-wise equivalence is correct for all of these types. But it doesn’t help us with <code class="sourceCode cpp">vector</code> or <code class="sourceCode cpp">string</code>. For that, we need some kind of variable-length type that the compiler recognizes as defining a representation.</p>
<p>The obvious choice there would be: <code class="sourceCode cpp">vector<span class="op">&lt;</span>T<span class="op">&gt;</span></code>.</p>
<p>That is, <code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span></code> would just be usable by default (as being a <code class="sourceCode cpp">vector</code> of a structural type, <code class="sourceCode cpp"><span class="dt">int</span></code>), while <code class="sourceCode cpp">string</code> would opt in by doing:</p>
<blockquote>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">class</span> simplified_string <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>    <span class="dt">char</span><span class="op">*</span> begin_;</span>
<span id="cb7-3"><a href="#cb7-3"></a>    <span class="dt">char</span><span class="op">*</span> end_;</span>
<span id="cb7-4"><a href="#cb7-4"></a>    <span class="dt">char</span><span class="op">*</span> capacity_;</span>
<span id="cb7-5"><a href="#cb7-5"></a></span>
<span id="cb7-6"><a href="#cb7-6"></a>    <span class="kw">struct</span> repr <span class="op">{</span> std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;</span> v; <span class="op">}</span>;</span>
<span id="cb7-7"><a href="#cb7-7"></a>    <span class="kw">constexpr</span> simplified_string<span class="op">(</span>repr r<span class="op">)</span></span>
<span id="cb7-8"><a href="#cb7-8"></a>        <span class="op">:</span> simplified_string<span class="op">(</span>r<span class="op">.</span>v<span class="op">.</span>begin<span class="op">()</span>, r<span class="op">.</span>v<span class="op">.</span>end<span class="op">())</span></span>
<span id="cb7-9"><a href="#cb7-9"></a>    <span class="op">{</span> <span class="op">}</span></span>
<span id="cb7-10"><a href="#cb7-10"></a></span>
<span id="cb7-11"><a href="#cb7-11"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span> <span class="kw">template</span><span class="op">()</span> <span class="kw">const</span> <span class="op">-&gt;</span> repr <span class="op">{</span></span>
<span id="cb7-12"><a href="#cb7-12"></a>        <span class="cf">return</span> repr<span class="op">{.</span>v<span class="op">=</span>std<span class="op">::</span>vector<span class="op">(</span>begin_, end_<span class="op">)}</span>;</span>
<span id="cb7-13"><a href="#cb7-13"></a>    <span class="op">}</span></span>
<span id="cb7-14"><a href="#cb7-14"></a><span class="op">}</span>;</span></code></pre></div>
</blockquote>
<p>However, in order to support this approach, the language needs to be able to support non-transient constexpr allocation. Otherwise, non-type template parameters of <code class="sourceCode cpp">string</code> or <code class="sourceCode cpp">vector</code> type can’t even exist. <span class="citation" data-cites="P0784R7">[<a href="#ref-P0784R7" role="doc-biblioref">P0784R7</a>]</span> originally attempted to solve this problem by introducing <code class="sourceCode cpp">std<span class="op">::</span>mark_immutable_if_constexpr</code>, but this direction was rejected. <span class="citation" data-cites="P1974R0">[<a href="#ref-P1974R0" role="doc-biblioref">P1974R0</a>]</span> proposes to solve this problem using a new <code class="sourceCode cpp">propconst</code> qualifier.</p>
<p>Regardless of which approach is taken, once the language supports non-transient constexpr allocation, the <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">template</span></code> model can be extended to recognize <code class="sourceCode cpp">vector<span class="op">&lt;</span>T<span class="op">&gt;</span></code> as being a structural type when <code class="sourceCode cpp">T</code> is a structural type.</p>
<h2 data-number="3.3" id="string_view-and-span"><span class="header-section-number">3.3</span> <code class="sourceCode cpp">string_view</code> and <code class="sourceCode cpp">span</code><a href="#string_view-and-span" class="self-link"></a></h2>
<p>While <code class="sourceCode cpp">string_view</code> compares the contents that it refers to and <code class="sourceCode cpp">span</code> should as well, the question is: how should these types behave were they to be allowed as non-type template parameters? Put differently:</p>
<blockquote>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">const</span> <span class="dt">char</span> a<span class="op">[]</span> <span class="op">=</span> <span class="st">&quot;Hello&quot;</span>;</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="kw">const</span> <span class="dt">char</span> b<span class="op">[]</span> <span class="op">=</span> <span class="st">&quot;Hello&quot;</span>;</span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="kw">template</span> <span class="op">&lt;</span>string_view S<span class="op">&gt;</span> <span class="kw">struct</span> C <span class="op">{</span> <span class="op">}</span>;</span></code></pre></div>
</blockquote>
<p>Are <code class="sourceCode cpp">C<span class="op">&lt;</span>a<span class="op">&gt;</span></code> and <code class="sourceCode cpp">C<span class="op">&lt;</span>b<span class="op">&gt;</span></code> the same type (because <code class="sourceCode cpp">string_view<span class="op">(</span>a<span class="op">)</span> <span class="op">==</span> string_view<span class="op">(</span>b<span class="op">)</span></code>) or different types (because their pointers point to different storage)? It basically has <em>has</em> to be the latter interpretation. Template equivalence is not <code class="sourceCode cpp"><span class="op">==</span></code>, which is why we replaced P0732 with P1907 to begin with. Users that want the former interpretation will have to use <code class="sourceCode cpp">string</code>, not <code class="sourceCode cpp">string_view</code>.</p>
<p>This begs the question of whether <code class="sourceCode cpp">string_view</code> and <code class="sourceCode cpp">span</code> should be usable as non-type template parameters (i.e. by providing a defaulted <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">template</span></code>), but this paper takes no position on that question.</p>
<h2 data-number="3.4" id="reference-types"><span class="header-section-number">3.4</span> Reference types<a href="#reference-types" class="self-link"></a></h2>
<p>An earlier example in this paper illustrated a custom <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">template</span></code> returning an <code class="sourceCode cpp"><span class="dt">int</span></code>. It is worth considering what would happen if it were instead written, accidentally, to return an <code class="sourceCode cpp"><span class="dt">int</span><span class="op">&amp;</span></code>:</p>
<blockquote>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">class</span> A4 <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>    <span class="dt">int</span> i;</span>
<span id="cb9-4"><a href="#cb9-4"></a></span>
<span id="cb9-5"><a href="#cb9-5"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span> <span class="kw">template</span><span class="op">()</span> <span class="kw">const</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="kw">const</span><span class="op">&amp;</span> <span class="op">{</span> <span class="cf">return</span> i; <span class="op">}</span></span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb9-7"><a href="#cb9-7"></a>    <span class="kw">constexpr</span> A4<span class="op">(</span><span class="dt">int</span> i<span class="op">)</span> <span class="op">:</span> i<span class="op">(</span>i<span class="op">)</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb9-8"><a href="#cb9-8"></a><span class="op">}</span>;</span>
<span id="cb9-9"><a href="#cb9-9"></a></span>
<span id="cb9-10"><a href="#cb9-10"></a><span class="kw">template</span> <span class="op">&lt;</span>A4 a<span class="op">&gt;</span> <span class="kw">struct</span> X <span class="op">{</span> <span class="op">}</span>;</span>
<span id="cb9-11"><a href="#cb9-11"></a><span class="kw">constexpr</span> A4 i <span class="op">=</span> <span class="dv">1</span>;</span>
<span id="cb9-12"><a href="#cb9-12"></a><span class="kw">constexpr</span> A4 j <span class="op">=</span> <span class="dv">1</span>;</span></code></pre></div>
</blockquote>
<p><code class="sourceCode cpp"><span class="dt">int</span> <span class="kw">const</span><span class="op">&amp;</span></code> is also a structural type (lvalue references are structural), but it is <em>differently</em> structural from <code class="sourceCode cpp"><span class="dt">int</span></code>. Equivalence for <code class="sourceCode cpp"><span class="dt">int</span> <span class="kw">const</span><span class="op">&amp;</span></code> is based on the <em>address</em>, while for <code class="sourceCode cpp"><span class="dt">int</span></code> it’s based on the value. <code class="sourceCode cpp">X<span class="op">&lt;</span>i<span class="op">&gt;</span></code> and <code class="sourceCode cpp">X<span class="op">&lt;</span>j<span class="op">&gt;</span></code> would have to be different types, because their underlying <code class="sourceCode cpp"><span class="dt">int</span></code>s are different. This mistake would be pretty broken.</p>
<p>However, the compiler should be able to reject such cases, because once we create <code class="sourceCode cpp">X<span class="op">&lt;</span>i<span class="op">&gt;</span></code>, the representation of the template parameter object would be different from the representation of <code class="sourceCode cpp">i</code>.</p>
<p>But there will be cases where it is the correct behavior to return a reference type from <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">template</span></code>, so it’s not something that can be rejected out of hand.</p>
<h2 data-number="3.5" id="direction-for-c23"><span class="header-section-number">3.5</span> Direction for C++23<a href="#direction-for-c23" class="self-link"></a></h2>
<p>Because we don’t have non-transient constexpr allocation yet, the only really interesting cases for <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">template</span></code> are those that let you use types with private members as non-type template parameters. So while this model presents a clear direction for how to extend support in the future to allow <code class="sourceCode cpp">vector</code>, <code class="sourceCode cpp">string</code>, and others to be usable as non-type template parameters, the C++23 paper is a lot narrower: only allow defaulted <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">template</span></code>.</p>
<p>This direction allows <code class="sourceCode cpp">tuple</code>, <code class="sourceCode cpp">optional</code>, and <code class="sourceCode cpp">variant</code>, and lots and of class types. Which seems plenty useful.</p>
<p>As discussed earlier, we also for now say that <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">template</span></code> that <em>cannot</em> be invoked by the program - it’s <em>solely</em> for use by the compiler. This avoids the question of what happens if a program refers to it and what return type they see: there simply will be no such reference. There can be only one <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">template</span></code> per class, its <em>cv-qualifier-seq</em> must be <code class="sourceCode cpp"><span class="kw">const</span></code> and its <em>ref-qualifier</em> must be empty. Perhaps in the future, these restrictions can be lifted if the need arises, but being conservative here doesn’t deprive us of functionality.</p>
<h1 data-number="4" style="border-bottom:1px solid #cccccc" id="proposal"><span class="header-section-number">4</span> Proposal<a href="#proposal" class="self-link"></a></h1>
<p>A class type can define <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">template</span></code> as defaulted (returning <code class="sourceCode cpp"><span class="kw">auto</span></code>, with a <em>cv-qualifier-seq</em> of <code class="sourceCode cpp"><span class="kw">const</span></code>, and no <em>ref-qualifier</em>, and of course declared <code class="sourceCode cpp"><span class="kw">constexpr</span></code>) in the body of the class. A class type with such an <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">template</span></code> is a structural type if all of its base classes and non-static data members have structural type and none of them are <code class="sourceCode cpp"><span class="kw">mutable</span></code>.</p>
<p>This is only valid if all base classes and non-static data members have structural types - however we don’t want to call this ill-formed if this rule is violated. If <code class="sourceCode cpp">tuple<span class="op">&lt;</span><span class="dt">int</span>, non_structural<span class="op">&gt;</span></code> providing a defaulted <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">template</span></code> were ill-formed, then <code class="sourceCode cpp">tuple</code> would have to constrain its <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">template</span></code> on all the types being structural, but that’s basically the only constraint that’s ever meaningful - so it seems reasonable to have defaulting <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">template</span></code> actually mean that. But even a (non-template) class having a <code class="sourceCode cpp">string</code> member defining <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">template</span></code> as defaulted doesn’t worth rejecting, for the same reasons as laid out in <span class="citation" data-cites="P2448R0">[<a href="#ref-P2448R0" role="doc-biblioref">P2448R0</a>]</span>: <code class="sourceCode cpp">string</code> will eventually be usable as a non-type template parameter, so let users write the declaration early.</p>
<p>Add defaulted <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">template</span></code> to <code class="sourceCode cpp">std<span class="op">::</span>tuple</code>, <code class="sourceCode cpp">std<span class="op">::</span>optional</code>, and <code class="sourceCode cpp">std<span class="op">::</span>variant</code>.</p>
<h2 data-number="4.1" id="language-wording"><span class="header-section-number">4.1</span> Language Wording<a href="#language-wording" class="self-link"></a></h2>
<p>Add a new clause called “Template representation functions” after <span>11.4.8.3 <a href="https://wg21.link/class.conv.fct">[class.conv.fct]</a></span> that will define <code class="sourceCode cpp"><span class="kw">operator</span> <span class="kw">template</span></code>:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_7" id="pnum_7">1</a></span> A member function of the form:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb10-1"><a href="#cb10-1"></a><em>template-representation-function</em>:</span>
<span id="cb10-2"><a href="#cb10-2"></a>    operator template</span></code></pre></div>
<p>shall have no parameters, have a <em>cv-qualifier-seq</em> consisting of exactly <code class="sourceCode cpp"><span class="kw">const</span></code>, have no <em>ref-qualifier</em>, have a return type of <code class="sourceCode cpp"><span class="kw">auto</span></code>, and shall be defined as defaulted on its first declaration. Such a function is called a <em>template representation function</em>. [<em>Note</em>: A template representation function can be used to opt a class type with private data members or private base classes into being a structural type ([temp.param]). -<em>end note</em>]</p>
</blockquote>
<p>Change <span>13.2 <a href="https://wg21.link/temp.param">[temp.param]</a></span>/7:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized" href="#pnum_8" id="pnum_8">7</a></span> A <em>structural type</em> is one of the following:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_9" id="pnum_9">(7.1)</a></span> a scalar type, or</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_10" id="pnum_10">(7.2)</a></span> an lvalue reference type, or</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_11" id="pnum_11">(7.3)</a></span> a literal class type with the following properties:
<ul>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_12" id="pnum_12">(7.3.1)</a></span> <span class="addu">no direct or indirect subobject is mutable</span> and</li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_13" id="pnum_13">(7.3.2)</a></span> <span class="addu">either the class defines a template representation function ([???]) or</span> all base classes and non-static data members are public <span class="rm" style="color: #bf0303"><del>and non-mutable</del></span> <span class="addu">and</span></li>
<li><span class="marginalizedparent"><a class="marginalized" href="#pnum_14" id="pnum_14">(7.3.3)</a></span> the types of all bases classes and non-static data members are structural types or (possibly multi-dimensional) array thereof.</li>
</ul></li>
</ul>
</blockquote>
<p>No changes to <span>13.6 <a href="https://wg21.link/temp.type">[temp.type]</a></span> necessary, since the class type equivalence rule (“their corresponding direct subobjects and reference members are template-argument-equivalent”) is still preserved with this change.</p>
<h2 data-number="4.2" id="library-wording"><span class="header-section-number">4.2</span> Library Wording<a href="#library-wording" class="self-link"></a></h2>
<p>Add to <span>20.5.3 <a href="https://wg21.link/tuple.tuple">[tuple.tuple]</a></span>:</p>
<blockquote>
<div>
<div class="sourceCode" id="cb11"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb11-1"><a href="#cb11-1"></a>namespace std {</span>
<span id="cb11-2"><a href="#cb11-2"></a>  template&lt;class... Types&gt;</span>
<span id="cb11-3"><a href="#cb11-3"></a>  class tuple {</span>
<span id="cb11-4"><a href="#cb11-4"></a>  public:</span>
<span id="cb11-5"><a href="#cb11-5"></a>    // ...</span>
<span id="cb11-6"><a href="#cb11-6"></a></span>
<span id="cb11-7"><a href="#cb11-7"></a>    // [tuple.swap], tuple swap</span>
<span id="cb11-8"><a href="#cb11-8"></a>    constexpr void swap(tuple&amp;) noexcept(see below);</span>
<span id="cb11-9"><a href="#cb11-9"></a>    constexpr void swap(const tuple&amp;) const noexcept(see below);</span>
<span id="cb11-10"><a href="#cb11-10"></a></span>
<span id="cb11-11"><a href="#cb11-11"></a><span class="va">+   constexpr auto operator template() const = default;</span></span>
<span id="cb11-12"><a href="#cb11-12"></a>  };</span>
<span id="cb11-13"><a href="#cb11-13"></a></span>
<span id="cb11-14"><a href="#cb11-14"></a>  // ...</span>
<span id="cb11-15"><a href="#cb11-15"></a>}</span></code></pre></div>
</div>
</blockquote>
<p>Add to <span>20.6.3.1 <a href="https://wg21.link/optional.optional.general">[optional.optional.general]</a></span>:</p>
<blockquote>
<div>
<div class="sourceCode" id="cb12"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb12-1"><a href="#cb12-1"></a>namespace std {</span>
<span id="cb12-2"><a href="#cb12-2"></a>  template&lt;class T&gt;</span>
<span id="cb12-3"><a href="#cb12-3"></a>  class optional {</span>
<span id="cb12-4"><a href="#cb12-4"></a>  public:</span>
<span id="cb12-5"><a href="#cb12-5"></a>    using value_type = T;</span>
<span id="cb12-6"><a href="#cb12-6"></a></span>
<span id="cb12-7"><a href="#cb12-7"></a>    // ...</span>
<span id="cb12-8"><a href="#cb12-8"></a></span>
<span id="cb12-9"><a href="#cb12-9"></a>    // [optional.mod], modifiers</span>
<span id="cb12-10"><a href="#cb12-10"></a>    constexpr void reset() noexcept;</span>
<span id="cb12-11"><a href="#cb12-11"></a></span>
<span id="cb12-12"><a href="#cb12-12"></a><span class="va">+   constexpr auto operator template() const = default;</span></span>
<span id="cb12-13"><a href="#cb12-13"></a></span>
<span id="cb12-14"><a href="#cb12-14"></a>  private:</span>
<span id="cb12-15"><a href="#cb12-15"></a>    T *val;         // exposition only</span>
<span id="cb12-16"><a href="#cb12-16"></a>  };</span>
<span id="cb12-17"><a href="#cb12-17"></a></span>
<span id="cb12-18"><a href="#cb12-18"></a>  template&lt;class T&gt;</span>
<span id="cb12-19"><a href="#cb12-19"></a>    optional(T) -&gt; optional&lt;T&gt;;</span>
<span id="cb12-20"><a href="#cb12-20"></a>}</span></code></pre></div>
</div>
</blockquote>
<p>Add to <span>20.7.3.1 <a href="https://wg21.link/variant.variant.general">[variant.variant.general]</a></span>:</p>
<blockquote>
<div>
<div class="sourceCode" id="cb13"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb13-1"><a href="#cb13-1"></a>namespace std {</span>
<span id="cb13-2"><a href="#cb13-2"></a>  template&lt;class... Types&gt;</span>
<span id="cb13-3"><a href="#cb13-3"></a>  class variant {</span>
<span id="cb13-4"><a href="#cb13-4"></a>  public:</span>
<span id="cb13-5"><a href="#cb13-5"></a>    // ...</span>
<span id="cb13-6"><a href="#cb13-6"></a></span>
<span id="cb13-7"><a href="#cb13-7"></a>    // [variant.swap], swap</span>
<span id="cb13-8"><a href="#cb13-8"></a>    constexpr void swap(variant&amp;) noexcept(see below);</span>
<span id="cb13-9"><a href="#cb13-9"></a></span>
<span id="cb13-10"><a href="#cb13-10"></a><span class="va">+   constexpr auto operator template() const = default;</span></span>
<span id="cb13-11"><a href="#cb13-11"></a>  };</span>
<span id="cb13-12"><a href="#cb13-12"></a>}</span></code></pre></div>
</div>
</blockquote>
<h2 data-number="4.3" id="feature-test-macros"><span class="header-section-number">4.3</span> Feature-test macros<a href="#feature-test-macros" class="self-link"></a></h2>
<p>Bump the non-type template argument macro in <span>15.11 <a href="https://wg21.link/cpp.predefined">[cpp.predefined]</a></span>:</p>
<blockquote>
<div>
<div class="sourceCode" id="cb14"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb14-1"><a href="#cb14-1"></a>__cpp_­nontype_­template_­args <span class="diffdel">201911L</span> <span class="diffins">2022XXL</span></span></code></pre></div>
</div>
</blockquote>
<p>Bump the corresponding library feature test macros in <span>17.3.2 <a href="https://wg21.link/version.syn">[version.syn]</a></span>. These seem like the most appropriate choices:</p>
<blockquote>
<div>
<div class="sourceCode" id="cb15"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb15-1"><a href="#cb15-1"></a>#define __cpp_­lib_­constexpr_­tuple   <span class="diffdel">201811L</span> <span class="diffins">2022XXL</span> // also in &lt;tuple&gt;</span>
<span id="cb15-2"><a href="#cb15-2"></a>#define __cpp_­lib_­optional          <span class="diffdel">202106L</span> <span class="diffins">2022XXL</span> // also in &lt;optional&gt;</span>
<span id="cb15-3"><a href="#cb15-3"></a>#define __cpp_­lib_­variant           <span class="diffdel">202106L</span> <span class="diffins">2022XXL</span> // also in &lt;variant&gt;</span></code></pre></div>
</div>
</blockquote>
<h1 data-number="5" style="border-bottom:1px solid #cccccc" id="bibliography"><span class="header-section-number">5</span> References<a href="#bibliography" class="self-link"></a></h1>
<div id="refs" class="references hanging-indent" role="doc-bibliography">
<div id="ref-P0732R2">
<p>[P0732R2] Jeff Snyder, Louis Dionne. 2018-06-06. Class Types in Non-Type Template Parameters. <br />
<a href="https://wg21.link/p0732r2">https://wg21.link/p0732r2</a></p>
</div>
<div id="ref-P0784R7">
<p>[P0784R7] Daveed Vandevoorde, Peter Dimov,Louis Dionne, Nina Ranns, Richard Smith, Daveed Vandevoorde. 2019-07-22. More constexpr containers. <br />
<a href="https://wg21.link/p0784r7">https://wg21.link/p0784r7</a></p>
</div>
<div id="ref-P1907R0">
<p>[P1907R0] Jens Maurer. 2019-10-07. Inconsistencies with non-type template parameters. <br />
<a href="https://wg21.link/p1907r0">https://wg21.link/p1907r0</a></p>
</div>
<div id="ref-P1907R1">
<p>[P1907R1] Jens Maurer. 2019-11-08. Inconsistencies with non-type template parameters. <br />
<a href="https://wg21.link/p1907r1">https://wg21.link/p1907r1</a></p>
</div>
<div id="ref-P1974R0">
<p>[P1974R0] Jeff Snyder, Louis Dionne, Daveed Vandevoorde. 2020-05-15. Non-transient constexpr allocation using propconst. <br />
<a href="https://wg21.link/p1974r0">https://wg21.link/p1974r0</a></p>
</div>
<div id="ref-P2448R0">
<p>[P2448R0] Barry Revzin. 2021-10-14. Relaxing some constexpr restrictions. <br />
<a href="https://wg21.link/p2448r0">https://wg21.link/p2448r0</a></p>
</div>
</div>
</div>
</div>
</body>
</html>
